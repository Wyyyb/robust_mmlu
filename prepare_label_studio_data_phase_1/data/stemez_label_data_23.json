[{"data": {"text": "Question:\nMrs. Jones has some money which she wants to invest in a number of activities (investment programs) in such a way that the total return is maximized. Assume that she has $8,000 for allocation and that the investments can only be integral multiples of $1000. Three investment programs are available. The return function for each program is tabulated below: Return Functions h_i (x) X(0000) 0 1 2 3 4 5 6 7 8 h_1(x) h_2(x) h_3(x) 0 0 0 5 5 4 15 15 26 40 40 40 80 60 45 90 70 50 95 73 51 98 74 52 100 75 53 Using the principles of dynamic programming, how would the optimal investment in each program be determined so as to maximize total return?\n\nOptions:\nA. The problem can be solved using a trial and error method.\nB. The problem can be solved using linear programming.\nC.             The problem can be solved recursively, using the principles of dynamic programming. The optimal solution for one stage is used as input for the next stage.\nD. The problem can be solved using calculus.\n\nAnswer: C\n\nReference Solution:\nThe problem can be solved recursively, i.e., the optimal solution for onestage is used as input for the next stage. Step 1: Assume that program 3 is the only program. Then the optimal returnfrom investing X = 0,1,2,...,8 inh_3(x) is given by the last row of the table above. In particular,h_3(8) = 53 isthe optimal return. Step 2: Now assume only programs 2 and 3 are available and that d_2 (x), d_3 (y) can be invested in programs 2 and 3, where x = 0,1,...,8 y = 0,1,2,...,8 and x + y = 0,1,2,...,8 Thus, with 8 we can invest 0 in 2 and 8 in 3, with 5 3 in 2 and 2 in 3 and so on. Find the optimum of all these choices for each x in 0,1,2,....8. The functional equation is f_2 (x) = max[g_2y + f_3(x)] y = 0,1,... ,8 - x x = 0,1,...,8 Step 3: The final stage is the same as the original prob-lem. We now assume all three programs are available. We examine the results of investing z in program 1 and 8 - z units in programs 2 and 3 (the optimal amounts for each 8 - z (z = 0,1,2, ..,8) have already been found in Step 2). The functional equation for the last stage is f_i ( x) = max [g_i(z) + f_i+1 (x - z) x = 0,...,8 Z = 0,1,.....,X d_i(x) = value of z that yieldsf_i(x) where f_i(x) is the optimal return from investing x units in programsi,i+ 1,..,3andd_i(x) is the optimal amount to invest in programiwhen x units are available to in-vest in programsi,i+ 1,..., 3 fori= 1,2,3.", "ref_id": 4600, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Mrs. Jones has some money which she wants to invest in a number of activities (investment programs) in such a way that the total return is maximized. Assume that she has $8,000 for allocation and that the investments can only be integral multiples of $1000. Three investment programs are available. The return function for each program is tabulated below: Return Functions h_i (x) X(0000) 0 1 2 3 4 5 6 7 8 h_1(x) h_2(x) h_3(x) 0 0 0 5 5 4 15 15 26 40 40 40 80 60 45 90 70 50 95 73 51 98 74 52 100 75 53 Using the principles of dynamic programming, how would the optimal investment in each program be determined so as to maximize total return?", "options": ["The problem can be solved using a trial and error method.", "The problem can be solved using linear programming.", "The problem can be solved recursively, using the principles of dynamic programming. The optimal solution for one stage is used as input for the next stage.", "The problem can be solved using calculus."], "answer": "C", "solution": "The problem can be solved recursively, i.e., the optimal solution for onestage is used as input for the next stage. Step 1: Assume that program 3 is the only program. Then the optimal returnfrom investing X = 0,1,2,...,8 inh_3(x) is given by the last row of the table above. In particular,h_3(8) = 53 isthe optimal return. Step 2: Now assume only programs 2 and 3 are available and that d_2 (x), d_3 (y) can be invested in programs 2 and 3, where x = 0,1,...,8 y = 0,1,2,...,8 and x + y = 0,1,2,...,8 Thus, with 8 we can invest 0 in 2 and 8 in 3, with 5 3 in 2 and 2 in 3 and so on. Find the optimum of all these choices for each x in 0,1,2,....8. The functional equation is f_2 (x) = max[g_2y + f_3(x)] y = 0,1,... ,8 - x x = 0,1,...,8 Step 3: The final stage is the same as the original prob-lem. We now assume all three programs are available. We examine the results of investing z in program 1 and 8 - z units in programs 2 and 3 (the optimal amounts for each 8 - z (z = 0,1,2, ..,8) have already been found in Step 2). The functional equation for the last stage is f_i ( x) = max [g_i(z) + f_i+1 (x - z) x = 0,...,8 Z = 0,1,.....,X d_i(x) = value of z that yieldsf_i(x) where f_i(x) is the optimal return from investing x units in programsi,i+ 1,..,3andd_i(x) is the optimal amount to invest in programiwhen x units are available to in-vest in programsi,i+ 1,..., 3 fori= 1,2,3."}, "question": "task_1"}}, {"data": {"text": "Question:\nYou have just received a Basic Assembler Language programyou ran. As you turn to the execution page to check theprintout, you find that every fourth line of the program reads, for example, PSW =... 00004F17B4C4. What is the PSW and what information does it provide? In addition, what informationis provided in the three lines following the PSW statement?\n\nOptions:\nA. PSW is a programming language used by the system.\nB. The three lines following the PSW statement are error codes.\nC.             PSW stands for Program Status Word. It contains the value of the location counter, system protection information, and program interrupt status. The three lines following the PSW statement display the contents of the system's registers at the time of interruption.\nD. PSW is a password for system protection.\n\nAnswer: C\n\nReference Solution:\nPSW is a mnemonic that stands for Program Status Word. The PSW has a length of 64 bits (8 bytes), and in general, contains the value of the location counter, system protection information, and program interrupt status. The system protection information protects the operating system (data needed by the computer) from errors that could be - detrimental to the system. This feature is an imperative one, since quite often programmers unknowingly make critical system errors. The interrupt status indicates the condi-tion of the Central Processing Unit (CPU) at the time of the interruption. When an interruption occurs, the proces-sor (CPU) places specific interrupt information in the PSW. In a simplified manner, we can say that when an interrupt occurs, the PSW stores the address of the next instruction to be executed; we may say the PSW 'looks-ahead'. The ad-dress of this instruction is indicated by the location counter portion of PSW. Thus, it is this part of the PSW that the beginning assembler language programmer should concern himself with. When an interrupt occurs, starting with the third byte of the 8-bytes PSW, the contents of the PSW are printed on the execution page of the program . It is printed in hexa-decimal notation. To find the instruction about to be ex-ecuted when the interruptoccured, the programmer need only concern himself with the rightmost four digits of the PSW. Using these digits, he can find the instruction in the body of the program. As this is the instruction that was to be executed when the interruption occured , it is the instruc-tion immediately preceding it that caused the problem . By closely inspecting this instruction, the cause of the in-terrupt can be found. The three lines following the PSW statement display the contents of the system's registers at the time of inter-ruption. The first two lines contain the 16 general purpose registers; this is indicated by the GPR (GPR 0-7; GPR 8-F) statement at the beginning of the line. The third line holds the Floating Point Registers (FPR). It should be noted that each time an interrupt occurs, the system prints the contents of the PSW. The program will be terminated if the number of allowed program inter-ruptions is exceeded.", "ref_id": 4601, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "You have just received a Basic Assembler Language programyou ran. As you turn to the execution page to check theprintout, you find that every fourth line of the program reads, for example, PSW =... 00004F17B4C4. What is the PSW and what information does it provide? In addition, what informationis provided in the three lines following the PSW statement?", "options": ["PSW is a programming language used by the system.", "The three lines following the PSW statement are error codes.", "PSW stands for Program Status Word. It contains the value of the location counter, system protection information, and program interrupt status. The three lines following the PSW statement display the contents of the system's registers at the time of interruption.", "PSW is a password for system protection."], "answer": "C", "solution": "PSW is a mnemonic that stands for Program Status Word. The PSW has a length of 64 bits (8 bytes), and in general, contains the value of the location counter, system protection information, and program interrupt status. The system protection information protects the operating system (data needed by the computer) from errors that could be - detrimental to the system. This feature is an imperative one, since quite often programmers unknowingly make critical system errors. The interrupt status indicates the condi-tion of the Central Processing Unit (CPU) at the time of the interruption. When an interruption occurs, the proces-sor (CPU) places specific interrupt information in the PSW. In a simplified manner, we can say that when an interrupt occurs, the PSW stores the address of the next instruction to be executed; we may say the PSW 'looks-ahead'. The ad-dress of this instruction is indicated by the location counter portion of PSW. Thus, it is this part of the PSW that the beginning assembler language programmer should concern himself with. When an interrupt occurs, starting with the third byte of the 8-bytes PSW, the contents of the PSW are printed on the execution page of the program . It is printed in hexa-decimal notation. To find the instruction about to be ex-ecuted when the interruptoccured, the programmer need only concern himself with the rightmost four digits of the PSW. Using these digits, he can find the instruction in the body of the program. As this is the instruction that was to be executed when the interruption occured , it is the instruc-tion immediately preceding it that caused the problem . By closely inspecting this instruction, the cause of the in-terrupt can be found. The three lines following the PSW statement display the contents of the system's registers at the time of inter-ruption. The first two lines contain the 16 general purpose registers; this is indicated by the GPR (GPR 0-7; GPR 8-F) statement at the beginning of the line. The third line holds the Floating Point Registers (FPR). It should be noted that each time an interrupt occurs, the system prints the contents of the PSW. The program will be terminated if the number of allowed program inter-ruptions is exceeded."}, "question": "task_1"}}, {"data": {"text": "Question:\nWhat arrangement of the integers 1, 2, 3, 4, and 5 in a five- element array will yield the longest sort time (also known as the worst-case sort time) for the insertion sort? Gen-eralize the answer you obtain for N integers.\n\nOptions:\nA. Ascending order\nB. Reverse order\nC.             Random order\nD. Alternating order\n\nAnswer: B\n\nReference Solution:\nAs developed earlier, in the insertion sort method, the list is scanned until an element is found to be out of order. The unordered element is stored temporarily, and the scan reverses direction until it reaches the place where the unordered element should be. The rest of the list's elements are moved up one place, and the sort continues. If the list of integers is presented initially in re-verse order, the insertion sort will have to make the great-est number of comparisons. Let us walk through the steps that must be taken: pass after 1st pass4, 5, 3, 2, 1 after 2nd pass4, 3, 5, 2, 1 after 3rd pass3, 4, 5, 2, 1 after 4th pass3, 4, 2, 5, 1 after 5th pass3, 2, 4, 5, 1 after 6th pass2, 3, 4, 5, 1 after 7th pass2, 3, 4, 1, 5 after 8th pass2, 3, 1, 4, 5 after 9th pass2, 1, 3, 4, 5 after 10th pass1, 2, 3, 4, 5 Ten comparisons must be made to get the list in order. We can generalize from this result to obtain a worst-case equation for the insertion sort. The maximum number of comparisons for the insertion sort is N (N - 1) / 2 This can be seen by writing the series in the order given and in the reverse order: (N - 1) + (N - 2) + (N - 3) + . . . + 3 + 2 + 1 1 + 2 + 3 + . . . + (N - 3) + (N - 2) + (N - 1) Adding term by term, we find that twice the sum of the series is N + N + N + ... + N + N + N Since N-l terms are in the series above, we can say that twice the sum of the series is N (N - 1), so, dividing by 2, the sum of the series is N (N -1) / 2.", "ref_id": 4602, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "What arrangement of the integers 1, 2, 3, 4, and 5 in a five- element array will yield the longest sort time (also known as the worst-case sort time) for the insertion sort? Gen-eralize the answer you obtain for N integers.", "options": ["Ascending order", "Reverse order", "Random order", "Alternating order"], "answer": "B", "solution": "As developed earlier, in the insertion sort method, the list is scanned until an element is found to be out of order. The unordered element is stored temporarily, and the scan reverses direction until it reaches the place where the unordered element should be. The rest of the list's elements are moved up one place, and the sort continues. If the list of integers is presented initially in re-verse order, the insertion sort will have to make the great-est number of comparisons. Let us walk through the steps that must be taken: pass after 1st pass4, 5, 3, 2, 1 after 2nd pass4, 3, 5, 2, 1 after 3rd pass3, 4, 5, 2, 1 after 4th pass3, 4, 2, 5, 1 after 5th pass3, 2, 4, 5, 1 after 6th pass2, 3, 4, 5, 1 after 7th pass2, 3, 4, 1, 5 after 8th pass2, 3, 1, 4, 5 after 9th pass2, 1, 3, 4, 5 after 10th pass1, 2, 3, 4, 5 Ten comparisons must be made to get the list in order. We can generalize from this result to obtain a worst-case equation for the insertion sort. The maximum number of comparisons for the insertion sort is N (N - 1) / 2 This can be seen by writing the series in the order given and in the reverse order: (N - 1) + (N - 2) + (N - 3) + . . . + 3 + 2 + 1 1 + 2 + 3 + . . . + (N - 3) + (N - 2) + (N - 1) Adding term by term, we find that twice the sum of the series is N + N + N + ... + N + N + N Since N-l terms are in the series above, we can say that twice the sum of the series is N (N - 1), so, dividing by 2, the sum of the series is N (N -1) / 2."}, "question": "task_1"}}, {"data": {"text": "Question:\nTrace the movement of the integers 4, 3, 5, 1, 2 as they are sorted in ascending order with the bubble sort. Can you give a general formula for the time needed for sorting N numbers in the best case? In the worst case?\n\nOptions:\nA. N (N - 1) / 2 comparisons\nB. N log N comparisons\nC.             N comparisons\nD. N^2 comparisons\n\nAnswer: A\n\nReference Solution:\nThe bubble sort compares each pair of adjacent elements in a list. If in the proper order, the pair is left alone, and the next pair is examined. If out of order, the items are switched, and the next pair is examined. In this fashion, the larger elements are \"bubbled\\textquotedblright down the list, while the smaller elements move to the head of the list. Of course, if the list is to be sorted in descending order, the opposite process will occur. Let us illustrate the steps necessary to arrange the integers in ascending order: 1st comparison3, 4, 5, 1, 2Compare 3 and 4,no switch 2nd comparison3, 4, 5, 1, 2Compare 4 and 5,no switch 3rd comparison3, 4, 1, 5, 2Compare 5 and 1,switch them 4th comparison3, 4, 1, 2, 5Compare 5 and 2,switch - end of 1st pass 5th comparison3, 1, 4, 2, 5Compare 4 and 1,switch 6th comparison3, 1, 2, 4, 5Compare 4 and 2,switch - end of 2nd pass 7th comparison1, 3, 2, 4, 5Compare 3 and 1,switch 8th comparison1, 2, 3, 4, 5Compare 3 and 2,switch - end of 3rd pass In the best case, i.e., when the data are already order, the bubble sort makes only one pass through the list. No sorting method can do any better than this. However, in the worst case, the bubble sort makes a maximum of N (N - 1) / 2 comparisons, just like other sequential sorting methods. The worst case is realized when the data are in the opposite order from the order you wish to have. For example, if we wish to sort the integers 5, 4, 3, 2, 1 into ascending order, the bubble sort will make 10 switches. 4, 3, 2, 1, 54 switches 3, 2, 1, 4, 53 switches 2, 1, 3, 4, 52 switches 1, 2, 3, 4, 51switches 10 switches total", "ref_id": 4603, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Trace the movement of the integers 4, 3, 5, 1, 2 as they are sorted in ascending order with the bubble sort. Can you give a general formula for the time needed for sorting N numbers in the best case? In the worst case?", "options": ["N (N - 1) / 2 comparisons", "N log N comparisons", "N comparisons", "N^2 comparisons"], "answer": "A", "solution": "The bubble sort compares each pair of adjacent elements in a list. If in the proper order, the pair is left alone, and the next pair is examined. If out of order, the items are switched, and the next pair is examined. In this fashion, the larger elements are \"bubbled\\textquotedblright down the list, while the smaller elements move to the head of the list. Of course, if the list is to be sorted in descending order, the opposite process will occur. Let us illustrate the steps necessary to arrange the integers in ascending order: 1st comparison3, 4, 5, 1, 2Compare 3 and 4,no switch 2nd comparison3, 4, 5, 1, 2Compare 4 and 5,no switch 3rd comparison3, 4, 1, 5, 2Compare 5 and 1,switch them 4th comparison3, 4, 1, 2, 5Compare 5 and 2,switch - end of 1st pass 5th comparison3, 1, 4, 2, 5Compare 4 and 1,switch 6th comparison3, 1, 2, 4, 5Compare 4 and 2,switch - end of 2nd pass 7th comparison1, 3, 2, 4, 5Compare 3 and 1,switch 8th comparison1, 2, 3, 4, 5Compare 3 and 2,switch - end of 3rd pass In the best case, i.e., when the data are already order, the bubble sort makes only one pass through the list. No sorting method can do any better than this. However, in the worst case, the bubble sort makes a maximum of N (N - 1) / 2 comparisons, just like other sequential sorting methods. The worst case is realized when the data are in the opposite order from the order you wish to have. For example, if we wish to sort the integers 5, 4, 3, 2, 1 into ascending order, the bubble sort will make 10 switches. 4, 3, 2, 1, 54 switches 3, 2, 1, 4, 53 switches 2, 1, 3, 4, 52 switches 1, 2, 3, 4, 51switches 10 switches total"}, "question": "task_1"}}, {"data": {"text": "Question:\nWrite a FORTRAN program to determine the greatest integerthat does not exceed a given real number X.\n\nOptions:\nA. 1) Round X to an integer, NX 2) If X is nonnegative, [X] = NX + 1 3) If X is negative [X] = NX.\nB. 1) Truncate X to an integer, NX 2) If X is nonnegative, [X] = NX 3) If X is negative [X] = NX - 1.\nC.             1) Truncate X to an integer, NX 2) If X is nonnegative, [X] = NX + 1 3) If X is negative [X] = NX - 1.\nD. 1) Round X to nearest integer, NX 2) If X is nonnegative, [X] = NX 3) If X is negative [X] = NX + 1.\n\nAnswer: B\n\nReference Solution:\nThe greatest integer function f: R\\rightarrow Z has as domain the real numbersand co-domain the integers. It is denoted by [X] where X is a real number. For example, [\\pi] = [3.1415...] = 3 [e] = [2.7128...] = 2 [-6.01] = -7 ;[8] = 8 . [-6.01] = -7 ;[8] = 8 . Thus, for X \\geq 0, [X] is the integer part of X (it is immaterial whether the decimalpart of X is greater than .5 or not). For X < 0, [X] is the integer part of X minus 1. Thus, to find [X], we proceed as follows: 1) Truncate X to an integer, NX 2) If X is nonnegative, [X] = NX 3) If X is negative [X] = NX - 1. CPROGRAM TO DETERMINE THE LARGEST CINTEGER THAT DOES NOT EXCEED A GIVEN CREAL NUMBER X. READ (5,1) X 1FORMAT (F 10.4) NX = X IF (X) 5,3,3 CIF X IS NEGATIVE, IS IT AN INTEGER? CIF SO, PROCEED DIRECTLY TO WRITE. CIF NOT,SUBTRACT1 FROM NX. 5Y = NX IF (X - Y) 7,3,7 7NX = NX - 1 3WRITE (6,9) X 9FORMAT (1HO, 14H REAL NUMBER= ,F 14.4) WRITE (6,11) NX 11FORMAT (1H ,19H GREATEST INTEGER = ,I6) STOP END", "ref_id": 4604, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Write a FORTRAN program to determine the greatest integerthat does not exceed a given real number X.", "options": ["1) Round X to an integer, NX 2) If X is nonnegative, [X] = NX + 1 3) If X is negative [X] = NX.", "1) Truncate X to an integer, NX 2) If X is nonnegative, [X] = NX 3) If X is negative [X] = NX - 1.", "1) Truncate X to an integer, NX 2) If X is nonnegative, [X] = NX + 1 3) If X is negative [X] = NX - 1.", "1) Round X to nearest integer, NX 2) If X is nonnegative, [X] = NX 3) If X is negative [X] = NX + 1."], "answer": "B", "solution": "The greatest integer function f: R\\rightarrow Z has as domain the real numbersand co-domain the integers. It is denoted by [X] where X is a real number. For example, [\\pi] = [3.1415...] = 3 [e] = [2.7128...] = 2 [-6.01] = -7 ;[8] = 8 . [-6.01] = -7 ;[8] = 8 . Thus, for X \\geq 0, [X] is the integer part of X (it is immaterial whether the decimalpart of X is greater than .5 or not). For X < 0, [X] is the integer part of X minus 1. Thus, to find [X], we proceed as follows: 1) Truncate X to an integer, NX 2) If X is nonnegative, [X] = NX 3) If X is negative [X] = NX - 1. CPROGRAM TO DETERMINE THE LARGEST CINTEGER THAT DOES NOT EXCEED A GIVEN CREAL NUMBER X. READ (5,1) X 1FORMAT (F 10.4) NX = X IF (X) 5,3,3 CIF X IS NEGATIVE, IS IT AN INTEGER? CIF SO, PROCEED DIRECTLY TO WRITE. CIF NOT,SUBTRACT1 FROM NX. 5Y = NX IF (X - Y) 7,3,7 7NX = NX - 1 3WRITE (6,9) X 9FORMAT (1HO, 14H REAL NUMBER= ,F 14.4) WRITE (6,11) NX 11FORMAT (1H ,19H GREATEST INTEGER = ,I6) STOP END"}, "question": "task_1"}}, {"data": {"text": "Question:\nWrite an APL program to evaluate the roots of the quadratic equation of the form ax^2 +bx+ c = 0.\n\nOptions:\nA. The roots are -0.6666666667 and -7.000000000\nB. The roots are 3 and -19\nC.             The roots are -0.6666666667 and +7.000000000\nD. The roots are -14 and 0\n\nAnswer: C\n\nReference Solution:\nTo do this, we use the quadratic formula: ROOT = [-B \\pm \\surd(B^2 - 4AC)] / [2A] The quantity given by B^2 - 4AC is named thediscriminant. If it is negative, then the roots are complex numbers. In that case the program will be terminated. (Complex numbers can be evaluated by a built-in library function, but we will omit this for simplicity sake.). If thediscriminantis positive, then we want to calculate the roots. The program is written below: \\nablaQUADRATIC [1]DISCRIM \\leftarrow (B\\textasteriskcentered2) - 4 \u00d7 A \u00d7 C [2]\\rightarrow (0 > DISCRIM) / 8 [3]'THE ROOTS ARE' [4]ROOT1 \\leftarrow (-B-DISCRIM\\textasteriskcentered0.5) \\div 2 \u00d7 A [5]ROOT2 \\leftarrow (-B + DISCRIM\\textasteriskcentered0.5) \\div 2 \u00d7 A [6]ROOT1, ROOT2 [7]\\rightarrow0 [8]'THE ROOTS ARE COMPLEX' \\nabla Line [2] may be translated as follows: \"If zero is greater than the discriminant , then go to line [8]. If zero is less than or equal to the discriminant , proceed with the next line.\" This is called a branch statement. Line [7] is also a branch: after the roots have been cal-culated, the program goes to line [0], which actually means the end of the program. Literal text has been added to make clear the meaning of the values being computed. Now, for the polynomial 3x^2 - 19x - 14 = 0, we can give a sample output, with A = 3, B = -19, and C = -14. This polynomial has real roots. A \\leftarrow 3 B \\leftarrow -19 C \\leftarrow -14 QUADRATIC The roots are -0.6666666667 +7.000000000.", "ref_id": 4605, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Write an APL program to evaluate the roots of the quadratic equation of the form ax^2 +bx+ c = 0.", "options": ["The roots are -0.6666666667 and -7.000000000", "The roots are 3 and -19", "The roots are -0.6666666667 and +7.000000000", "The roots are -14 and 0"], "answer": "C", "solution": "To do this, we use the quadratic formula: ROOT = [-B \\pm \\surd(B^2 - 4AC)] / [2A] The quantity given by B^2 - 4AC is named thediscriminant. If it is negative, then the roots are complex numbers. In that case the program will be terminated. (Complex numbers can be evaluated by a built-in library function, but we will omit this for simplicity sake.). If thediscriminantis positive, then we want to calculate the roots. The program is written below: \\nablaQUADRATIC [1]DISCRIM \\leftarrow (B\\textasteriskcentered2) - 4 \u00d7 A \u00d7 C [2]\\rightarrow (0 > DISCRIM) / 8 [3]'THE ROOTS ARE' [4]ROOT1 \\leftarrow (-B-DISCRIM\\textasteriskcentered0.5) \\div 2 \u00d7 A [5]ROOT2 \\leftarrow (-B + DISCRIM\\textasteriskcentered0.5) \\div 2 \u00d7 A [6]ROOT1, ROOT2 [7]\\rightarrow0 [8]'THE ROOTS ARE COMPLEX' \\nabla Line [2] may be translated as follows: \"If zero is greater than the discriminant , then go to line [8]. If zero is less than or equal to the discriminant , proceed with the next line.\" This is called a branch statement. Line [7] is also a branch: after the roots have been cal-culated, the program goes to line [0], which actually means the end of the program. Literal text has been added to make clear the meaning of the values being computed. Now, for the polynomial 3x^2 - 19x - 14 = 0, we can give a sample output, with A = 3, B = -19, and C = -14. This polynomial has real roots. A \\leftarrow 3 B \\leftarrow -19 C \\leftarrow -14 QUADRATIC The roots are -0.6666666667 +7.000000000."}, "question": "task_1"}}, {"data": {"text": "Question:\nSince PL/I can be treated as a modular language, it is very adapt-able to the tenets of structured programming. One of the tenets is the reduction, sometimes even abolition, of the use of the GO TO statement. With this in mind, redesign the following program segments so that the GO TO statements are not necessary: a)IF X = X + Y\\textasteriskcentered\\textasteriskcentered2 THEN GO TO FIRST; ELSE GO TO NEXT; FIRST: X = X - 1; T = T + X; PUT DATA (T); GO TO FINAL; NEXT: PUT DATA (X,Y); FINAL: C = C + T; b)GET DATA (T); T1 = 0; S = 0; SUM: T1 = T1 + S; S = S + 2; IF T1 = T THEN GO TO B; GO TO SUM; B:PUT DATA. (T,T1,S);\n\nOptions:\nA. IF-THEN-ELSE construct and DO WHILE\nB. IF-THEN\nC.             Switch Case\nD. FOR loop\n\nAnswer: A\n\nReference Solution:\nThe way to solve this problem Is just by moving segments of statements around. For example, a) may be rewritten thus: IF X = X + Y \\textasteriskcentered\\textasteriskcentered 2 THEN DO; X = X - 1; T = T + X; PUT DATA. (T); END; ELSE PUT DATA (X); FINAL: C = C + T; The procedure names NEXT and FIRST are unnecessary, so we simplify the code by rendering a simple IF-THEN-ELSE construct. The next program segment can be modified with the use of the DO WHILE: GET DATA (T); T1 = 0; S = 0; DO WHILE (T > T1); T1 = T1 + S; S = S + 2; END; B:PUT DATA (T,S); As before, the procedure names are not always necessary.", "ref_id": 4606, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Since PL/I can be treated as a modular language, it is very adapt-able to the tenets of structured programming. One of the tenets is the reduction, sometimes even abolition, of the use of the GO TO statement. With this in mind, redesign the following program segments so that the GO TO statements are not necessary: a)IF X = X + Y\\textasteriskcentered\\textasteriskcentered2 THEN GO TO FIRST; ELSE GO TO NEXT; FIRST: X = X - 1; T = T + X; PUT DATA (T); GO TO FINAL; NEXT: PUT DATA (X,Y); FINAL: C = C + T; b)GET DATA (T); T1 = 0; S = 0; SUM: T1 = T1 + S; S = S + 2; IF T1 = T THEN GO TO B; GO TO SUM; B:PUT DATA. (T,T1,S);", "options": ["IF-THEN-ELSE construct and DO WHILE", "IF-THEN", "Switch Case", "FOR loop"], "answer": "A", "solution": "The way to solve this problem Is just by moving segments of statements around. For example, a) may be rewritten thus: IF X = X + Y \\textasteriskcentered\\textasteriskcentered 2 THEN DO; X = X - 1; T = T + X; PUT DATA. (T); END; ELSE PUT DATA (X); FINAL: C = C + T; The procedure names NEXT and FIRST are unnecessary, so we simplify the code by rendering a simple IF-THEN-ELSE construct. The next program segment can be modified with the use of the DO WHILE: GET DATA (T); T1 = 0; S = 0; DO WHILE (T > T1); T1 = T1 + S; S = S + 2; END; B:PUT DATA (T,S); As before, the procedure names are not always necessary."}, "question": "task_1"}}, {"data": {"text": "Question:\nA sign of a good computer programmer is the ability to write a program which minimizes storage usage. The IBM 360/370 computers provide us with the DSECT and CSECT statements . How do they enable us to becomebetter programmers ?\n\nOptions:\nA. They allow for faster execution of programs.\nB. They enhance the graphic interface of the program.\nC.             The DSECT and CSECT statements allow for the definition and use of many variables without allocating storage space for them all at once, minimizing storage usage.\nD. They enable multithreading capabilities.\n\nAnswer: C\n\nReference Solution:\nThe DSECT (Dummy Section) is actually an indica-tor that tells the assembler that the following code defines a dummy section. This facility enables us to define and use many variables in our program without actually allocating storage space for them all at one time. This may sound somewhat strange but the procedure is rather simple. The DSECT is an assembler instruction, and it generates no ma-chine code. It tells the assembler that the storage defini-tions which follow forms a dummy section . The CSECT (Control Section) instruction indicates the end of the dummy section. For the DSECT a substitute base register is used. The register to be used is generally specified in a 'USING' statement at the beginning of the program. When the DSECT is encountered, the displacements of the labels within it are assigned, not from the beginning of the program, but from the DSECT statement. The CSECT instruction indicates the end of the dummy section. With this, the substitute base register is restored (freed), the location counter pro-ceeds as if the DSECT instruction was not there. It has the value it had previous to encountering the DSECT instruction . Instead of having storage allocation for the 'running- life' of the program , the symbols of a DSECT are allocated space as they are encountered in the body of the program. This space is then freed when usage is completed. By placing a label in the label field of the DSECT instruction, the dummy section can be named. The label field of the SCECT statement must contain the name of the program, this name is taken from the label field of the start instruc-tion. Coding of the section is generally done as follows USINGCRDMAP, 5 APTOTSUM, SLSREG CRDMAPDESECT SLSCARDDSOCL80 SLSNBRDSCL4 SLSNAMDSCL20 SLSREGDSCL2 SLSQTYDSCL6 DSCL48 PROGNAMECSECT The 'USING' statement is generally coded after the pro-gram's base register 'USING' statement. The AP statement adds a number previously placed in SLSREG to TOTSUM. The DSECT is usually coded for repetitious procedures. In many instances it is used to replace explicit coding. This is done because DSECT is considered easier to code and there are less changes of addressing errors. It is important to note that since DSECT is a dummy section only storage space can be defined in it and not con-stants. Thus, only the 'DS' statement is used for the labels.", "ref_id": 4607, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "A sign of a good computer programmer is the ability to write a program which minimizes storage usage. The IBM 360/370 computers provide us with the DSECT and CSECT statements . How do they enable us to becomebetter programmers ?", "options": ["They allow for faster execution of programs.", "They enhance the graphic interface of the program.", "The DSECT and CSECT statements allow for the definition and use of many variables without allocating storage space for them all at once, minimizing storage usage.", "They enable multithreading capabilities."], "answer": "C", "solution": "The DSECT (Dummy Section) is actually an indica-tor that tells the assembler that the following code defines a dummy section. This facility enables us to define and use many variables in our program without actually allocating storage space for them all at one time. This may sound somewhat strange but the procedure is rather simple. The DSECT is an assembler instruction, and it generates no ma-chine code. It tells the assembler that the storage defini-tions which follow forms a dummy section . The CSECT (Control Section) instruction indicates the end of the dummy section. For the DSECT a substitute base register is used. The register to be used is generally specified in a 'USING' statement at the beginning of the program. When the DSECT is encountered, the displacements of the labels within it are assigned, not from the beginning of the program, but from the DSECT statement. The CSECT instruction indicates the end of the dummy section. With this, the substitute base register is restored (freed), the location counter pro-ceeds as if the DSECT instruction was not there. It has the value it had previous to encountering the DSECT instruction . Instead of having storage allocation for the 'running- life' of the program , the symbols of a DSECT are allocated space as they are encountered in the body of the program. This space is then freed when usage is completed. By placing a label in the label field of the DSECT instruction, the dummy section can be named. The label field of the SCECT statement must contain the name of the program, this name is taken from the label field of the start instruc-tion. Coding of the section is generally done as follows USINGCRDMAP, 5 APTOTSUM, SLSREG CRDMAPDESECT SLSCARDDSOCL80 SLSNBRDSCL4 SLSNAMDSCL20 SLSREGDSCL2 SLSQTYDSCL6 DSCL48 PROGNAMECSECT The 'USING' statement is generally coded after the pro-gram's base register 'USING' statement. The AP statement adds a number previously placed in SLSREG to TOTSUM. The DSECT is usually coded for repetitious procedures. In many instances it is used to replace explicit coding. This is done because DSECT is considered easier to code and there are less changes of addressing errors. It is important to note that since DSECT is a dummy section only storage space can be defined in it and not con-stants. Thus, only the 'DS' statement is used for the labels."}, "question": "task_1"}}, {"data": {"text": "Question:\nState the basic laws of Boolean algebra.\n\nOptions:\nA. The basic laws of Boolean algebra are Associative, Distributive, Commutative, and Identity\nB. The basic laws of Boolean algebra are Addition, Subtraction, Multiplication and Division\nC.             The basic laws of Boolean algebra are Commutative, Associative, Distributive, Identity and Inverse\nD. The basic laws of Boolean algebra are Idempotent, Commutative, Associative, Distributive, Law of Union, Law of Intersection, Double Negative Law or Involution Law, Law of complement and deMorgan's law\n\nAnswer: D\n\nReference Solution:\nIf A, B and C are Boolean variables, then the basic laws of Boolean algebras are (where + and \\textbullet are binary operators representing OR (inclusive) and AND respectively): 1A:A + A = A [Idempotent law for + ] 1B:A \\bullet A = A [Idempotent law for \\textbullet ] 2A:A + B = B + A [Commutative law for + ] 2B:A \\bullet B = B \\bullet A[Commutative law for \\textbullet ] 3A:A + (B+C) = (A+B) + C [Associative law for + ] 3B:A \\bullet (B\\bulletC) = (A\\bulletB) \\textbullet C [Associative law for \\textbullet ] 4A:A \\bullet (B+C) = (A\\bulletB) + (A\\bulletC) [Distributive law for \\textbullet over + ] 4B:A + (B\\bulletC) = (A+B) \\bullet (A+C) [Distributive law for + over \\bullet ] 5A:A + 1 = 1 (Law of Union) 5B:A \\bullet 0 = 0 (Law of Intersection) 6A:A \\bullet 1 = A [1 is the identity element for \\textbullet ] 6B:A + 0 = A [0 is the identity element for + ] The law of \\backsim : 7: \\textasciitilde(\\textasciitilde A) = A [Double Negative Law or Involution Law] 8A: A + \\backsimA = 1 \u2502Law of complement 8B: A \\bullet \\backsimA= 0 \u2502 9A: \\backsim(A+B) = \\backsimA \\bullet \\backsim B [deMorgan's law] 9B: \\textasciitilde(A \\textbullet B) = \\textasciitilde A + \\textasciitilde B [deMorgan's law] 10: 1^\\backsim = 0 and 0\\backsim= 1 Any system obeying these laws is known as Boolean algebra. A set with its subsets and the subset operations union and intersect (+ and \\bullet , respectively) is a Boolean algebra. The one-to-one correspondence between Boolean expressions and switching circuits suggests that a switch-ing algebra is a Boolean algebra. In fact, 1A - 3B obviously holds true for switching circuits. The switching analog of 4A claims that Fig. 1, and Fig. 2 are equivalent circuits. Since both circuits conduct unless A is open or both B and C are open, they are, in fact, equivalent. Therefore, 4A holds true for switching circuits. And similarly, 4B - 10 can be shown to hold for switching circuits by exhibiting the switching circuits representing the left and right sides of the equation and show-ing that the two are equivalent. Once it is shown that all 18 laws hold for switching circuits, they can be used for simplifying circuits. For example, 4A and 4B reduce four-switch circuits to three-switch cir-cuits. Actually all 18 laws are not a minimal set of Boolean algebra laws, since laws 1A, 1B, 3A, 3B, 5A, 5B, 7, 9B and 10 can be derived from the other laws. For example, once this fact is established, only 8 properties need be satisfied to determine a Boolear algebra, since the other ten follow immediately. Since the gate elements OR, AND and NOT are representations of the operations +, \\textbullet and \\textasciitilde respec-tively, it follows that a gating algebra is a Boolean algebra. This fact can be used for simplifying gating circuits. For instance 4A and 4B reduce 3-gate circuits to 2-gate circuits.", "ref_id": 4608, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "State the basic laws of Boolean algebra.", "options": ["The basic laws of Boolean algebra are Associative, Distributive, Commutative, and Identity", "The basic laws of Boolean algebra are Addition, Subtraction, Multiplication and Division", "The basic laws of Boolean algebra are Commutative, Associative, Distributive, Identity and Inverse", "The basic laws of Boolean algebra are Idempotent, Commutative, Associative, Distributive, Law of Union, Law of Intersection, Double Negative Law or Involution Law, Law of complement and deMorgan's law"], "answer": "D", "solution": "If A, B and C are Boolean variables, then the basic laws of Boolean algebras are (where + and \\textbullet are binary operators representing OR (inclusive) and AND respectively): 1A:A + A = A [Idempotent law for + ] 1B:A \\bullet A = A [Idempotent law for \\textbullet ] 2A:A + B = B + A [Commutative law for + ] 2B:A \\bullet B = B \\bullet A[Commutative law for \\textbullet ] 3A:A + (B+C) = (A+B) + C [Associative law for + ] 3B:A \\bullet (B\\bulletC) = (A\\bulletB) \\textbullet C [Associative law for \\textbullet ] 4A:A \\bullet (B+C) = (A\\bulletB) + (A\\bulletC) [Distributive law for \\textbullet over + ] 4B:A + (B\\bulletC) = (A+B) \\bullet (A+C) [Distributive law for + over \\bullet ] 5A:A + 1 = 1 (Law of Union) 5B:A \\bullet 0 = 0 (Law of Intersection) 6A:A \\bullet 1 = A [1 is the identity element for \\textbullet ] 6B:A + 0 = A [0 is the identity element for + ] The law of \\backsim : 7: \\textasciitilde(\\textasciitilde A) = A [Double Negative Law or Involution Law] 8A: A + \\backsimA = 1 \u2502Law of complement 8B: A \\bullet \\backsimA= 0 \u2502 9A: \\backsim(A+B) = \\backsimA \\bullet \\backsim B [deMorgan's law] 9B: \\textasciitilde(A \\textbullet B) = \\textasciitilde A + \\textasciitilde B [deMorgan's law] 10: 1^\\backsim = 0 and 0\\backsim= 1 Any system obeying these laws is known as Boolean algebra. A set with its subsets and the subset operations union and intersect (+ and \\bullet , respectively) is a Boolean algebra. The one-to-one correspondence between Boolean expressions and switching circuits suggests that a switch-ing algebra is a Boolean algebra. In fact, 1A - 3B obviously holds true for switching circuits. The switching analog of 4A claims that Fig. 1, and Fig. 2 are equivalent circuits. Since both circuits conduct unless A is open or both B and C are open, they are, in fact, equivalent. Therefore, 4A holds true for switching circuits. And similarly, 4B - 10 can be shown to hold for switching circuits by exhibiting the switching circuits representing the left and right sides of the equation and show-ing that the two are equivalent. Once it is shown that all 18 laws hold for switching circuits, they can be used for simplifying circuits. For example, 4A and 4B reduce four-switch circuits to three-switch cir-cuits. Actually all 18 laws are not a minimal set of Boolean algebra laws, since laws 1A, 1B, 3A, 3B, 5A, 5B, 7, 9B and 10 can be derived from the other laws. For example, once this fact is established, only 8 properties need be satisfied to determine a Boolear algebra, since the other ten follow immediately. Since the gate elements OR, AND and NOT are representations of the operations +, \\textbullet and \\textasciitilde respec-tively, it follows that a gating algebra is a Boolean algebra. This fact can be used for simplifying gating circuits. For instance 4A and 4B reduce 3-gate circuits to 2-gate circuits."}, "question": "task_1"}}, {"data": {"text": "Question:\nModify the program of the previous problem to handle overflowif the capacity of the tank is finite.\n\nOptions:\nA. No modifications are necessary\nB. Check if VOL exceeds the given capacity CAP each time it is computed.\nC.             Check if VOL is less than the given capacity CAP each time it is computed\nD. Modify the program to handle underflow\n\nAnswer: B\n\nReference Solution:\nEach time VOL is computed, check to see if it exceeds the given capacityCAP. If it does, indicate this and stop the simulation: DATA T/0.0/ READ N, TFIN, Q, VOL, CAP PRINT T, VOL REALN = N DT + (TFIN - T)/REALN DO 50 I = 1,N T = T + DT VOL = VOL + Q {_\\ast} DT IF(VOL.GT. CAP) GO TO 60 PRINT T, VOL 50CONTINUE STOP 60PRINT 'OVERFLOW' STOP END", "ref_id": 4609, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Modify the program of the previous problem to handle overflowif the capacity of the tank is finite.", "options": ["No modifications are necessary", "Check if VOL exceeds the given capacity CAP each time it is computed.", "Check if VOL is less than the given capacity CAP each time it is computed", "Modify the program to handle underflow"], "answer": "B", "solution": "Each time VOL is computed, check to see if it exceeds the given capacityCAP. If it does, indicate this and stop the simulation: DATA T/0.0/ READ N, TFIN, Q, VOL, CAP PRINT T, VOL REALN = N DT + (TFIN - T)/REALN DO 50 I = 1,N T = T + DT VOL = VOL + Q {_\\ast} DT IF(VOL.GT. CAP) GO TO 60 PRINT T, VOL 50CONTINUE STOP 60PRINT 'OVERFLOW' STOP END"}, "question": "task_1"}}, {"data": {"text": "Question:\nExplain what is meant by reduction of vectors. Also explain the rule for APL arithmetic. Evaluate the expression: 6 + ((5 + 2 \u00d7 11 - 2) - 3 + 2) \\div 2 \u00d7 3.\n\nOptions:\nA. 9\nB. 18\nC.             6\nD. 12\n\nAnswer: A\n\nReference Solution:\nReduction of a vector, in APL, is equivalent to placing a dyadic operator between each element of the vec-tor and evaluating the resulting expression. Examples of dyadic operators are plus +, minus -, multiply \u00d7, divide \\div, exponentiation \\textasteriskcentered, etc. The symbol for reduction is a right-tilting slash, e.g.,/. The use of the symbol is illustrated below for a vector V. +/V, -/V, \u00d7/V, \\div/V, \\textasteriskcentered/V, etc. If V is defined by V \\leftarrow 1 2 3 then each of the above re-ductions is equivalent to the following, respectively. +/V is equivalent to 1 + 2 + 3 -/V is equivalent to 1 - 2 - 3 \u00d7/V is equivalent to 1 \u00d7 2 \u00d7 3 \\div/V is equivalent to 1 \\div 2 \\div 3 \\textasteriskcentered/V is equivalent to 1 \\textasteriskcentered 2 \\textasteriskcentered 3 The rule for APL arithmetic is a right to left rule. That is, the arithmetic operations are performed on a string of operators from right to left. Items enclosed within parentheses are evaluated first, and the whole parenthesized content acts as a single opera-tor. The given expression evaluates as follows: Expression = 6 + ((5 + 2 \u00d7 11 - 2) - 3+ 2) \\div 2 \u00d7 3 = 6 + ((5 + 2 \u00d7 9) - 3+ 2) \\div 2 \u00d7 3 = 6 + ((5 + 18) - 3+ 2) \\div 2 \u00d7 3 = 6 + ((23) - 3+ 2) \\div 2 \u00d7 3 = 6 + (23 - 3+ 2) \\div 2 \u00d7 3 = 6 + (23 - 5) \\div 2 \u00d7 3 = 6 + (18) \\div 2 \u00d7 3 = 6 + 18 \\div 2 \u00d7 3 = 6 + 18 \\div 6 = 6 + 3 = 9Answer Note that the innermost pair of brackets is evaluated out first using the right to left rule inside the brackets. Then the outer pair of brackets is evaluated using the right to left rule inside the brackets. Then, after all the brackets have been eliminated, the whole expression is evaluated using the right to left rule. Also note that the effect of a reduction1; operation performed on the vector V is to reduce it to a scalar quantity, which is the evaluated value of the resulting expression. Now, a vector has a dimension of 1. And, a scalar has a dimension of 0. Thus, the reduction operation has reduced the dimension of the variable V from 1 to 0. In general, it is found that for an n-dimensional ar-ray, a reduction operation reduces the dimension of the ar-ray by 1, from n to n-1. Finally, note that the arithmetical operations are not ordered in a hierarchy unlike FORTRAN, where multiplications and divisions are performed before additions and subtrac-tions .", "ref_id": 4610, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Explain what is meant by reduction of vectors. Also explain the rule for APL arithmetic. Evaluate the expression: 6 + ((5 + 2 \u00d7 11 - 2) - 3 + 2) \\div 2 \u00d7 3.", "options": ["9", "18", "6", "12"], "answer": "A", "solution": "Reduction of a vector, in APL, is equivalent to placing a dyadic operator between each element of the vec-tor and evaluating the resulting expression. Examples of dyadic operators are plus +, minus -, multiply \u00d7, divide \\div, exponentiation \\textasteriskcentered, etc. The symbol for reduction is a right-tilting slash, e.g.,/. The use of the symbol is illustrated below for a vector V. +/V, -/V, \u00d7/V, \\div/V, \\textasteriskcentered/V, etc. If V is defined by V \\leftarrow 1 2 3 then each of the above re-ductions is equivalent to the following, respectively. +/V is equivalent to 1 + 2 + 3 -/V is equivalent to 1 - 2 - 3 \u00d7/V is equivalent to 1 \u00d7 2 \u00d7 3 \\div/V is equivalent to 1 \\div 2 \\div 3 \\textasteriskcentered/V is equivalent to 1 \\textasteriskcentered 2 \\textasteriskcentered 3 The rule for APL arithmetic is a right to left rule. That is, the arithmetic operations are performed on a string of operators from right to left. Items enclosed within parentheses are evaluated first, and the whole parenthesized content acts as a single opera-tor. The given expression evaluates as follows: Expression = 6 + ((5 + 2 \u00d7 11 - 2) - 3+ 2) \\div 2 \u00d7 3 = 6 + ((5 + 2 \u00d7 9) - 3+ 2) \\div 2 \u00d7 3 = 6 + ((5 + 18) - 3+ 2) \\div 2 \u00d7 3 = 6 + ((23) - 3+ 2) \\div 2 \u00d7 3 = 6 + (23 - 3+ 2) \\div 2 \u00d7 3 = 6 + (23 - 5) \\div 2 \u00d7 3 = 6 + (18) \\div 2 \u00d7 3 = 6 + 18 \\div 2 \u00d7 3 = 6 + 18 \\div 6 = 6 + 3 = 9Answer Note that the innermost pair of brackets is evaluated out first using the right to left rule inside the brackets. Then the outer pair of brackets is evaluated using the right to left rule inside the brackets. Then, after all the brackets have been eliminated, the whole expression is evaluated using the right to left rule. Also note that the effect of a reduction1; operation performed on the vector V is to reduce it to a scalar quantity, which is the evaluated value of the resulting expression. Now, a vector has a dimension of 1. And, a scalar has a dimension of 0. Thus, the reduction operation has reduced the dimension of the variable V from 1 to 0. In general, it is found that for an n-dimensional ar-ray, a reduction operation reduces the dimension of the ar-ray by 1, from n to n-1. Finally, note that the arithmetical operations are not ordered in a hierarchy unlike FORTRAN, where multiplications and divisions are performed before additions and subtrac-tions ."}, "question": "task_1"}}, {"data": {"text": "Question:\nWrite a Basic Assembler Language program to compute and print out the first twenty numbers of the Fibonacci Sequence.\n\nOptions:\nA. Adding two previous numbers to get the next\nB. Programming number sequence in assembler language\nC.             Using loop to compute sequence\nD. BALR2, 0ESTABLISHES BASE REGISTER USING\\textasteriskcentered, 2ESTABLISHES BASE REGISTER LA1, 0REGISTER 1 CONTAINS NUMBER TO BE INCREMENTED BY LOOP LA4, 1REGISTER 4 CONTAINS INCREMENT LA5, 9REGISTER 5 CONTAINS LIMIT L7, = F'0'LOADS FIRST TW0 NUMBERS OF SEQUENCE L8, = F'1'LOADS FIRST TW0 NUMBERS OF SEQUENCE LOOP PRINTOUT7PRINT NUMBERS OF SEQUENCE PRINTOUT8PRINT NUMBERS OF SEQUENCE AR7, 8CREATES NEXT TWO NUMBERS OF SE-QUENCE AR8, 7CREATES NEXT TWO NUMBERS OF SE-QUENCE AR1.4ADDS INCREMENT TO INDEX CR4, 5COMPARE INDEX TO END BLELOOPRETURN FOR NEXT PART OF SERIES IF NOT PAST END END\n\nAnswer: D\n\nReference Solution:\nThe Fibonacci numbers are a sequence of numbers beginning with 0 and 1. To compute the following numbers of the series one adds the previous two to form the next. For example, the third number of the series is 0 + 1 = 1. The next is 1 +1 = 2, the next 1 + 2 = 3, the sixth is 2 + 3 = 5 and so on. This simple number sequence is easily programmed in assembler language. We will start off by loading the first two numbers of the sequence into two registers. Next we fall into a loop which prints out the two registers and then adds each register to the other creating the nexttwo num-bers of the sequence. These next two numbers are printed out when the program goes back to the top of the loop and the procedure is repeated. The program follows below: BALR2, 0ESTABLISHES BASE REGISTER USING\\textasteriskcentered, 2ESTABLISHES BASE REGISTER LA1, 0REGISTER 1 CONTAINS NUMBER TO BE INCREMENTED BY LOOP LA4, 1REGISTER 4 CONTAINS INCREMENT LA5, 9REGISTER 5 CONTAINS LIMIT L7, = F'0'LOADS FIRST TW0 NUMBERS OF SEQUENCE L8, = F'1'LOADS FIRST TW0 NUMBERS OF SEQUENCE LOOP PRINTOUT7PRINT NUMBERS OF SEQUENCE PRINTOUT8PRINT NUMBERS OF SEQUENCE AR7, 8CREATES NEXT TWO NUMBERS OF SE-QUENCE AR8, 7CREATES NEXT TWO NUMBERS OF SE-QUENCE AR1.4ADDS INCREMENT TO INDEX CR4, 5COMPARE INDEX TO END BLELOOPRETURN FOR NEXT PART OF SERIES IF NOT PAST END END", "ref_id": 4611, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Write a Basic Assembler Language program to compute and print out the first twenty numbers of the Fibonacci Sequence.", "options": ["Adding two previous numbers to get the next", "Programming number sequence in assembler language", "Using loop to compute sequence", "BALR2, 0ESTABLISHES BASE REGISTER USING\\textasteriskcentered, 2ESTABLISHES BASE REGISTER LA1, 0REGISTER 1 CONTAINS NUMBER TO BE INCREMENTED BY LOOP LA4, 1REGISTER 4 CONTAINS INCREMENT LA5, 9REGISTER 5 CONTAINS LIMIT L7, = F'0'LOADS FIRST TW0 NUMBERS OF SEQUENCE L8, = F'1'LOADS FIRST TW0 NUMBERS OF SEQUENCE LOOP PRINTOUT7PRINT NUMBERS OF SEQUENCE PRINTOUT8PRINT NUMBERS OF SEQUENCE AR7, 8CREATES NEXT TWO NUMBERS OF SE-QUENCE AR8, 7CREATES NEXT TWO NUMBERS OF SE-QUENCE AR1.4ADDS INCREMENT TO INDEX CR4, 5COMPARE INDEX TO END BLELOOPRETURN FOR NEXT PART OF SERIES IF NOT PAST END END"], "answer": "D", "solution": "The Fibonacci numbers are a sequence of numbers beginning with 0 and 1. To compute the following numbers of the series one adds the previous two to form the next. For example, the third number of the series is 0 + 1 = 1. The next is 1 +1 = 2, the next 1 + 2 = 3, the sixth is 2 + 3 = 5 and so on. This simple number sequence is easily programmed in assembler language. We will start off by loading the first two numbers of the sequence into two registers. Next we fall into a loop which prints out the two registers and then adds each register to the other creating the nexttwo num-bers of the sequence. These next two numbers are printed out when the program goes back to the top of the loop and the procedure is repeated. The program follows below: BALR2, 0ESTABLISHES BASE REGISTER USING\\textasteriskcentered, 2ESTABLISHES BASE REGISTER LA1, 0REGISTER 1 CONTAINS NUMBER TO BE INCREMENTED BY LOOP LA4, 1REGISTER 4 CONTAINS INCREMENT LA5, 9REGISTER 5 CONTAINS LIMIT L7, = F'0'LOADS FIRST TW0 NUMBERS OF SEQUENCE L8, = F'1'LOADS FIRST TW0 NUMBERS OF SEQUENCE LOOP PRINTOUT7PRINT NUMBERS OF SEQUENCE PRINTOUT8PRINT NUMBERS OF SEQUENCE AR7, 8CREATES NEXT TWO NUMBERS OF SE-QUENCE AR8, 7CREATES NEXT TWO NUMBERS OF SE-QUENCE AR1.4ADDS INCREMENT TO INDEX CR4, 5COMPARE INDEX TO END BLELOOPRETURN FOR NEXT PART OF SERIES IF NOT PAST END END"}, "question": "task_1"}}, {"data": {"text": "Question:\nEach of the following is not a correct FORTRAN statement. Give reasons in each case.\n\nOptions:\nA. M + 1 is a valid variable\nB. Arithmetic operations are allowed on the left side of the '=' sign\nC.             M + 1 is an invalid variable\nD. FORTRAN has the symbol '\u00d7' for multiplication\n\nAnswer: C\n\nReference Solution:\na) The only acceptable characters in a variable name in any FORTRAN statement are the twenty-six letters of the alphabet and the ten digits 0 to 9 (some systems also accept the $ included in the variable name). Algebraic signs cannot be included, and therefore M + 1 is an invalid variable. b)For FORTRAN statements involving arithmetic operations, we use the following symbols: -for subtraction +for addition {_\\ast}{_\\ast}for exponentiation {_\\ast}for multiplication /for division No arithmetic operations are allowed on the left side of the \"=\" sign. c) In the WRITE statement the first number (3) indicates the device that is to be used to print the values obtained at the end of the program. (Typewriter, printer). The second number (13) is the number of the corresponding FORMAT statement (will be discussed in later chapters). The listing of the variables should not be followed by a period. This is an error. d) FORTRAN has no symbol \\textquotedblright\u00d7\" (presumably we mean multiplication, in which case the correct FORTRAN statement is K = 2 {_\\ast} I . (Z^Y)^W or (Z)^(Y)W. These are not always equal. For example, if Z = 2, Y = 3, W = 4: (2^3)^4 \\not = (2)^(3)4.", "ref_id": 4612, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Each of the following is not a correct FORTRAN statement. Give reasons in each case.", "options": ["M + 1 is a valid variable", "Arithmetic operations are allowed on the left side of the '=' sign", "M + 1 is an invalid variable", "FORTRAN has the symbol '\u00d7' for multiplication"], "answer": "C", "solution": "a) The only acceptable characters in a variable name in any FORTRAN statement are the twenty-six letters of the alphabet and the ten digits 0 to 9 (some systems also accept the $ included in the variable name). Algebraic signs cannot be included, and therefore M + 1 is an invalid variable. b)For FORTRAN statements involving arithmetic operations, we use the following symbols: -for subtraction +for addition {_\\ast}{_\\ast}for exponentiation {_\\ast}for multiplication /for division No arithmetic operations are allowed on the left side of the \"=\" sign. c) In the WRITE statement the first number (3) indicates the device that is to be used to print the values obtained at the end of the program. (Typewriter, printer). The second number (13) is the number of the corresponding FORMAT statement (will be discussed in later chapters). The listing of the variables should not be followed by a period. This is an error. d) FORTRAN has no symbol \\textquotedblright\u00d7\" (presumably we mean multiplication, in which case the correct FORTRAN statement is K = 2 {_\\ast} I . (Z^Y)^W or (Z)^(Y)W. These are not always equal. For example, if Z = 2, Y = 3, W = 4: (2^3)^4 \\not = (2)^(3)4."}, "question": "task_1"}}, {"data": {"text": "Question:\nA doctor is testing the potency of a new drug. He compares two groups of samples, an experimental group and a control group. Each group contained 10 samples and yielded 10 results. Every result was assigned a number from 1 to 10 according to the degree of success. Do the two means of these groups differ significantly? Write a FORTRAN program to find out. Control Experimental 10 7 5 3 6 5 7 7 10 8 6 4 7 5 8 6 6 3 5 2\n\nOptions:\nA. The two means differ significantly\nB. The two means do not differ significantly\nC.             The control group has a higher mean\nD. The experimental group has a higher mean\n\nAnswer: B\n\nReference Solution:\nThis is a problem in hypothesis testing for the difference between means of two sets of data. The test used is the t-test and the t-statistic is computed according to the formula t = [x_1 -x_2] / [\\surd(\\sumx^2_1 - {(\\sumx_1)^2 / N_1} + \\sumX^2_2 - {(\\sumX_2)^2 / N_2}] {(1/N_1) + (1/N_2)})] wherex_i- mean ofi-thgroupi= 1,2 ; \\sumx^2_1 - sum of squared score values ofi-thgroup ; (\\sumx_1)^ 2 - square of the sum of scores ini-thgroup; N_i : the number of scores in thei-thgroup. The summary statistics for the given problem are: \\sumx_1 = 70; \\sumx_2 = 50; \\sumx^2_1 = 520; \\sumx^2_2 = 286 (\\sumx_1)^ 2 = 4900; (\\sumx_2)2= 2500; N_1 = 10 N_2 = 10 . Using these the calculated t-value is found to be t = (7 - 5) / 1.82 = 1.10. This calculated t-value is compared with the t-value for N_1 + N_2 - 2 degrees of freedom at the 5% level of significance (i.e., ift_calculated<t_table then the two means do not differ and the observed difference is due to sampling variability). If the calculated t-value exceeds the value in the table for a 5% level, this indicates that the observed difference in means would occur less than 5 times out of 100. Note that the 5% level is the usual level adopted in statistical testing. We conclude that at the 5% level, the two means do not differ signifi-cantly. The new drug does not indicate increased potency. The general program for a test of hypothesis involving two means is given below. CT-TEST FOR INDEPENDENT MEANS DIM X1 (N), X2(M), KF(L) READ (2,1\\O\\O) N1, N2, KF 1\\O\\OFORMAT (2I3/2\\OA4) CINITIALIZE VARIABLES SUM1 = \\O SQ1 = \\O SQ2 = \\O CUSING THE FORMAT THAT WAS READ IN, READ CTHE DATA FOR BOTH GROUPS READ (2,KF) (X1 (J), J = 1,N1) READ (2,KF) (X2(K), K = 1,N2) DO 10 J = 1,N1 SUM1 = SUM1 + X1(J) 1\\OSQ1 = SQ1 + X1 (J)\\textasteriskcentered\\textasteriskcentered2 CCHANGE THE N'S TO FLOATING POINT DN1 = N1 DN2 = N2 S1SQ = SUM1 \\textasteriskcentered\\textasteriskcentered2 S1 = S1SQ/DN1 SN1 = SQ1 - S1 DO 2\\O J = 1,N2 SUM2 = SUM2 + X2(J) 2\\OSQ2 = SQ2 + X2(J)\\textasteriskcentered\\textasteriskcentered2 S2SQ = SUM2\\textasteriskcentered\\textasteriskcentered2 S2 = S2SQ/DN2 SN2 = SQ2 - S2 SN = SN1 + SN2 SS = SN/(DN1 + DN2 - 2.0) SSQ = SS\\textasteriskcentered((1.0/DN1) + (1.0/DN2)) SD = SQRT(SSQ) GM1 = SUM1/DN1 GM2 = SUM2/DN2 DIFF = GM1 - GM2 WRITE (6,2\\O\\O) T 2\\O\\OFORMAT (1H1, 7H THE T-VALUE IS T = , F 10.4 , 167H LOOK IN THE T-TABLES TO SEE WHETHER THE HYPOTHESIS CAN BE REJECTED.) STOP END", "ref_id": 4613, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "A doctor is testing the potency of a new drug. He compares two groups of samples, an experimental group and a control group. Each group contained 10 samples and yielded 10 results. Every result was assigned a number from 1 to 10 according to the degree of success. Do the two means of these groups differ significantly? Write a FORTRAN program to find out. Control Experimental 10 7 5 3 6 5 7 7 10 8 6 4 7 5 8 6 6 3 5 2", "options": ["The two means differ significantly", "The two means do not differ significantly", "The control group has a higher mean", "The experimental group has a higher mean"], "answer": "B", "solution": "This is a problem in hypothesis testing for the difference between means of two sets of data. The test used is the t-test and the t-statistic is computed according to the formula t = [x_1 -x_2] / [\\surd(\\sumx^2_1 - {(\\sumx_1)^2 / N_1} + \\sumX^2_2 - {(\\sumX_2)^2 / N_2}] {(1/N_1) + (1/N_2)})] wherex_i- mean ofi-thgroupi= 1,2 ; \\sumx^2_1 - sum of squared score values ofi-thgroup ; (\\sumx_1)^ 2 - square of the sum of scores ini-thgroup; N_i : the number of scores in thei-thgroup. The summary statistics for the given problem are: \\sumx_1 = 70; \\sumx_2 = 50; \\sumx^2_1 = 520; \\sumx^2_2 = 286 (\\sumx_1)^ 2 = 4900; (\\sumx_2)2= 2500; N_1 = 10 N_2 = 10 . Using these the calculated t-value is found to be t = (7 - 5) / 1.82 = 1.10. This calculated t-value is compared with the t-value for N_1 + N_2 - 2 degrees of freedom at the 5% level of significance (i.e., ift_calculated<t_table then the two means do not differ and the observed difference is due to sampling variability). If the calculated t-value exceeds the value in the table for a 5% level, this indicates that the observed difference in means would occur less than 5 times out of 100. Note that the 5% level is the usual level adopted in statistical testing. We conclude that at the 5% level, the two means do not differ signifi-cantly. The new drug does not indicate increased potency. The general program for a test of hypothesis involving two means is given below. CT-TEST FOR INDEPENDENT MEANS DIM X1 (N), X2(M), KF(L) READ (2,1\\O\\O) N1, N2, KF 1\\O\\OFORMAT (2I3/2\\OA4) CINITIALIZE VARIABLES SUM1 = \\O SQ1 = \\O SQ2 = \\O CUSING THE FORMAT THAT WAS READ IN, READ CTHE DATA FOR BOTH GROUPS READ (2,KF) (X1 (J), J = 1,N1) READ (2,KF) (X2(K), K = 1,N2) DO 10 J = 1,N1 SUM1 = SUM1 + X1(J) 1\\OSQ1 = SQ1 + X1 (J)\\textasteriskcentered\\textasteriskcentered2 CCHANGE THE N'S TO FLOATING POINT DN1 = N1 DN2 = N2 S1SQ = SUM1 \\textasteriskcentered\\textasteriskcentered2 S1 = S1SQ/DN1 SN1 = SQ1 - S1 DO 2\\O J = 1,N2 SUM2 = SUM2 + X2(J) 2\\OSQ2 = SQ2 + X2(J)\\textasteriskcentered\\textasteriskcentered2 S2SQ = SUM2\\textasteriskcentered\\textasteriskcentered2 S2 = S2SQ/DN2 SN2 = SQ2 - S2 SN = SN1 + SN2 SS = SN/(DN1 + DN2 - 2.0) SSQ = SS\\textasteriskcentered((1.0/DN1) + (1.0/DN2)) SD = SQRT(SSQ) GM1 = SUM1/DN1 GM2 = SUM2/DN2 DIFF = GM1 - GM2 WRITE (6,2\\O\\O) T 2\\O\\OFORMAT (1H1, 7H THE T-VALUE IS T = , F 10.4 , 167H LOOK IN THE T-TABLES TO SEE WHETHER THE HYPOTHESIS CAN BE REJECTED.) STOP END"}, "question": "task_1"}}, {"data": {"text": "Question:\nGive an example of a distributed lag model for the national economy, using the national accounting scheme. Is the computer essential for dealing with distributed lag models?\n\nOptions:\nA. The computer is not needed at all\nB. The computer is only needed for large-scale models\nC.             The computer is indispensable at lower levels of aggregation\nD. The computer is always required\n\nAnswer: C\n\nReference Solution:\nIn simulation studies, a problem in the real world is solved using a simple mathematical model in conjunction with the computer. Distributed lag models belong to the class of discrete simulation models. Such models change only at fixed intervals of time, and current values of a given variable are determined by previous values of the same variable. Using Keynesian macroeconomic analysis we can construct a model of the national economy. Let C be consumption, I be investment, T be taxes, G be government expenditure and Y be national income. Then, a general macroeconomic model would be: C = a + c(Y-T) I = b + rY(1) T = tY Y = c + I + G Here, \"a\" represents consumption that is independent of income while \"c\" is the marginal propensity to consume. \"c\" represents the amount per dollar that is spent on con-sumption. \"b\" is investment that is independent of income, and \"r\" is the marginal propensity to invest. Finally, \"t\" is the tax rate per dollar of income. Note that o \\leq c, r, t \\leq 1. Since simulation deals with concrete situations, we should give values to the parameters in (1). Thus, C = 30 + 0.7(Y - T) I= 3+ 0.1(Y)(2) T = . 2Y Y = C + I + G. The above static model can be made dynamic by picking a fixed time interval and then expressing the current values of the variables in terms of values at previous intervals, or lagging them. Thus, we can lag all the variables in (2) by a year to obtain C = 30 + 0.7(Y-1- T_-1) I = 3 + 0.1(Y_-1)(3) T = 0.2Y_-1 Y = C_-1 + I_-1 + G_-1 Model (3) is to be understood as follows: Current consump-tion depends on disposable income from the previous year. Investment is a function of the previous year's national income, as is taxes. In large-scale models, like (3), most calculations can be done without the aid of the computer. But at lower levels of aggregation (say where investment in different industries is considered separately), the computer is indispensable.", "ref_id": 4614, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Give an example of a distributed lag model for the national economy, using the national accounting scheme. Is the computer essential for dealing with distributed lag models?", "options": ["The computer is not needed at all", "The computer is only needed for large-scale models", "The computer is indispensable at lower levels of aggregation", "The computer is always required"], "answer": "C", "solution": "In simulation studies, a problem in the real world is solved using a simple mathematical model in conjunction with the computer. Distributed lag models belong to the class of discrete simulation models. Such models change only at fixed intervals of time, and current values of a given variable are determined by previous values of the same variable. Using Keynesian macroeconomic analysis we can construct a model of the national economy. Let C be consumption, I be investment, T be taxes, G be government expenditure and Y be national income. Then, a general macroeconomic model would be: C = a + c(Y-T) I = b + rY(1) T = tY Y = c + I + G Here, \"a\" represents consumption that is independent of income while \"c\" is the marginal propensity to consume. \"c\" represents the amount per dollar that is spent on con-sumption. \"b\" is investment that is independent of income, and \"r\" is the marginal propensity to invest. Finally, \"t\" is the tax rate per dollar of income. Note that o \\leq c, r, t \\leq 1. Since simulation deals with concrete situations, we should give values to the parameters in (1). Thus, C = 30 + 0.7(Y - T) I= 3+ 0.1(Y)(2) T = . 2Y Y = C + I + G. The above static model can be made dynamic by picking a fixed time interval and then expressing the current values of the variables in terms of values at previous intervals, or lagging them. Thus, we can lag all the variables in (2) by a year to obtain C = 30 + 0.7(Y-1- T_-1) I = 3 + 0.1(Y_-1)(3) T = 0.2Y_-1 Y = C_-1 + I_-1 + G_-1 Model (3) is to be understood as follows: Current consump-tion depends on disposable income from the previous year. Investment is a function of the previous year's national income, as is taxes. In large-scale models, like (3), most calculations can be done without the aid of the computer. But at lower levels of aggregation (say where investment in different industries is considered separately), the computer is indispensable."}, "question": "task_1"}}, {"data": {"text": "Question:\nWrite a FORTRAN program segment to compute values of the POISSON distribution given by P(X) = e^-mm^x/x! Assume (1) that X and m are integer variables; (2) that X and m are small enough that no term will exceed the size permitted for a real variable in your computer; and (3) that the function FACT (n) for computing n! is available.\n\nOptions:\nA. FUNCTION P(X,M) INTEGER X Y = FLOAT (M) P = EXP(Y) * M ** X / FACT (X) RETURN END\nB. FUNCTION P(X,M) INTEGER X Y = FLOAT (M) P = EXP(-Y) * M / X / FACT (X) RETURN END\nC.             FUNCTION P(X,M) INTEGER X Y = FLOAT (M) P = EXP(-Y) * M ** X * FACT (X) RETURN END\nD. FUNCTION P(X,M) INTEGER X Y = FLOAT (M) P = EXP(-Y) * M ** X / FACT (X) RETURN END\n\nAnswer: D\n\nReference Solution:\nRemember that the library functione^yis defined for real y, so we set y = FLOAT(m) to convert the integer m to a real variable when evaluating P. The rest of the Integer expressions, need not be FLOATED since the FORTRAN compiler allows mixing of modes in a product expression of real \\textasteriskcentered integer; the result being converted to a real number. Bearing the above in mind, we can write out the program below: FUNCTION P(X,M) INTEGER X Y = FLOAT (M) P = EXP(-Y) \\textasteriskcentered M \\textasteriskcentered\\textasteriskcentered X / FACT (X) RETURN END The factorial function, FACT (X), is defined in chapter 19.", "ref_id": 4615, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Write a FORTRAN program segment to compute values of the POISSON distribution given by P(X) = e^-mm^x/x! Assume (1) that X and m are integer variables; (2) that X and m are small enough that no term will exceed the size permitted for a real variable in your computer; and (3) that the function FACT (n) for computing n! is available.", "options": ["FUNCTION P(X,M) INTEGER X Y = FLOAT (M) P = EXP(Y) * M ** X / FACT (X) RETURN END", "FUNCTION P(X,M) INTEGER X Y = FLOAT (M) P = EXP(-Y) * M / X / FACT (X) RETURN END", "FUNCTION P(X,M) INTEGER X Y = FLOAT (M) P = EXP(-Y) * M ** X * FACT (X) RETURN END", "FUNCTION P(X,M) INTEGER X Y = FLOAT (M) P = EXP(-Y) * M ** X / FACT (X) RETURN END"], "answer": "D", "solution": "Remember that the library functione^yis defined for real y, so we set y = FLOAT(m) to convert the integer m to a real variable when evaluating P. The rest of the Integer expressions, need not be FLOATED since the FORTRAN compiler allows mixing of modes in a product expression of real \\textasteriskcentered integer; the result being converted to a real number. Bearing the above in mind, we can write out the program below: FUNCTION P(X,M) INTEGER X Y = FLOAT (M) P = EXP(-Y) \\textasteriskcentered M \\textasteriskcentered\\textasteriskcentered X / FACT (X) RETURN END The factorial function, FACT (X), is defined in chapter 19."}, "question": "task_1"}}, {"data": {"text": "Question:\nGive some examples of valid and invalid variable names in BASIC. Ex-plain briefly the differences.\n\nOptions:\nA. C5N, FBG4, KM28\nB. 5N, BG4, M28\nC.             C, F, K1, L9\nD. 5, 4, 28\n\nAnswer: C\n\nReference Solution:\nVariable names in BASIC can be represented by a single letter of the alphabet,or a single letter followed by a single digit, For example: VALID INVALID C 5N (starts with a digit) F BG4 (too many letters) K1 M28 (too many digits) L9", "ref_id": 4616, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Give some examples of valid and invalid variable names in BASIC. Ex-plain briefly the differences.", "options": ["C5N, FBG4, KM28", "5N, BG4, M28", "C, F, K1, L9", "5, 4, 28"], "answer": "C", "solution": "Variable names in BASIC can be represented by a single letter of the alphabet,or a single letter followed by a single digit, For example: VALID INVALID C 5N (starts with a digit) F BG4 (too many letters) K1 M28 (too many digits) L9"}, "question": "task_1"}}, {"data": {"text": "Question:\nWhat are the main methods used for debugging a program and what are their advantages?\n\nOptions:\nA. The main methods for debugging a program include generating output, planning ahead by including output statements into the program, and running the program step by step\nB. Running the program in reverse order\nC.             Rewriting the entire program\nD. Using an automated debugging tool\n\nAnswer: A\n\nReference Solution:\nDEBUGGING is the procedure of eliminating bugs (errors) that almost every program has the first time it is run through the computer. These are some of the indications that the program does indeed have mistakes : answers . closer inspection reveals the answers to be wrong. The following is a list of some of the most commonly used debugging methods : assumes the program is fit enough to generate out-put. 4)Planning ahead is based upon occasionally including output statements into the program. Those output statements usually print intermediate results obtained up to that point. This allows the programmer to follow the execution of his program and check the inter-mediate results, accuracy of which is essential. 5) Running the program step by step: When the computer is in its MANUAL condition, pushing the SINGLE STEP key makes the computer perform one instruction. Each time this key is pushed, the computer will perform the instruction and change the lights on the control panel to indicate the address of the next Instruction. In this way, the entire program is performed step by step. This method can only be used when working directly with the central processing unit of the computer.", "ref_id": 4617, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "What are the main methods used for debugging a program and what are their advantages?", "options": ["The main methods for debugging a program include generating output, planning ahead by including output statements into the program, and running the program step by step", "Running the program in reverse order", "Rewriting the entire program", "Using an automated debugging tool"], "answer": "A", "solution": "DEBUGGING is the procedure of eliminating bugs (errors) that almost every program has the first time it is run through the computer. These are some of the indications that the program does indeed have mistakes : answers . closer inspection reveals the answers to be wrong. The following is a list of some of the most commonly used debugging methods : assumes the program is fit enough to generate out-put. 4)Planning ahead is based upon occasionally including output statements into the program. Those output statements usually print intermediate results obtained up to that point. This allows the programmer to follow the execution of his program and check the inter-mediate results, accuracy of which is essential. 5) Running the program step by step: When the computer is in its MANUAL condition, pushing the SINGLE STEP key makes the computer perform one instruction. Each time this key is pushed, the computer will perform the instruction and change the lights on the control panel to indicate the address of the next Instruction. In this way, the entire program is performed step by step. This method can only be used when working directly with the central processing unit of the computer."}, "question": "task_1"}}, {"data": {"text": "Question:\nThe formula Z = [(e^ax- e ^-ax)/ 2] sin (x + b) + a log [(b + x) / 2] is to be evaluated for all combinations of x: 1.0(0,1) 2.0 a: 0.10(0.05)0.80 b: 1.0(1.0) 10.0 where x: 1.0(0.1) 2.0 means x = 1.0, 1.1, 1.2,...,2.0 and so on. (There are 11 \u00d7 15 \u00d7 10 = 1650 combinations.) For each combination a line giving x, a, b, and Z values is to be written. Write a program containing three DO loops to carry out this computation.\n\nOptions:\nA. DO 100 I = 10,20 X = FLOAT (I)/10.0 DO 100 J = 10,80,5 A = ELOAT(J)/200.0 DO 100 K = 1,10 B = FLOAT(K) Z = 0.5{_\u0007st}(EXP(A{_\u0007st}X) - EXP(-A{_\u0007st}X)){_\u0007st}SIN(X+B) 1+ A{_\u0007st}AL0G ((B+X)/2.) WRITE (6,10) A,B,X,Z\nB. DO 100 I = 10,20 X = FLOAT (I)/20.0 DO 100 J = 10,80,5 A = ELOAT(J)/100.0 DO 100 K = 1,10 B = FLOAT(K) Z = 0.5{_\u0007st}(EXP(A{_\u0007st}X) - EXP(-A{_\u0007st}X)){_\u0007st}SIN(X+B) 1+ A{_\u0007st}AL0G ((B+X)/2.) WRITE (6,10) A,B,X,Z\nC.             DO 200 I = 10,20 X = FLOAT (I)/10.0 DO 100 J = 10,80,5 A = ELOAT(J)/100.0 DO 100 K = 1,10 B = FLOAT(K) Z = 0.5{_\u0007st}(EXP(A{_\u0007st}X) - EXP(-A{_\u0007st}X)){_\u0007st}SIN(X+B) 1+ A{_\u0007st}AL0G ((B+X)/2.) WRITE (6,10) A,B,X,Z\nD. DO 100 I = 10,20 X = FLOAT (I)/10.0 DO 100 J = 10,80,5 A = ELOAT(J)/100.0 DO 100 K = 1,10 B = FLOAT(K) Z = 0.5{_\u0007st}(EXP(A{_\u0007st}X) - EXP(-A{_\u0007st}X)){_\u0007st}SIN(X+B) 1+ A{_\u0007st}AL0G ((B+X)/2.) WRITE (6,10) A,B,X,Z\n\nAnswer: D\n\nReference Solution:\nWe need to obtain integral subscripts for our DO loops. This is no problem for b. For x, though, note that 10{_\\ast}X takes on values 10., 11.,...,20. Thus if I = 10, 11,...,20, X= FLOAT(I)/10. Similarly, 100{_\\ast}A takes on values 10.0, 15.0, 20.0,...,80.0 in steps of 5. Let J = 10, 15, 20, ,..,80. So A = FLOAT (J)/100. [Remember that the library function FLOAT changes an integer number into a real number.] Hence we obtain the program below. DO 100 I = 10,20 X = FLOAT (I)/10.0 DO 100 J = 10,80,5 A = ELOAT(J)/100.0 DO 100 K = 1,10 B = FLOAT(K) Z = 0.5{_\\ast}(EXP(A{_\\ast}X) - EXP(-A{_\\ast}X)){_\\ast}SIN(X+B) 1+ A{_\\ast}AL0G ((B+X)/2.) WRITE (6,10) A,B,X,Z 10FORMAT (4X,3(2X,F6.3), E13.7) 100CONTINUE STOP END", "ref_id": 4618, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "The formula Z = [(e^ax- e ^-ax)/ 2] sin (x + b) + a log [(b + x) / 2] is to be evaluated for all combinations of x: 1.0(0,1) 2.0 a: 0.10(0.05)0.80 b: 1.0(1.0) 10.0 where x: 1.0(0.1) 2.0 means x = 1.0, 1.1, 1.2,...,2.0 and so on. (There are 11 \u00d7 15 \u00d7 10 = 1650 combinations.) For each combination a line giving x, a, b, and Z values is to be written. Write a program containing three DO loops to carry out this computation.", "options": ["DO 100 I = 10,20 X = FLOAT (I)/10.0 DO 100 J = 10,80,5 A = ELOAT(J)/200.0 DO 100 K = 1,10 B = FLOAT(K) Z = 0.5{_\u0007st}(EXP(A{_\u0007st}X) - EXP(-A{_\u0007st}X)){_\u0007st}SIN(X+B) 1+ A{_\u0007st}AL0G ((B+X)/2.) WRITE (6,10) A,B,X,Z", "DO 100 I = 10,20 X = FLOAT (I)/20.0 DO 100 J = 10,80,5 A = ELOAT(J)/100.0 DO 100 K = 1,10 B = FLOAT(K) Z = 0.5{_\u0007st}(EXP(A{_\u0007st}X) - EXP(-A{_\u0007st}X)){_\u0007st}SIN(X+B) 1+ A{_\u0007st}AL0G ((B+X)/2.) WRITE (6,10) A,B,X,Z", "DO 200 I = 10,20 X = FLOAT (I)/10.0 DO 100 J = 10,80,5 A = ELOAT(J)/100.0 DO 100 K = 1,10 B = FLOAT(K) Z = 0.5{_\u0007st}(EXP(A{_\u0007st}X) - EXP(-A{_\u0007st}X)){_\u0007st}SIN(X+B) 1+ A{_\u0007st}AL0G ((B+X)/2.) WRITE (6,10) A,B,X,Z", "DO 100 I = 10,20 X = FLOAT (I)/10.0 DO 100 J = 10,80,5 A = ELOAT(J)/100.0 DO 100 K = 1,10 B = FLOAT(K) Z = 0.5{_\u0007st}(EXP(A{_\u0007st}X) - EXP(-A{_\u0007st}X)){_\u0007st}SIN(X+B) 1+ A{_\u0007st}AL0G ((B+X)/2.) WRITE (6,10) A,B,X,Z"], "answer": "D", "solution": "We need to obtain integral subscripts for our DO loops. This is no problem for b. For x, though, note that 10{_\\ast}X takes on values 10., 11.,...,20. Thus if I = 10, 11,...,20, X= FLOAT(I)/10. Similarly, 100{_\\ast}A takes on values 10.0, 15.0, 20.0,...,80.0 in steps of 5. Let J = 10, 15, 20, ,..,80. So A = FLOAT (J)/100. [Remember that the library function FLOAT changes an integer number into a real number.] Hence we obtain the program below. DO 100 I = 10,20 X = FLOAT (I)/10.0 DO 100 J = 10,80,5 A = ELOAT(J)/100.0 DO 100 K = 1,10 B = FLOAT(K) Z = 0.5{_\\ast}(EXP(A{_\\ast}X) - EXP(-A{_\\ast}X)){_\\ast}SIN(X+B) 1+ A{_\\ast}AL0G ((B+X)/2.) WRITE (6,10) A,B,X,Z 10FORMAT (4X,3(2X,F6.3), E13.7) 100CONTINUE STOP END"}, "question": "task_1"}}, {"data": {"text": "Question:\nWrite a BASIC program to search a data statement for a given name which is typed in when the program is executed.\n\nOptions:\nA. Use of GET function to search for name\nB. Use of PRINT function to display the name\nC.             Use of GOTO function to loop through the names\nD. 1\\O REM PROGRAM SEARCHES THE DATA STATEMENT 2\\O REM FOR A CERTAIN NAME 3\\O PRINT \"TYPE NAME, THEN HIT RETURN\" 4\\O INPUT A$ 5\\O FOR J = 1 TO 5 6\\O READ B$ 7\\O IF B$ = A$ THEN 11\\O 8\\O NEXT J 9\\O PRINT \"CAN'T FIND NAME\" 1\\O\\O GO TO 12\\O 11\\O PRINT B$; \"WAS FOUND\" 12\\O PRINT \"TO CONTINUE TYPE YES; ELSE - NO.\" 13\\O INPUT C 14\\O IF C$ < > \"YES\" THEN 18\\O 15\\O DATA \"JOHN\", \"BOB\", \"JILL\", \"MARY\", \"FRED\" 16\\O RESTORE 17\\O GO TO 3\\O 18\\O END\n\nAnswer: D\n\nReference Solution:\nThis problem introduces the notion of string variables and of comparisons between strings. String variables are denoted by any valid variable name with $ at the end, for example: A$, B$, C1$,..., etc. One can test strings for equality by means of the ' = ' and '< >' operators. When the search is finished, if the user wishes to search for another name, the RESTORE statement is used. 1\\O REM PROGRAM SEARCHES THE DATA STATEMENT 2\\O REM FOR A CERTAIN NAME 3\\O PRINT \"TYPE NAME, THEN HIT RETURN\" 4\\O INPUT A$ 5\\O FOR J = 1 TO 5 6\\O READ B$ 7\\O IF B$ = A$ THEN 11\\O 8\\O NEXT J 9\\O PRINT \"CAN'T FIND NAME\" 1\\O\\O GO TO 12\\O 11\\O PRINT B$; 'WAS FOUND\" 12\\O PRINT \"TO CONTINUE TYPE YES; ELSE - NO.\" 13\\O INPUT C 14\\O IF C$ < > \"YES\" THEN 18\\O 15\\O DATA \"JOHN\", \"BOB\", \"JILL\", \"MARY\", \"FRED\" 16\\O RESTORE 17\\O GO TO 3\\O 18\\O END", "ref_id": 4619, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Write a BASIC program to search a data statement for a given name which is typed in when the program is executed.", "options": ["Use of GET function to search for name", "Use of PRINT function to display the name", "Use of GOTO function to loop through the names", "1\\O REM PROGRAM SEARCHES THE DATA STATEMENT 2\\O REM FOR A CERTAIN NAME 3\\O PRINT \"TYPE NAME, THEN HIT RETURN\" 4\\O INPUT A$ 5\\O FOR J = 1 TO 5 6\\O READ B$ 7\\O IF B$ = A$ THEN 11\\O 8\\O NEXT J 9\\O PRINT \"CAN'T FIND NAME\" 1\\O\\O GO TO 12\\O 11\\O PRINT B$; \"WAS FOUND\" 12\\O PRINT \"TO CONTINUE TYPE YES; ELSE - NO.\" 13\\O INPUT C 14\\O IF C$ < > \"YES\" THEN 18\\O 15\\O DATA \"JOHN\", \"BOB\", \"JILL\", \"MARY\", \"FRED\" 16\\O RESTORE 17\\O GO TO 3\\O 18\\O END"], "answer": "D", "solution": "This problem introduces the notion of string variables and of comparisons between strings. String variables are denoted by any valid variable name with $ at the end, for example: A$, B$, C1$,..., etc. One can test strings for equality by means of the ' = ' and '< >' operators. When the search is finished, if the user wishes to search for another name, the RESTORE statement is used. 1\\O REM PROGRAM SEARCHES THE DATA STATEMENT 2\\O REM FOR A CERTAIN NAME 3\\O PRINT \"TYPE NAME, THEN HIT RETURN\" 4\\O INPUT A$ 5\\O FOR J = 1 TO 5 6\\O READ B$ 7\\O IF B$ = A$ THEN 11\\O 8\\O NEXT J 9\\O PRINT \"CAN'T FIND NAME\" 1\\O\\O GO TO 12\\O 11\\O PRINT B$; 'WAS FOUND\" 12\\O PRINT \"TO CONTINUE TYPE YES; ELSE - NO.\" 13\\O INPUT C 14\\O IF C$ < > \"YES\" THEN 18\\O 15\\O DATA \"JOHN\", \"BOB\", \"JILL\", \"MARY\", \"FRED\" 16\\O RESTORE 17\\O GO TO 3\\O 18\\O END"}, "question": "task_1"}}, {"data": {"text": "Question:\nGiven the coordinates of three points (X_1 ,Y_1 ), (X_2 ,Y_2 ), and (X_3 ,Y_3), developea program which outputs a message regarding theircollinearity. (Three points are collinear if they all lie on the same line.) Include statements that will take into account round-off errors.\n\nOptions:\nA. Three points are collinear if (Y_2 -Y_1)/ (X_2 - X_1) != (Y3- Y_2)/ (X3- X_2)\nB. Three points are collinear if (Y_2 -Y_1)* (X_2 - X_1) = (Y3- Y_2)* (X3- X_2)\nC.             Three points are collinear if (Y_2 -Y_1)/ (X_2 - X_1) = (Y3- Y_2)/ (X3- X_2)\nD. Three points are collinear if (Y_2 +Y_1)/ (X_2 + X_1) = (Y3+ Y_2)/ (X3+ X_2)\n\nAnswer: C\n\nReference Solution:\nThe solution to the problem rests on the fact that three points P_1 , P_2 , and P_3 are collinear if and only if the slopes of the segments P_1 P_2 and P_2 P_3 are equal. This implies (Y_2 -Y_1)/ (X_2 - X_1) = (Y3- Y_2)/ (X3- X_2) where (X_1,Y_1), (X_2 ,Y_2 ) and (X_3 ,Y_3 ) are the coordinates of three points. Instead of calculating slopes, we can test the expressions (Y2- Y_1) \u00d7 (X_3 - X_2) and (Y_3 - Y_2) \u00d7 (X_2 - Y_1) , for equality. If they are equal, the three points are collinear, and an appropriate message is output. This expression may also be used to establish the degree of round-off error. One way of doing this is with the statement ABS((Y2 - Y1){_\\ast}(X3 - X2) - (Y3 - Y2){_\\ast}(X2 - X1)) If this quantity is very small, say, less than .0001, we can accept the accuracy ofcollinearity. If this condition is not met, a message indicates that there is an unacceptable accuracy in the determination. We use a format-free READ statement in the program for simplicity's sake, a feature available on some machines. CCOLLINEARITY PROGRAM READ (5,{_\\ast}) X1, Y1, X2, Y2, X3, Y3 ,ACCUR CARE THEY COLLINEAR? IF((Y2 - Y1){_\\ast}(X3 - X2). NE. (Y3 - Y2){_\\ast}(X2 - X1)) GO TO 30 WRITE (5,100) X1, Y1, X2, Y2, X3, Y3 100FORMAT (1X, 'THE PAIRS OF POINTS ', 3(1X,2(1X,F7.5)), 'ARE 1COLLINEAR') TEST = ABS((Y2 - Y1){_\\ast}(X3 - X2) - (Y3 - Y2){_\\ast}(X2 - X1)) IF (TEST. GE. ACCUR) GO TO 25 WRITE (5,101) ACCUR 101FORMAT(1X, 'WITH DESIRED ACCURACY TO ', F7.5) GO TO 99 25WRITE (5,101) ACCUR 101FORMAT (1X 'WITHOUT ACCURACY OF', F7.5) 30WRITE (5,102) 102FORMAT (1X,'POINTS ARE NOT COLL INEAR') 99STOP END", "ref_id": 4620, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Given the coordinates of three points (X_1 ,Y_1 ), (X_2 ,Y_2 ), and (X_3 ,Y_3), developea program which outputs a message regarding theircollinearity. (Three points are collinear if they all lie on the same line.) Include statements that will take into account round-off errors.", "options": ["Three points are collinear if (Y_2 -Y_1)/ (X_2 - X_1) != (Y3- Y_2)/ (X3- X_2)", "Three points are collinear if (Y_2 -Y_1)* (X_2 - X_1) = (Y3- Y_2)* (X3- X_2)", "Three points are collinear if (Y_2 -Y_1)/ (X_2 - X_1) = (Y3- Y_2)/ (X3- X_2)", "Three points are collinear if (Y_2 +Y_1)/ (X_2 + X_1) = (Y3+ Y_2)/ (X3+ X_2)"], "answer": "C", "solution": "The solution to the problem rests on the fact that three points P_1 , P_2 , and P_3 are collinear if and only if the slopes of the segments P_1 P_2 and P_2 P_3 are equal. This implies (Y_2 -Y_1)/ (X_2 - X_1) = (Y3- Y_2)/ (X3- X_2) where (X_1,Y_1), (X_2 ,Y_2 ) and (X_3 ,Y_3 ) are the coordinates of three points. Instead of calculating slopes, we can test the expressions (Y2- Y_1) \u00d7 (X_3 - X_2) and (Y_3 - Y_2) \u00d7 (X_2 - Y_1) , for equality. If they are equal, the three points are collinear, and an appropriate message is output. This expression may also be used to establish the degree of round-off error. One way of doing this is with the statement ABS((Y2 - Y1){_\\ast}(X3 - X2) - (Y3 - Y2){_\\ast}(X2 - X1)) If this quantity is very small, say, less than .0001, we can accept the accuracy ofcollinearity. If this condition is not met, a message indicates that there is an unacceptable accuracy in the determination. We use a format-free READ statement in the program for simplicity's sake, a feature available on some machines. CCOLLINEARITY PROGRAM READ (5,{_\\ast}) X1, Y1, X2, Y2, X3, Y3 ,ACCUR CARE THEY COLLINEAR? IF((Y2 - Y1){_\\ast}(X3 - X2). NE. (Y3 - Y2){_\\ast}(X2 - X1)) GO TO 30 WRITE (5,100) X1, Y1, X2, Y2, X3, Y3 100FORMAT (1X, 'THE PAIRS OF POINTS ', 3(1X,2(1X,F7.5)), 'ARE 1COLLINEAR') TEST = ABS((Y2 - Y1){_\\ast}(X3 - X2) - (Y3 - Y2){_\\ast}(X2 - X1)) IF (TEST. GE. ACCUR) GO TO 25 WRITE (5,101) ACCUR 101FORMAT(1X, 'WITH DESIRED ACCURACY TO ', F7.5) GO TO 99 25WRITE (5,101) ACCUR 101FORMAT (1X 'WITHOUT ACCURACY OF', F7.5) 30WRITE (5,102) 102FORMAT (1X,'POINTS ARE NOT COLL INEAR') 99STOP END"}, "question": "task_1"}}, {"data": {"text": "Question:\nTwo species form a predator-prey pair. Their relation is expressed by the rule: The rate of predator population Increase is proportional to an excess in prey population and the rate of decrease of the prey pop-ulation is proportional to the increase of its enemy's population. Let N_1(t), N_2(t) be the prey and predator populations, respectively and A_1, A_2, are positive constants for natural (i.e., in absence of other species) rates of birth (per unit of population per unit of time). Write a FORTRAN program which uses the modified Euler method to simulate this system from time t = 0 to t =t_fif N_1(0) = N_10 and N_2(0) = N_20.\n\nOptions:\nA. A Java program using the Gauss-Seidel method\nB. A C++ program using the Newton's method\nC.             A Python program using the Runge-Kutta method\nD. A FORTRAN program using the modified Euler method\n\nAnswer: D\n\nReference Solution:\nProceeding directly to the mathematical model, one can express the predator-prey relation as: \u1e44\u0307_1 = -A_2N_2(1) \u1e44\u0307_2 = A_1N_1(2) The program applies the modified Euler method first to equation (1) and then to equation (2). N1 and N2 are kept in a COMMON block so that the new computed value of N1 could be used in determining N2. A logical flag, TWO, is used to determine which equation is being integrated: REALT/0.0/,TFIN,DT,REALN,ACCUR,N1,N2,N10,N20,A1,A2 INTEGER I,N LOGICAL TWO/.FALSE./ COMMON TW0,N1,N2,A1,A2 READ,N,TFIN,ACCUR,NIO,N20,A1,A2 PRINT,T,NIO,N20 REALN = N DT = TFIN/REALN N1 = N10 N2 = N20 DO 10 I = 1,N T = T + DT CALL MEULER(T,N1, ACC UR, DT) TWO = .TRUE. CALL MEULER (T,N2,ACCUR,DT) TWO = .FALSE. PRINT, T,N1,N2 10CONTINUE STOP END FUNCTION G(W) REAL G,W,N1,N2,A1,A2 LOGICAL TWO COMMON TWO,N1 ,N2 ,A1 ,A2 G = (-A2)\\textasteriskcenteredN2 IF (TWO) G = A1\\textasteriskcenteredN1 RETURN END Note, that if equation (1) is differentiated, the result is: \u1e44\u0307= -A_2\u1e44_2(3) Substituting equation (2) into equation (3) one gets: \u1e44\u0307_1 = -A_2A_1N_1(4) Differentiating equation (2) and substituting equation (1) into the result yields: \u1e44\u0307_2 = -A_2A_1N_2(5) Equations (4) and (5) are of the form \u04f1 = -Ay where A = -A_2A_1 is constant. The conclusion can be made that this is a free harmonic oscillating system.", "ref_id": 4621, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Two species form a predator-prey pair. Their relation is expressed by the rule: The rate of predator population Increase is proportional to an excess in prey population and the rate of decrease of the prey pop-ulation is proportional to the increase of its enemy's population. Let N_1(t), N_2(t) be the prey and predator populations, respectively and A_1, A_2, are positive constants for natural (i.e., in absence of other species) rates of birth (per unit of population per unit of time). Write a FORTRAN program which uses the modified Euler method to simulate this system from time t = 0 to t =t_fif N_1(0) = N_10 and N_2(0) = N_20.", "options": ["A Java program using the Gauss-Seidel method", "A C++ program using the Newton's method", "A Python program using the Runge-Kutta method", "A FORTRAN program using the modified Euler method"], "answer": "D", "solution": "Proceeding directly to the mathematical model, one can express the predator-prey relation as: \u1e44\u0307_1 = -A_2N_2(1) \u1e44\u0307_2 = A_1N_1(2) The program applies the modified Euler method first to equation (1) and then to equation (2). N1 and N2 are kept in a COMMON block so that the new computed value of N1 could be used in determining N2. A logical flag, TWO, is used to determine which equation is being integrated: REALT/0.0/,TFIN,DT,REALN,ACCUR,N1,N2,N10,N20,A1,A2 INTEGER I,N LOGICAL TWO/.FALSE./ COMMON TW0,N1,N2,A1,A2 READ,N,TFIN,ACCUR,NIO,N20,A1,A2 PRINT,T,NIO,N20 REALN = N DT = TFIN/REALN N1 = N10 N2 = N20 DO 10 I = 1,N T = T + DT CALL MEULER(T,N1, ACC UR, DT) TWO = .TRUE. CALL MEULER (T,N2,ACCUR,DT) TWO = .FALSE. PRINT, T,N1,N2 10CONTINUE STOP END FUNCTION G(W) REAL G,W,N1,N2,A1,A2 LOGICAL TWO COMMON TWO,N1 ,N2 ,A1 ,A2 G = (-A2)\\textasteriskcenteredN2 IF (TWO) G = A1\\textasteriskcenteredN1 RETURN END Note, that if equation (1) is differentiated, the result is: \u1e44\u0307= -A_2\u1e44_2(3) Substituting equation (2) into equation (3) one gets: \u1e44\u0307_1 = -A_2A_1N_1(4) Differentiating equation (2) and substituting equation (1) into the result yields: \u1e44\u0307_2 = -A_2A_1N_2(5) Equations (4) and (5) are of the form \u04f1 = -Ay where A = -A_2A_1 is constant. The conclusion can be made that this is a free harmonic oscillating system."}, "question": "task_1"}}, {"data": {"text": "Question:\nExplain briefly the background and applications of BASIC computer language.\n\nOptions:\nA. BASIC is a language primarily used in the field of arts and literature.\nB. BASIC is a language developed at Dartmouth College in the 1960s to make the computer more accessible and easy to use. It is widely used in science, business, and engineering due to its simplicity and similarity to English and algebra.\nC.             BASIC was developed in the 1980s to simplify computer programming.\nD. BASIC was developed by Microsoft to enhance the Windows operating system.\n\nAnswer: B\n\nReference Solution:\nBASIC (Beginner's All-purpose Symbolic Instruction Code). In the early 1960's, a project was undertaken at Dartmouth College to make the computer more accessible and easy to use by both students and faculty. One of the objectives was to develop a language that could be quickly learned but powerful enough to be used in solving most small to medium scale problems in any discipline. The result of this effort was BASIC, and it more than met its objective. Since BASIC provides the opportunity for someone with little or no previous computer experience to quickly begin writing programs and using the computer, it is commonly available on time sharing systems. BASIC's statements and operands are, probably, the closest to actual English language and algebra respectively and the easiest to comprehend, which ensures its huge popularity in almost every field of science, business, and engineering.", "ref_id": 4622, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Explain briefly the background and applications of BASIC computer language.", "options": ["BASIC is a language primarily used in the field of arts and literature.", "BASIC is a language developed at Dartmouth College in the 1960s to make the computer more accessible and easy to use. It is widely used in science, business, and engineering due to its simplicity and similarity to English and algebra.", "BASIC was developed in the 1980s to simplify computer programming.", "BASIC was developed by Microsoft to enhance the Windows operating system."], "answer": "B", "solution": "BASIC (Beginner's All-purpose Symbolic Instruction Code). In the early 1960's, a project was undertaken at Dartmouth College to make the computer more accessible and easy to use by both students and faculty. One of the objectives was to develop a language that could be quickly learned but powerful enough to be used in solving most small to medium scale problems in any discipline. The result of this effort was BASIC, and it more than met its objective. Since BASIC provides the opportunity for someone with little or no previous computer experience to quickly begin writing programs and using the computer, it is commonly available on time sharing systems. BASIC's statements and operands are, probably, the closest to actual English language and algebra respectively and the easiest to comprehend, which ensures its huge popularity in almost every field of science, business, and engineering."}, "question": "task_1"}}, {"data": {"text": "Question:\nHow are tracers useful as a debugging aid?\n\nOptions:\nA. Tracers help to reduce the execution time of a program\nB. Tracers help to encrypt the program\nC.             Tracers help to optimize the code\nD. Tracers help locate bugs by analyzing and executing real machine instructions one at a time, allowing complete internal program inspection.\n\nAnswer: D\n\nReference Solution:\nSuppose a computer runs and executes a program but produces incorrect results. If the programmer is unable to locate the bugs by the usual methods (running test data, checking size dimensions, etc.), an emergency technique called tracing can be applied. Tracing is usually done with an interpreter, whose routine dissects, analyzes and executes pseudo-instructions. (Pseudo-instructions do not form part of the program but are neces-sary for its execution). The tracer is an interpretive routine that analyzes and executes real machine instructions one at a time. To understand its opera-tion consider the following problem: The trouble with the program being debugged is suspected to be in the action of a loop. While the loop is being executed, the values of some variables go out of bounds. Using the tracer routine, the contents of the accumulator are printed out before each instruc-tion in the loop is executed. The point at which the variables misbehave can thus be located. The advantage of the trace routine is that the complete internal program is available for external inspection. This is, at the same time, its disadvantage. A series of nested loops may require a few thousand iterations. All these iterations will be executed and printed at printer speed. Clearly, the computer time involved is prohibitive. Hence, tracing functions have been modified to execute only non-branch commands, attached to high speed printers. If a branch is met, selected registers are printed before execution of the branch.", "ref_id": 4623, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "How are tracers useful as a debugging aid?", "options": ["Tracers help to reduce the execution time of a program", "Tracers help to encrypt the program", "Tracers help to optimize the code", "Tracers help locate bugs by analyzing and executing real machine instructions one at a time, allowing complete internal program inspection."], "answer": "D", "solution": "Suppose a computer runs and executes a program but produces incorrect results. If the programmer is unable to locate the bugs by the usual methods (running test data, checking size dimensions, etc.), an emergency technique called tracing can be applied. Tracing is usually done with an interpreter, whose routine dissects, analyzes and executes pseudo-instructions. (Pseudo-instructions do not form part of the program but are neces-sary for its execution). The tracer is an interpretive routine that analyzes and executes real machine instructions one at a time. To understand its opera-tion consider the following problem: The trouble with the program being debugged is suspected to be in the action of a loop. While the loop is being executed, the values of some variables go out of bounds. Using the tracer routine, the contents of the accumulator are printed out before each instruc-tion in the loop is executed. The point at which the variables misbehave can thus be located. The advantage of the trace routine is that the complete internal program is available for external inspection. This is, at the same time, its disadvantage. A series of nested loops may require a few thousand iterations. All these iterations will be executed and printed at printer speed. Clearly, the computer time involved is prohibitive. Hence, tracing functions have been modified to execute only non-branch commands, attached to high speed printers. If a branch is met, selected registers are printed before execution of the branch."}, "question": "task_1"}}, {"data": {"text": "Question:\nDesign a FORTRAN function to simulate trials according to the geometric distribution f(x) =pq^x, where p is the probability of success on any trial, and q = 1 - p is the probability of failure.\n\nOptions:\nA. INTEGER FUNCTION TRIALS(P)\nB. INTEGER FUNCTION BERN(P)\nC.             INTEGER FUNCTION SIMULATE(P)\nD. INTEGER FUNCTION GEO(P)\n\nAnswer: B\n\nReference Solution:\nThis perfectly binary probability structure is derived from the notion of Bernoulli trials, in which the only two possible outcomes are \"success\" and \"failure\". If a sequence of these independent trials is performed, the probability of obtaining X failures before reaching a success can be exhibited by the geometric distribution. There are two approaches to this problem, both depending on the value of p. If p is close to 0 or 1, we can generate a series of inde-pendent trials, and count the number of trials necessary before a suc-cess appears. As q = 1 - p, we can generate a series of random numbers between 0 and 1 and can call the series S. Let Si be thei-thterm of the series S. As we generate a new term Si, we compare its value with q. As soon as Si > q at any point during iteration, procedure stops, andi- 1 turns out to be the value of the geometric variable X. The alternate approach, when p is not close to 0 or 1, uses the formula [i= log r / log q], in whichiis the geometric variable, r is a random number such that 0 \\leq r \\leq 1, q = 1 - p, and the brackets indicate that only the integer part of the result is desired. This method is unreliable when p is close to 0 or 1 because the ALOG library function is computed with a power series that, on most machines, is imprecise when calculating values near the parameters of the chosen interval. The function procedure is described below. Comments highlight the two different methods of solution. INTEGER FUNCTION BERN(P) CRETURN TO THE MAIN PROGRAM IS CONTINGENT CUPON FINDING THE FIRST SUCCESS IF (P.LE. .\\O5 .OR. P. GE. .95) GO TO 1\\O CLOGARITHMIC METHOD X = RNDM (NUM) BERN = INT(1.\\O + (ALOG 1\\O (X) / ALOG 1\\O(1.\\O - P))) RETURN CTHIS IS THE COUNTING METHOD, WHICH CAVOIDS THE AFOREMENTIONED PRECISION DIFFICULTIES 1\\ODO 2\\O J = 1, 1\\O\\O\\O X = RNDM (NUM) IF (X.LT.P) GO TO 3\\O 2\\OCONTINUE CIF NO SUCCESSES, BERN = 1\\O\\O\\O\\O BERN = 1\\O\\O\\O\\O RETURN CSUCCESS! 3\\OBERN = J RETURN END Some FORTRAN compilers contain random number generation function as a library function. For those which do not, the function has to be defined and called. In this program, the random number generation function is called by means of X = RNDM (NUM) statement and has the following (generally used) procedure: FUNCTION RNDM (NUM) IF (NUM. GT. 0) INUM = NUM INU = 65539 \\textasteriskcentered INUM IF (INU.LT. 0) INU = INU + 2147483647 + 1 RNDM = .4656613E - 9 \\textasteriskcentered FLOAT (INU) INUM = INU RETURN END", "ref_id": 4624, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Design a FORTRAN function to simulate trials according to the geometric distribution f(x) =pq^x, where p is the probability of success on any trial, and q = 1 - p is the probability of failure.", "options": ["INTEGER FUNCTION TRIALS(P)", "INTEGER FUNCTION BERN(P)", "INTEGER FUNCTION SIMULATE(P)", "INTEGER FUNCTION GEO(P)"], "answer": "B", "solution": "This perfectly binary probability structure is derived from the notion of Bernoulli trials, in which the only two possible outcomes are \"success\" and \"failure\". If a sequence of these independent trials is performed, the probability of obtaining X failures before reaching a success can be exhibited by the geometric distribution. There are two approaches to this problem, both depending on the value of p. If p is close to 0 or 1, we can generate a series of inde-pendent trials, and count the number of trials necessary before a suc-cess appears. As q = 1 - p, we can generate a series of random numbers between 0 and 1 and can call the series S. Let Si be thei-thterm of the series S. As we generate a new term Si, we compare its value with q. As soon as Si > q at any point during iteration, procedure stops, andi- 1 turns out to be the value of the geometric variable X. The alternate approach, when p is not close to 0 or 1, uses the formula [i= log r / log q], in whichiis the geometric variable, r is a random number such that 0 \\leq r \\leq 1, q = 1 - p, and the brackets indicate that only the integer part of the result is desired. This method is unreliable when p is close to 0 or 1 because the ALOG library function is computed with a power series that, on most machines, is imprecise when calculating values near the parameters of the chosen interval. The function procedure is described below. Comments highlight the two different methods of solution. INTEGER FUNCTION BERN(P) CRETURN TO THE MAIN PROGRAM IS CONTINGENT CUPON FINDING THE FIRST SUCCESS IF (P.LE. .\\O5 .OR. P. GE. .95) GO TO 1\\O CLOGARITHMIC METHOD X = RNDM (NUM) BERN = INT(1.\\O + (ALOG 1\\O (X) / ALOG 1\\O(1.\\O - P))) RETURN CTHIS IS THE COUNTING METHOD, WHICH CAVOIDS THE AFOREMENTIONED PRECISION DIFFICULTIES 1\\ODO 2\\O J = 1, 1\\O\\O\\O X = RNDM (NUM) IF (X.LT.P) GO TO 3\\O 2\\OCONTINUE CIF NO SUCCESSES, BERN = 1\\O\\O\\O\\O BERN = 1\\O\\O\\O\\O RETURN CSUCCESS! 3\\OBERN = J RETURN END Some FORTRAN compilers contain random number generation function as a library function. For those which do not, the function has to be defined and called. In this program, the random number generation function is called by means of X = RNDM (NUM) statement and has the following (generally used) procedure: FUNCTION RNDM (NUM) IF (NUM. GT. 0) INUM = NUM INU = 65539 \\textasteriskcentered INUM IF (INU.LT. 0) INU = INU + 2147483647 + 1 RNDM = .4656613E - 9 \\textasteriskcentered FLOAT (INU) INUM = INU RETURN END"}, "question": "task_1"}}, {"data": {"text": "Question:\nThe \"Meat is Neat\" company wishes to enter the frozen shrimp market. They contract a researcher to investigate various methods of growing shrimp in large tanks. The researcher suspects that temperature and salinity are important factors influencing shrimp yield and conducts a factorial experiment with three levels of temperature and salinity. That is, each combination of temperature and salinity are employed and the shrimp yield for each (from identical 80 gallon tanks) is measured. The recorded yields are given in the following chart: Temperature Salinity (inppm) 700 1400 2100 60 3 5 4 70 11 10 12 80 16 21 17 Write a computer program that computes the ANOVA (analysis of variance) tables.\n\nOptions:\nA. ANOVA table\nB. T-test\nC.             Chi-square test\nD. Regression analysis\n\nAnswer: A\n\nReference Solution:\nThis is a two factor factorial design experiment. The logic of the program is best illustrated by showing how the above problem is solved. The interaction model is Y_ij= \\mu +\\alpha_i+\\beta_j+\\epsilon_iji= 1, 2, 3 j = 1, 2. 3 The construction of the ANOVA table requires the computation of various sums of squares. If\\alpha_iis the effect due to temperature, then the row averages are: Y_1. = (3 + 5 + 4) / 3 = 4 Y_2. = (11 + 10 + 12) / 3 = 11 Y_3. = (16 + 21 + 17) / 3 = 18 The column averages are: Y.1 = (3 + 11 + 16) / 3 = 10 Y.2 = (5 + 10 + 21) / 3 = 12 Y.3 = (4 + 12 + 17) / 3 = 11 Y.. = (4 + 11 + 18) / 3 = 11 = (10 + 12 + 11) / 3 (The dots represent the index over which summation is taking place). The sum of squares about the origin is: ^3\\sum_i=1 ^3\\sum_j=1 y^2_ij = 3^2 + 5^2 + 4^2 + 11^2 + ... + 21^2 + 17^2 = 9 + 25 + 16 + 121 + ... + 441 + 289 = 1401. The sum of squares due to variation in temperature is: SSA= ^3\\sum_i=1 ^3\\sum_j=1 (Y_i. -Y..)^2 = 3\\sum(Y_i. -Y..)^2 = 3[(4 - 11)^2 + (11 - 11)^2 + (18 - 11)^2] = 3[49 + 49] = 294. The sum of squares due to variation in salinity is: SSB= ^3\\sum_i=1 ^3\\sum_j=1 (Y._j-Y..)^2 = 3 ^3\\sum_j=1 (Y._j-Y..)^2 = 3[(10 - 11)^2 + (12 - 11)^2 + (11 - 11)^2] = 3[1 + 1 + 0] = 6 The total sum of squares is: SSTO = ^3\\sum_i=1 ^3\\sum_j=1 (Y_ij-Y..)^2 = ^3\\sum_i=1 ^3\\sum_j=1Y^2_ij - 9.Y^2.. = 1401 - 9.11^2 = 1401 - 1089 = 312. Thus, the sum of squares due to the error is SSE= SSTO - SSA - SSB = 312 - 6 - 294 = 12 . The ANOVA table (Analysis of Variance) Source of Variation Sum of Squares Degrees of Freedom Mean Squares Temperature 294 3 - 1 = 2 147 Salinity 6 3 - 1 = 2 3 Error 12 (9 -1) - 4 = 4 3 The program looks as follows: CPROGRAM FOR FACTORIAL DESIGN: TWO FACTORS CSUBPROGRAMS FOLLOW AFTER MAIN PROGRAM DIMENSION A(2\\O), B(2\\O), C(2\\O,2\\O), LA(2\\O), LB(2\\O) DIMENSION SN(2\\O,2\\O), SA(2\\O), AM(2\\O), SB(2\\O), BM(2\\O) DIMENSION CLM(2\\O,2\\O), KH(5), K1(4), K2(4), K3(4), 1N(2\\O,2\\O), KF(2\\O), D(1\\O,2\\O,5\\O) ND = 2\\O 99READ (2,1\\O\\O)KH, K1, K2, K3, K,L, ((N(I,J), J = 1,K), I = 1,L) WRITE (3,2\\O\\O)KH,K1,K2, K3, K,L, ((N(I,J), J = 1,K), I = 1,L) 1\\O\\OFORMAT (5A4, 3(4A4), 213/4\\OI2) 2\\O\\OFORMAT (\\textasteriskcentered1\\textasteriskcentered, 5A4, 3(4A4), 2I3/4\\OI2) READ (2,3\\O\\O) KF WRITE (3,3\\O\\O) KF 3\\O\\OFORMAT (2\\OA4) T = 0 XX = 0 NC = 0 DO 1\\O J = 1,L A(J) = 0 1\\OLA(J) = 0 DO 2\\O M = 1 ,K B(M) =0 LB(M) = 0 DO 3\\O J = 1,L DO 3\\O M = 1,K 3\\OC(J,M) = 0 DO 4\\O J = 1,L DO 4\\O M = 1,K NUM = N(J,M) DO 4\\O I = 1,NUM T = T + D(J,M,I) XX = XX + D(J,M, I) \\textasteriskcentered\\textasteriskcentered 2 B(M) = B(M) + D(J,M,I) A(J) = A(J) + D(J,M,I) 4\\OC(J,M) = C(J,M) + D(J,M,I) DO 5\\O I = 1,L DO 5\\O J = 1,K LA (I) = LA (I) + N(I, J) LB(J) = LB(J) + H(I,J) NC = NC + N(I, J) 5\\OSN(I,J) = N(I, J) AA = 0 BB = 0 CLL = 0 DO 6\\O I = 1,L SA(I) = LA (I) AM (I) = A(I)/SA(I) AA = AA + A (I) \\textasteriskcentered\\textasteriskcentered 2/SA(I) DO 6\\O J = 1,K CLM(I,J) = C(I,J)/SN(I,J) 6\\OCLL = CLL + C(I, J) \\textasteriskcentered\\textasteriskcentered 2/SN(I,J) DO 7\\O J = 1,K SB(J) = LB(J) BM(J) = B(J)/SB(J) 7\\OBB = BB + B(J) \\textasteriskcentered\\textasteriskcentered 2/SB(J) CCOMPUTE SS, DF, MS, F CCC = T \\textasteriskcentered\\textasteriskcentered 2/NC BETA = AA - CCC BETB = BB - CCC BETC = CLL - CCC AB = BETC - BETA - BETB TOT = XX - CCC ERR = TOT - BETC DT = NC - 1 DA = L - 1 DB = K - 1 DC = L \\textasteriskcentered K - 1 DAB = DA \\textasteriskcentered CB DER = DT - DC AMS = BETA/DA BMS = BETB/DB ABMS = AB/DAB ERMS = ERR/DER FA = AMS/ERUS FB = BMS/ERMS FAB = ABMS/ERMS PA = PRBF(CA,DER,FA) PB = PRBF(CAB,DER,FB) WRITE (3,4\\O\\O) KH, TOT, DT, K1, BETA, DA, AMS, FA, 1PA,K2,BETB, BMS, FB, PB,K3, AB, DAB, ABMS, FAB, PAB, 2ERR, DER, ERMS 4\\O\\OFORMAT CALL PRTS (AM, L, 1, 7H AMEANS, ND) CALL PRTS (BM, K, 1, 7H BMEANS, ND) CALL PRTS (CLM, L, K, 8H ABMEANS, ND) END SUBROUTINE PRTS (X,N,M,KH,ND) CPRINT A MATRIX OR VECTOR IN 1\\O-COLUMN PARTITIONS DIMENSION X(2\\O,2\\O) KH(2) IF (M.GT.1) GO TO 2\\O DO 1\\O I = 1,N,1\\O J = MINO (I + 9,N) WRITE (3,5) KH, (K,K = I,J) 5FORMAT (2A4, 1\\OI11) 1\\OWRITE (3,15) (X(K,1), K = I,J) 15FORMAT (119X, 1\\OF11.4) RETURN 2\\ODO 25 I = 1,N 25WRITE (3,3\\O) I, (x(I,J), J = K,L) 3\\OFORMAT (11 I6, 4X, 1\\OF 11.4) RETURN END", "ref_id": 4625, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "The \"Meat is Neat\" company wishes to enter the frozen shrimp market. They contract a researcher to investigate various methods of growing shrimp in large tanks. The researcher suspects that temperature and salinity are important factors influencing shrimp yield and conducts a factorial experiment with three levels of temperature and salinity. That is, each combination of temperature and salinity are employed and the shrimp yield for each (from identical 80 gallon tanks) is measured. The recorded yields are given in the following chart: Temperature Salinity (inppm) 700 1400 2100 60 3 5 4 70 11 10 12 80 16 21 17 Write a computer program that computes the ANOVA (analysis of variance) tables.", "options": ["ANOVA table", "T-test", "Chi-square test", "Regression analysis"], "answer": "A", "solution": "This is a two factor factorial design experiment. The logic of the program is best illustrated by showing how the above problem is solved. The interaction model is Y_ij= \\mu +\\alpha_i+\\beta_j+\\epsilon_iji= 1, 2, 3 j = 1, 2. 3 The construction of the ANOVA table requires the computation of various sums of squares. If\\alpha_iis the effect due to temperature, then the row averages are: Y_1. = (3 + 5 + 4) / 3 = 4 Y_2. = (11 + 10 + 12) / 3 = 11 Y_3. = (16 + 21 + 17) / 3 = 18 The column averages are: Y.1 = (3 + 11 + 16) / 3 = 10 Y.2 = (5 + 10 + 21) / 3 = 12 Y.3 = (4 + 12 + 17) / 3 = 11 Y.. = (4 + 11 + 18) / 3 = 11 = (10 + 12 + 11) / 3 (The dots represent the index over which summation is taking place). The sum of squares about the origin is: ^3\\sum_i=1 ^3\\sum_j=1 y^2_ij = 3^2 + 5^2 + 4^2 + 11^2 + ... + 21^2 + 17^2 = 9 + 25 + 16 + 121 + ... + 441 + 289 = 1401. The sum of squares due to variation in temperature is: SSA= ^3\\sum_i=1 ^3\\sum_j=1 (Y_i. -Y..)^2 = 3\\sum(Y_i. -Y..)^2 = 3[(4 - 11)^2 + (11 - 11)^2 + (18 - 11)^2] = 3[49 + 49] = 294. The sum of squares due to variation in salinity is: SSB= ^3\\sum_i=1 ^3\\sum_j=1 (Y._j-Y..)^2 = 3 ^3\\sum_j=1 (Y._j-Y..)^2 = 3[(10 - 11)^2 + (12 - 11)^2 + (11 - 11)^2] = 3[1 + 1 + 0] = 6 The total sum of squares is: SSTO = ^3\\sum_i=1 ^3\\sum_j=1 (Y_ij-Y..)^2 = ^3\\sum_i=1 ^3\\sum_j=1Y^2_ij - 9.Y^2.. = 1401 - 9.11^2 = 1401 - 1089 = 312. Thus, the sum of squares due to the error is SSE= SSTO - SSA - SSB = 312 - 6 - 294 = 12 . The ANOVA table (Analysis of Variance) Source of Variation Sum of Squares Degrees of Freedom Mean Squares Temperature 294 3 - 1 = 2 147 Salinity 6 3 - 1 = 2 3 Error 12 (9 -1) - 4 = 4 3 The program looks as follows: CPROGRAM FOR FACTORIAL DESIGN: TWO FACTORS CSUBPROGRAMS FOLLOW AFTER MAIN PROGRAM DIMENSION A(2\\O), B(2\\O), C(2\\O,2\\O), LA(2\\O), LB(2\\O) DIMENSION SN(2\\O,2\\O), SA(2\\O), AM(2\\O), SB(2\\O), BM(2\\O) DIMENSION CLM(2\\O,2\\O), KH(5), K1(4), K2(4), K3(4), 1N(2\\O,2\\O), KF(2\\O), D(1\\O,2\\O,5\\O) ND = 2\\O 99READ (2,1\\O\\O)KH, K1, K2, K3, K,L, ((N(I,J), J = 1,K), I = 1,L) WRITE (3,2\\O\\O)KH,K1,K2, K3, K,L, ((N(I,J), J = 1,K), I = 1,L) 1\\O\\OFORMAT (5A4, 3(4A4), 213/4\\OI2) 2\\O\\OFORMAT (\\textasteriskcentered1\\textasteriskcentered, 5A4, 3(4A4), 2I3/4\\OI2) READ (2,3\\O\\O) KF WRITE (3,3\\O\\O) KF 3\\O\\OFORMAT (2\\OA4) T = 0 XX = 0 NC = 0 DO 1\\O J = 1,L A(J) = 0 1\\OLA(J) = 0 DO 2\\O M = 1 ,K B(M) =0 LB(M) = 0 DO 3\\O J = 1,L DO 3\\O M = 1,K 3\\OC(J,M) = 0 DO 4\\O J = 1,L DO 4\\O M = 1,K NUM = N(J,M) DO 4\\O I = 1,NUM T = T + D(J,M,I) XX = XX + D(J,M, I) \\textasteriskcentered\\textasteriskcentered 2 B(M) = B(M) + D(J,M,I) A(J) = A(J) + D(J,M,I) 4\\OC(J,M) = C(J,M) + D(J,M,I) DO 5\\O I = 1,L DO 5\\O J = 1,K LA (I) = LA (I) + N(I, J) LB(J) = LB(J) + H(I,J) NC = NC + N(I, J) 5\\OSN(I,J) = N(I, J) AA = 0 BB = 0 CLL = 0 DO 6\\O I = 1,L SA(I) = LA (I) AM (I) = A(I)/SA(I) AA = AA + A (I) \\textasteriskcentered\\textasteriskcentered 2/SA(I) DO 6\\O J = 1,K CLM(I,J) = C(I,J)/SN(I,J) 6\\OCLL = CLL + C(I, J) \\textasteriskcentered\\textasteriskcentered 2/SN(I,J) DO 7\\O J = 1,K SB(J) = LB(J) BM(J) = B(J)/SB(J) 7\\OBB = BB + B(J) \\textasteriskcentered\\textasteriskcentered 2/SB(J) CCOMPUTE SS, DF, MS, F CCC = T \\textasteriskcentered\\textasteriskcentered 2/NC BETA = AA - CCC BETB = BB - CCC BETC = CLL - CCC AB = BETC - BETA - BETB TOT = XX - CCC ERR = TOT - BETC DT = NC - 1 DA = L - 1 DB = K - 1 DC = L \\textasteriskcentered K - 1 DAB = DA \\textasteriskcentered CB DER = DT - DC AMS = BETA/DA BMS = BETB/DB ABMS = AB/DAB ERMS = ERR/DER FA = AMS/ERUS FB = BMS/ERMS FAB = ABMS/ERMS PA = PRBF(CA,DER,FA) PB = PRBF(CAB,DER,FB) WRITE (3,4\\O\\O) KH, TOT, DT, K1, BETA, DA, AMS, FA, 1PA,K2,BETB, BMS, FB, PB,K3, AB, DAB, ABMS, FAB, PAB, 2ERR, DER, ERMS 4\\O\\OFORMAT CALL PRTS (AM, L, 1, 7H AMEANS, ND) CALL PRTS (BM, K, 1, 7H BMEANS, ND) CALL PRTS (CLM, L, K, 8H ABMEANS, ND) END SUBROUTINE PRTS (X,N,M,KH,ND) CPRINT A MATRIX OR VECTOR IN 1\\O-COLUMN PARTITIONS DIMENSION X(2\\O,2\\O) KH(2) IF (M.GT.1) GO TO 2\\O DO 1\\O I = 1,N,1\\O J = MINO (I + 9,N) WRITE (3,5) KH, (K,K = I,J) 5FORMAT (2A4, 1\\OI11) 1\\OWRITE (3,15) (X(K,1), K = I,J) 15FORMAT (119X, 1\\OF11.4) RETURN 2\\ODO 25 I = 1,N 25WRITE (3,3\\O) I, (x(I,J), J = K,L) 3\\OFORMAT (11 I6, 4X, 1\\OF 11.4) RETURN END"}, "question": "task_1"}}, {"data": {"text": "Question:\nFind the mistakes in the following FORTRAN expressions.\n\nOptions:\nA. Incorrect variable naming\nB. Undefined variables\nC.             No comments in the code\nD. Incorrect syntax, parenthesis and operator usage\n\nAnswer: D\n\nReference Solution:\na) In FORTRAN any constant or variable in an expression, unless it is the first constant or variable of that expression, must be preceded immediately by one of the following: a left parenthesis one of the operators +, -, {_\\ast},/, or {_\\ast}{_\\ast} . Any constant or variable in an expression, unless it is the last constant or variable of that expression, must be followed by one of the following: a right parenthesis one of the operatorsor +, -, {_\\ast},/, or {_\\ast}{_\\ast} . The number of opened and closed parenthesis must be equal. Therefore the correct expression is (A - (B - (C + D(4.7)))). b) For the same argument as was used in part (a), the correct expres-sions are (A/B) or (A)/(B). c) The Statement is incorrectly formed, and has no meaning. Except for the unary minus, each operator +, {_\\ast}, /, or {_\\ast}{_\\ast} must have a term or factor both to its left and to its right, in order for an expression to be correctly formed.", "ref_id": 4626, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Find the mistakes in the following FORTRAN expressions.", "options": ["Incorrect variable naming", "Undefined variables", "No comments in the code", "Incorrect syntax, parenthesis and operator usage"], "answer": "D", "solution": "a) In FORTRAN any constant or variable in an expression, unless it is the first constant or variable of that expression, must be preceded immediately by one of the following: a left parenthesis one of the operators +, -, {_\\ast},/, or {_\\ast}{_\\ast} . Any constant or variable in an expression, unless it is the last constant or variable of that expression, must be followed by one of the following: a right parenthesis one of the operatorsor +, -, {_\\ast},/, or {_\\ast}{_\\ast} . The number of opened and closed parenthesis must be equal. Therefore the correct expression is (A - (B - (C + D(4.7)))). b) For the same argument as was used in part (a), the correct expres-sions are (A/B) or (A)/(B). c) The Statement is incorrectly formed, and has no meaning. Except for the unary minus, each operator +, {_\\ast}, /, or {_\\ast}{_\\ast} must have a term or factor both to its left and to its right, in order for an expression to be correctly formed."}, "question": "task_1"}}, {"data": {"text": "Question:\nWhat is a One-to-One Assembler?\n\nOptions:\nA. A One-to-One assembler translates each machine word into multiple lines of an assembler language program\nB. A One-to-One assembler translates each line of an assembler language program into one machine word during assembly\nC.             A One-to-One assembler translates each line of an assembler language program into multiple machine words\nD. A One-to-One assembler translates each line of a machine word into an assembler language program\n\nAnswer: B\n\nReference Solution:\nOne to One Assembler: - The most direct approach to interpreting each line of an assembler language program is as one machine word during assembly. The assembler can be a one pass or two pass assembler. Often, when we hear the term one-to-one, the thought of correspondence comes to mind, in particular, one-to-one correspondence. This is also the case with the One-to-One Assembler; it makes a one-to-one correspondence. This correspondence stems from the fact that a One-to-One assembler translates each line of an assembler language program into one machine word during as-sembly. The translation is done on a sequential basis; an instruction is \"mapped\" into a machine word as it is en-countered, with the assembler making one or two passes over each instruction, depending on its type. The following is an example of how a One-to-One Assembler may do its trans-lation. The One-to-One Assembler is an example of one of the simplest assemblers. Actually, it forms the foundations on which most practical assemblers are built. For the assem-bler to translate assembly language into machine code the following rules must be observed: For naming locations: may be alphabetic or numeric in any desired mixture. Any other character, such as a comma, is illegal. No character of the name may be a blank. exactly once in the NAME field. be the start of the command field. similar to those of most assemblers. This is not surprising since the One-to-One Assembler forms the basis for most assemblers.", "ref_id": 4627, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "What is a One-to-One Assembler?", "options": ["A One-to-One assembler translates each machine word into multiple lines of an assembler language program", "A One-to-One assembler translates each line of an assembler language program into one machine word during assembly", "A One-to-One assembler translates each line of an assembler language program into multiple machine words", "A One-to-One assembler translates each line of a machine word into an assembler language program"], "answer": "B", "solution": "One to One Assembler: - The most direct approach to interpreting each line of an assembler language program is as one machine word during assembly. The assembler can be a one pass or two pass assembler. Often, when we hear the term one-to-one, the thought of correspondence comes to mind, in particular, one-to-one correspondence. This is also the case with the One-to-One Assembler; it makes a one-to-one correspondence. This correspondence stems from the fact that a One-to-One assembler translates each line of an assembler language program into one machine word during as-sembly. The translation is done on a sequential basis; an instruction is \"mapped\" into a machine word as it is en-countered, with the assembler making one or two passes over each instruction, depending on its type. The following is an example of how a One-to-One Assembler may do its trans-lation. The One-to-One Assembler is an example of one of the simplest assemblers. Actually, it forms the foundations on which most practical assemblers are built. For the assem-bler to translate assembly language into machine code the following rules must be observed: For naming locations: may be alphabetic or numeric in any desired mixture. Any other character, such as a comma, is illegal. No character of the name may be a blank. exactly once in the NAME field. be the start of the command field. similar to those of most assemblers. This is not surprising since the One-to-One Assembler forms the basis for most assemblers."}, "question": "task_1"}}, {"data": {"text": "Question:\nWhat is the maximum number of entries that can be stored in a binary tree if the longest path from the root to any node does not exceed N? Find the general equation for the aver-age search time for any entry in a tree with N levels.\n\nOptions:\nA. 2^N, N / (2^N)\nB. N^2 - 1, N + 1 - (N / (2^N - 1))\nC.             2^N - 1, N - 1 + (N / (2^N - 1))\nD. 2^N + 1, N / (2^N - 1) - 1\n\nAnswer: C\n\nReference Solution:\nIf the longest path is N, the tree will have N levels below the root node. At most, one node can be at the root, two nodes at the next level, four nodes at the next, etc. This expands geometrically, until the total number of nodes possible is 1 + 2 + 4 + . . . 2^N-1 = 2^N - 1 If we want to search the nodes for a particular entry, each time we descend to the next level, we must perform another comparison. For example, if we have 3 levels, the following distribution of search times is realized: 1 node takes 1 comparison 2 nodes take 2 comparisons 4 nodes take 3 comparisons The average over the seven nodes is given simply by multi-plying nodes by comparisons, taking the sum, and dividing by the total number of nodes. Hence, (1 \u00d7 1 + 2 \u00d7 2 + 4 \u00d7 3) / 7 = 2.43 We do not include the unit of time here, for it could bemilli-, micro-, or nanoseconds, according to the machine doing the comparisons. The general equation for N levels is given by N - 1 + (N / (2^N - 1))", "ref_id": 4628, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "What is the maximum number of entries that can be stored in a binary tree if the longest path from the root to any node does not exceed N? Find the general equation for the aver-age search time for any entry in a tree with N levels.", "options": ["2^N, N / (2^N)", "N^2 - 1, N + 1 - (N / (2^N - 1))", "2^N - 1, N - 1 + (N / (2^N - 1))", "2^N + 1, N / (2^N - 1) - 1"], "answer": "C", "solution": "If the longest path is N, the tree will have N levels below the root node. At most, one node can be at the root, two nodes at the next level, four nodes at the next, etc. This expands geometrically, until the total number of nodes possible is 1 + 2 + 4 + . . . 2^N-1 = 2^N - 1 If we want to search the nodes for a particular entry, each time we descend to the next level, we must perform another comparison. For example, if we have 3 levels, the following distribution of search times is realized: 1 node takes 1 comparison 2 nodes take 2 comparisons 4 nodes take 3 comparisons The average over the seven nodes is given simply by multi-plying nodes by comparisons, taking the sum, and dividing by the total number of nodes. Hence, (1 \u00d7 1 + 2 \u00d7 2 + 4 \u00d7 3) / 7 = 2.43 We do not include the unit of time here, for it could bemilli-, micro-, or nanoseconds, according to the machine doing the comparisons. The general equation for N levels is given by N - 1 + (N / (2^N - 1))"}, "question": "task_1"}}, {"data": {"text": "Question:\nConsider the following input containing information about the players of a soccer team: LAST NAMEBIRTHDATENO. GAMES PLAYEDGOALS SCORED Write a program which punches cards with the same information, but in form: LAST NAME;BIRTH DATE: NO; GAMES PLAYED;GOALS SCORED\n\nOptions:\nA. &ANCHOR = 1; &TRIM = 1 STRING = BREAK(' ') . CHARS SPAN(' ') NEXTCARD = INPUT: F(END) LOOPCARD STRING = CHARS ' , ': S(LOOP) PUNCH = CARD: (NEXT) END\nB. &ANCHOR = 1; &TRIM = 0 STRING = BREAK(' ') . CHARS SPAN(' ') NEXTCARD = INPUT: F(END) LOOPCARD STRING = CHARS ' ; ': S(LOOP) PUNCH = CARD: (NEXT) END\nC.             &ANCHOR = 1; &TRIM = 1 STRING = BREAK(' ') . CHARS SPAN(' ') NEXTCARD = INPUT: F(END) LOOPCARD STRING = CHARS ' ; ': S(LOOP) PUNCH = CARD: (NEXT) END\nD. &ANCHOR = 0; &TRIM = 1 STRING = BREAK(' ') . CHARS SPAN(' ') NEXTCARD = INPUT: F(END) LOOPCARD STRING = CHARS ' ; ': S(LOOP) PUNCH = CARD: (NEXT) END\n\nAnswer: C\n\nReference Solution:\n&ANCHOR = 1; &TRIM = 1 STRING = BREAK(' ') . CHARS SPAN(' ') NEXTCARD = INPUT: F(END) LOOPCARD STRING = CHARS ' ; ': S(LOOP) PUNCH = CARD: (NEXT) END The first line, &ANCHOR = 1; &TRIM = 1, introduces two new features of the SNOBOL IV language. First, it includes two separate statements. SNOBOL IV permits reordering of the several statements on one line, where each statement (except the last) ends with semicolon. Second, the first line introduces a new keyword &ANCH0R. If not otherwise specified, the initial value of &ANCH0R is zero, meaning that any pattern matching in that program will succeed whenever a pattern occurs anywhere in the subject. If the value of &ANCH0R is not zero, any pattern matching will succeed only if a pattern occurs in the beginning of the subject. Thus, in the previous problem, the two statements W0RD1LEN(1) . K K'K': F(START) could be replaced by &ANCH0R = 1 W0RD1'K': F(START) The second line includes BREAK and SPAN, the primitive functions whose values are pattern structures that match runs of characters. Patterns described by A RUN OF BLANKS, A STRING OF DIGITS, A WORD (RUN OF LETTERS) can be formed using SPAN as SPAN (' ') SPAN ('0123456789') SPAN ('ABCDEFGHIJKLMNOPQRSTUVWXYZ') respectively. Patterns described by i) Everything up to the next blank, ii) Everything up to the next punctuation mark, iii) Everything up to the next number, can be formed using BREAK as BREAK (' ') BREAK (',.;:.'?') BREAK ('+-0123456789') respectively. The pattern structure for SPAN matches the longest string that consists solely of characters, appearing in the argument. BREAK generates a pattern structure that matches the string up to, but not including, the break character in the argument. Thus, the second line of this program indicates that the variable STRING will be assigned a first matched string of characters up to a first blank (the same string will also be assigned to CHARS), concatenated with the run of blanks between it and the next string. The third line of the program reads in a first input card. The fourth line assigns the first string of the card up to a blank, concatenated with the run of blanks following it, to STRING and substitutes it by the same string, only now followed by a semicolon, rather than blanks. Then it takes the next string and run of blanks and does the same. The procedure repeats until all the strings on the card are substituted. Then the computer punches out the first card with the proper changes, goes back to the third line (labeled NEXT), reads in the next card, and performs the needed substitutions on it. The control exits from the loop and terminates the program when there are no more cards in the input. Considering the following input: PELE1938103530 the output will be: PELE; 1938; 10; 35; 30", "ref_id": 4629, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Consider the following input containing information about the players of a soccer team: LAST NAMEBIRTHDATENO. GAMES PLAYEDGOALS SCORED Write a program which punches cards with the same information, but in form: LAST NAME;BIRTH DATE: NO; GAMES PLAYED;GOALS SCORED", "options": ["&ANCHOR = 1; &TRIM = 1 STRING = BREAK(' ') . CHARS SPAN(' ') NEXTCARD = INPUT: F(END) LOOPCARD STRING = CHARS ' , ': S(LOOP) PUNCH = CARD: (NEXT) END", "&ANCHOR = 1; &TRIM = 0 STRING = BREAK(' ') . CHARS SPAN(' ') NEXTCARD = INPUT: F(END) LOOPCARD STRING = CHARS ' ; ': S(LOOP) PUNCH = CARD: (NEXT) END", "&ANCHOR = 1; &TRIM = 1 STRING = BREAK(' ') . CHARS SPAN(' ') NEXTCARD = INPUT: F(END) LOOPCARD STRING = CHARS ' ; ': S(LOOP) PUNCH = CARD: (NEXT) END", "&ANCHOR = 0; &TRIM = 1 STRING = BREAK(' ') . CHARS SPAN(' ') NEXTCARD = INPUT: F(END) LOOPCARD STRING = CHARS ' ; ': S(LOOP) PUNCH = CARD: (NEXT) END"], "answer": "C", "solution": "&ANCHOR = 1; &TRIM = 1 STRING = BREAK(' ') . CHARS SPAN(' ') NEXTCARD = INPUT: F(END) LOOPCARD STRING = CHARS ' ; ': S(LOOP) PUNCH = CARD: (NEXT) END The first line, &ANCHOR = 1; &TRIM = 1, introduces two new features of the SNOBOL IV language. First, it includes two separate statements. SNOBOL IV permits reordering of the several statements on one line, where each statement (except the last) ends with semicolon. Second, the first line introduces a new keyword &ANCH0R. If not otherwise specified, the initial value of &ANCH0R is zero, meaning that any pattern matching in that program will succeed whenever a pattern occurs anywhere in the subject. If the value of &ANCH0R is not zero, any pattern matching will succeed only if a pattern occurs in the beginning of the subject. Thus, in the previous problem, the two statements W0RD1LEN(1) . K K'K': F(START) could be replaced by &ANCH0R = 1 W0RD1'K': F(START) The second line includes BREAK and SPAN, the primitive functions whose values are pattern structures that match runs of characters. Patterns described by A RUN OF BLANKS, A STRING OF DIGITS, A WORD (RUN OF LETTERS) can be formed using SPAN as SPAN (' ') SPAN ('0123456789') SPAN ('ABCDEFGHIJKLMNOPQRSTUVWXYZ') respectively. Patterns described by i) Everything up to the next blank, ii) Everything up to the next punctuation mark, iii) Everything up to the next number, can be formed using BREAK as BREAK (' ') BREAK (',.;:.'?') BREAK ('+-0123456789') respectively. The pattern structure for SPAN matches the longest string that consists solely of characters, appearing in the argument. BREAK generates a pattern structure that matches the string up to, but not including, the break character in the argument. Thus, the second line of this program indicates that the variable STRING will be assigned a first matched string of characters up to a first blank (the same string will also be assigned to CHARS), concatenated with the run of blanks between it and the next string. The third line of the program reads in a first input card. The fourth line assigns the first string of the card up to a blank, concatenated with the run of blanks following it, to STRING and substitutes it by the same string, only now followed by a semicolon, rather than blanks. Then it takes the next string and run of blanks and does the same. The procedure repeats until all the strings on the card are substituted. Then the computer punches out the first card with the proper changes, goes back to the third line (labeled NEXT), reads in the next card, and performs the needed substitutions on it. The control exits from the loop and terminates the program when there are no more cards in the input. Considering the following input: PELE1938103530 the output will be: PELE; 1938; 10; 35; 30"}, "question": "task_1"}}, {"data": {"text": "Question:\nA recursive function is the one which uses itself in the body of its definition. Use APL to write anonrecursiveand a recursive function for computing the factorial of a number.\n\nOptions:\nA. A nonrecursive function uses recursion to solve the problem, while a recursive function does not\nB. A nonrecursive function cannot solve the factorial problem, only a recursive function can\nC.             A nonrecursive function for computing the factorial uses a loop to multiply the numbers from 1 to n, while a recursive function uses a base case where the factorial of 0 is 1 and for other numbers, it multiplies the number with the factorial of the number minus one.\nD. Both nonrecursive and recursive functions solve the problem without using loops\n\nAnswer: C\n\nReference Solution:\nUsing the most commonly used mathematical convention, the factorial function is written as n!, where n is a non-negative integer, n! is defined as follows: \\mid1,if n = 0 n! =\\midn \u00d7 (n-1) \u00d7 (n-2) \u00d7 ..... \u00d7 2 \u00d7 1,if n \\not = 0 Anonrecursivefunction for computing the factorial is as follows: \\nablaZ \\leftarrow FAC J\\mid [1]Z \\leftarrow I \\leftarrow 1\\mid [2]\\rightarrow (I \\geq J) / 6\\mid [3]I \\leftarrow I + 1\\mid(1) [4]Z \\leftarrow Z \u00d7 I\\mid [5]\\rightarrow 2\\mid [6]Z\\mid \\nabla\\mid An explicit result function was used above to compute factorials nonrecursively . [1] initializes both Z and I to the value 1. If the value of I is greater than or equal to the value of J, then Z is already the value of J! and the program branches to statement [6]. In statement [6], the value of Z which is computed is printed out. The program then halts. But, if the value of I is smaller than J, the condition-al branching does not take place. The program then sequences to statement [3]. In statement [3], the value of I is incre-mented by 1. Statement [4] replaces the value of Z with Z \u00d7 I. Then statement [5] sends the program back to state-ment [2] to repeat the comparison of I and J. This process is continued until the value of I is greater than or equal to the value of J; J! is then Z. A jump is made to state-ment [6] , the value of Z is printed out, and the program ends. A recursive function for computing the factorial is as follows: \\nablaZ \\leftarrow REFAC J\\mid [1]\\rightarrow (J = 0) / GO\\mid [2]Z \\leftarrow J \u00d7 REFAC J-1\\mid(2) [3]\\rightarrow 0\\mid [4]GO: Z \\leftarrow 1\\mid \\nabla\\mid Again, an explicit result function was used. In [1], if J=0 the program goes to the statementlabelledGO. Here, the value of Z is made equal to 1. The program ends. Thus, the program obtains the value of 0! equal to 1. Note that the program does not ask for the value of Z to be printed out. The value of Z is just stored in memory for future use when required by the programmer. If J \\not = O, then step [2] indicates how J! is computed recursively. Notice how the REFAC function calls itself in step [2].", "ref_id": 4630, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "A recursive function is the one which uses itself in the body of its definition. Use APL to write anonrecursiveand a recursive function for computing the factorial of a number.", "options": ["A nonrecursive function uses recursion to solve the problem, while a recursive function does not", "A nonrecursive function cannot solve the factorial problem, only a recursive function can", "A nonrecursive function for computing the factorial uses a loop to multiply the numbers from 1 to n, while a recursive function uses a base case where the factorial of 0 is 1 and for other numbers, it multiplies the number with the factorial of the number minus one.", "Both nonrecursive and recursive functions solve the problem without using loops"], "answer": "C", "solution": "Using the most commonly used mathematical convention, the factorial function is written as n!, where n is a non-negative integer, n! is defined as follows: \\mid1,if n = 0 n! =\\midn \u00d7 (n-1) \u00d7 (n-2) \u00d7 ..... \u00d7 2 \u00d7 1,if n \\not = 0 Anonrecursivefunction for computing the factorial is as follows: \\nablaZ \\leftarrow FAC J\\mid [1]Z \\leftarrow I \\leftarrow 1\\mid [2]\\rightarrow (I \\geq J) / 6\\mid [3]I \\leftarrow I + 1\\mid(1) [4]Z \\leftarrow Z \u00d7 I\\mid [5]\\rightarrow 2\\mid [6]Z\\mid \\nabla\\mid An explicit result function was used above to compute factorials nonrecursively . [1] initializes both Z and I to the value 1. If the value of I is greater than or equal to the value of J, then Z is already the value of J! and the program branches to statement [6]. In statement [6], the value of Z which is computed is printed out. The program then halts. But, if the value of I is smaller than J, the condition-al branching does not take place. The program then sequences to statement [3]. In statement [3], the value of I is incre-mented by 1. Statement [4] replaces the value of Z with Z \u00d7 I. Then statement [5] sends the program back to state-ment [2] to repeat the comparison of I and J. This process is continued until the value of I is greater than or equal to the value of J; J! is then Z. A jump is made to state-ment [6] , the value of Z is printed out, and the program ends. A recursive function for computing the factorial is as follows: \\nablaZ \\leftarrow REFAC J\\mid [1]\\rightarrow (J = 0) / GO\\mid [2]Z \\leftarrow J \u00d7 REFAC J-1\\mid(2) [3]\\rightarrow 0\\mid [4]GO: Z \\leftarrow 1\\mid \\nabla\\mid Again, an explicit result function was used. In [1], if J=0 the program goes to the statementlabelledGO. Here, the value of Z is made equal to 1. The program ends. Thus, the program obtains the value of 0! equal to 1. Note that the program does not ask for the value of Z to be printed out. The value of Z is just stored in memory for future use when required by the programmer. If J \\not = O, then step [2] indicates how J! is computed recursively. Notice how the REFAC function calls itself in step [2]."}, "question": "task_1"}}, {"data": {"text": "Question:\nV \\leftarrow 3 4 2 -1. Find the result of the following operations.\n\nOptions:\nA. Absolute value of V is 3 4 2 -1, max value is 4, min value is 1\nB. Absolute value of V is 3 4 2 1, max value is 4, min value is -1\nC.             Absolute value of V is 3 4 2 1, max value is 3, min value is 1\nD. Absolute value of V is -3 -4 -2 -1, max value is -1, min value is -4\n\nAnswer: B\n\nReference Solution:\na) The symbol \\vert, when written as a monadic function, as \\vertV, specifies the absolute value of V. V is a vector, which consists of the elements 3 4 2 -1. The absolute value of V is 3 4 2 1 i.e., \\vertV is equal to 3 4 2 1. b) The symbol \\Gamma represents a maximum function. When used with the Reduction Operator /, the maximum function selects the largest from among all the elements of the vec-tor, V in this case. Thus, if V consists of 3 4 2 -1, then \\Gamma/V is equivalent to the following: 3\\Gamma4\\Gamma2\\Gamma - 1 i.e.,3\\Gamma4\\Gamma2 i.e.,3\\Gamma4 i.e.,4 In the above, using the right to left rule of APL for eval-uating an expression, the elements of V are compared two by two from the right. The maximum is selected at each com-parison. Thus, finally when the whole string has been checked out, the largest element is obtained. c) The symbol L represents a minimum function. When used with the Reduction Operator / , the minimum function selects the least from among all the elements of the vec-tor (V in this case). Thus, if V consists of 3 4 2 -1, then L/V is equivalent to the following: 3L4L2L - 1 i.e.,3L4L-1 i.e.,3L-1 i.e.,-1 In the above, using the right to left rule, the elements of V are compared two by two, and the minimum is selected.", "ref_id": 4631, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "V \\leftarrow 3 4 2 -1. Find the result of the following operations.", "options": ["Absolute value of V is 3 4 2 -1, max value is 4, min value is 1", "Absolute value of V is 3 4 2 1, max value is 4, min value is -1", "Absolute value of V is 3 4 2 1, max value is 3, min value is 1", "Absolute value of V is -3 -4 -2 -1, max value is -1, min value is -4"], "answer": "B", "solution": "a) The symbol \\vert, when written as a monadic function, as \\vertV, specifies the absolute value of V. V is a vector, which consists of the elements 3 4 2 -1. The absolute value of V is 3 4 2 1 i.e., \\vertV is equal to 3 4 2 1. b) The symbol \\Gamma represents a maximum function. When used with the Reduction Operator /, the maximum function selects the largest from among all the elements of the vec-tor, V in this case. Thus, if V consists of 3 4 2 -1, then \\Gamma/V is equivalent to the following: 3\\Gamma4\\Gamma2\\Gamma - 1 i.e.,3\\Gamma4\\Gamma2 i.e.,3\\Gamma4 i.e.,4 In the above, using the right to left rule of APL for eval-uating an expression, the elements of V are compared two by two from the right. The maximum is selected at each com-parison. Thus, finally when the whole string has been checked out, the largest element is obtained. c) The symbol L represents a minimum function. When used with the Reduction Operator / , the minimum function selects the least from among all the elements of the vec-tor (V in this case). Thus, if V consists of 3 4 2 -1, then L/V is equivalent to the following: 3L4L2L - 1 i.e.,3L4L-1 i.e.,3L-1 i.e.,-1 In the above, using the right to left rule, the elements of V are compared two by two, and the minimum is selected."}, "question": "task_1"}}, {"data": {"text": "Question:\nGive a list of the character set used inPL/I. Also define the term'variable', and explain what is meant by an 'assign-ment statement'.\n\nOptions:\nA. 60 different characters, variable can vary, assignment statement assigns a value to a variable\nB. 50 different characters, variable can't vary, assignment statement assigns a variable to a function\nC.             80 different characters, variable is a function, assignment statement assigns a function to a variable\nD. 70 different characters, variable is constant, assignment statement assigns a variable to a value\n\nAnswer: A\n\nReference Solution:\nAltogether, 60 different characters constitute the PL/I character set, allor only some of them may appear in a specific PL/I program. In PL/I thereis a choice of the 26 capital letters A through Z, the 10 digits 0 through9, and also 24 special characters. The graphics and names by whichthese 24 special characters are represented are as follows: =Equal or assignment symbol +Plus symbol -Minussymbol \\textasteriskcenteredAsterikor multiply symbol /Slash or divide symbol (Left parenthesis symbol :Colon symbol \\lnotNOT symbol &AND symbol \\vertOR symbol >Greater than symbol <Less than symbol )Right parenthesis symbol ,Comma symbol .Period or decimal point symbol 'Quotation mark symbol %Percent symbol ;Semicolon symbol -Break character symbol ?Question mark symbol $Currency symbol @\"at\" symbol #Number sign symbol bBlank (space, no graphic) Recognition of a blank character is important. The blank character hasno graphic representation; it represents spacing. Often one wrongly considersthe blank character as an unessential character for a language. But consider the following: THESEATHADANICECOVER The above statement, without blanks, could either mean: The seat had a nice cover,or, The seat had an ice cover. Hence, it can be seen that blanks are very important, in a language. To understand what is meant by 'assignment statements' take a simpleexample as follows: X = A + B; The semicolon indicates to the PL/I machine the end of an in-struction. The symbolhas the function of a directed equality sign. It states that the quantityon the left-hand side is defined by the formula on the right-hand side. Or, more precisely, the value created by addition of the two variables onthe right-hand side is taken on by the variable X on the left-hand side. One can say that the newly calcula-ted value (i.e. sum of A & B) is \"assigned\" to the variable X. The complete structure is called 'assignment statement.' It is necessary that the variables A and B, at the instant of calculation, have well defined values. This is not neces-sary for X on the left-handside. If X does not appear in any previous statements its value willbe undefined before execution of the assignment statement. After execution, the value of X will be equal to the sum of the values of A & B. If thereis any previous assignment, say X = 5, before X = A + B, the effect ofthe assignment statement is as follows: Any previous value of X is lost; anew value of X is defined; the old value is replaced by the new value. We have used the term 'variable' for A, B and X while explaining theterm 'assignment statement'. The term 'vari-able' is used to indicate thata value attached to the quan-tity may \"vary\" during the calculations performedby the PL/I machine.", "ref_id": 4632, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Give a list of the character set used inPL/I. Also define the term'variable', and explain what is meant by an 'assign-ment statement'.", "options": ["60 different characters, variable can vary, assignment statement assigns a value to a variable", "50 different characters, variable can't vary, assignment statement assigns a variable to a function", "80 different characters, variable is a function, assignment statement assigns a function to a variable", "70 different characters, variable is constant, assignment statement assigns a variable to a value"], "answer": "A", "solution": "Altogether, 60 different characters constitute the PL/I character set, allor only some of them may appear in a specific PL/I program. In PL/I thereis a choice of the 26 capital letters A through Z, the 10 digits 0 through9, and also 24 special characters. The graphics and names by whichthese 24 special characters are represented are as follows: =Equal or assignment symbol +Plus symbol -Minussymbol \\textasteriskcenteredAsterikor multiply symbol /Slash or divide symbol (Left parenthesis symbol :Colon symbol \\lnotNOT symbol &AND symbol \\vertOR symbol >Greater than symbol <Less than symbol )Right parenthesis symbol ,Comma symbol .Period or decimal point symbol 'Quotation mark symbol %Percent symbol ;Semicolon symbol -Break character symbol ?Question mark symbol $Currency symbol @\"at\" symbol #Number sign symbol bBlank (space, no graphic) Recognition of a blank character is important. The blank character hasno graphic representation; it represents spacing. Often one wrongly considersthe blank character as an unessential character for a language. But consider the following: THESEATHADANICECOVER The above statement, without blanks, could either mean: The seat had a nice cover,or, The seat had an ice cover. Hence, it can be seen that blanks are very important, in a language. To understand what is meant by 'assignment statements' take a simpleexample as follows: X = A + B; The semicolon indicates to the PL/I machine the end of an in-struction. The symbolhas the function of a directed equality sign. It states that the quantityon the left-hand side is defined by the formula on the right-hand side. Or, more precisely, the value created by addition of the two variables onthe right-hand side is taken on by the variable X on the left-hand side. One can say that the newly calcula-ted value (i.e. sum of A & B) is \"assigned\" to the variable X. The complete structure is called 'assignment statement.' It is necessary that the variables A and B, at the instant of calculation, have well defined values. This is not neces-sary for X on the left-handside. If X does not appear in any previous statements its value willbe undefined before execution of the assignment statement. After execution, the value of X will be equal to the sum of the values of A & B. If thereis any previous assignment, say X = 5, before X = A + B, the effect ofthe assignment statement is as follows: Any previous value of X is lost; anew value of X is defined; the old value is replaced by the new value. We have used the term 'variable' for A, B and X while explaining theterm 'assignment statement'. The term 'vari-able' is used to indicate thata value attached to the quan-tity may \"vary\" during the calculations performedby the PL/I machine."}, "question": "task_1"}}, {"data": {"text": "Question:\nWhat is modular programming?Name the six functional Name the six functional modulesof a structured program.\n\nOptions:\nA. The six functional modules of a structured program are: 1) INPUT, 2) INPUT DATA VALIDATION, 3) PROCESSING, 4) OUTPUT, 5) ERROR SPECIFICATION, 6) CLOSING\nB. 1) DATA ENTRY, 2) VALIDATION, 3) OPERATION, 4) RESULT, 5) ERROR DETECTION, 6) TERMINATION\nC.             1) INPUT, 2) DATA VERIFICATION, 3) CALCULATION, 4) DISPLAY, 5) ERROR DIAGNOSIS, 6) EXIT\nD. 1) READING, 2) DATA CHECKING, 3) PROCESSING, 4) OUTPUT, 5) ERROR HANDLING, 6) FINALIZING\n\nAnswer: A\n\nReference Solution:\nModular programming is a term which describes a disciplined meansof writing computer programs. By writing program segments which performspecific tasks, you will find that it is easier to debug your program. This concept is a step to take some of the \"art\" out of computer programmingand to replace It with more logical, intelligent, and efficient techniques. There are six types of modules needed in almost every type of program. The table below gives an overview of these modules. FUNCTIONAL MODULE DESCRIPTION 1) INPUT Performs the input of data necessary to accomplish the task 2) INPUT DATA VALIDATION Checks the validity of the incoming data and diagnoses what type of error if any, has occurred 3) PROCESSING Completes the basic task requested of the algorithm 4) OUTPUT Performs output of information needed by the user 5) ERROR SPECIFICATION Analyzes problematical points in the execution of the program and takes appropriate action 6) CLOSING Finalizes program execution The above modules should stand alone in their meaning. That is, If definedthoroughly enough, the module should be readily adaptable to anotherprogram with only minor changes in variable names. In addition, eachmodule should have only one point of entry and one point of exit. Multiple returns and branches, if used excessively, tend to bewilder the readerof your program. The term robustness is used in programming to mean the degree of completenessa program offers. A robust algorithm takes care of almost all possibilitieswith swift and precise action. The idea of modular programming, if followed carefully, yields robustness.", "ref_id": 4633, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "What is modular programming?Name the six functional Name the six functional modulesof a structured program.", "options": ["The six functional modules of a structured program are: 1) INPUT, 2) INPUT DATA VALIDATION, 3) PROCESSING, 4) OUTPUT, 5) ERROR SPECIFICATION, 6) CLOSING", "1) DATA ENTRY, 2) VALIDATION, 3) OPERATION, 4) RESULT, 5) ERROR DETECTION, 6) TERMINATION", "1) INPUT, 2) DATA VERIFICATION, 3) CALCULATION, 4) DISPLAY, 5) ERROR DIAGNOSIS, 6) EXIT", "1) READING, 2) DATA CHECKING, 3) PROCESSING, 4) OUTPUT, 5) ERROR HANDLING, 6) FINALIZING"], "answer": "A", "solution": "Modular programming is a term which describes a disciplined meansof writing computer programs. By writing program segments which performspecific tasks, you will find that it is easier to debug your program. This concept is a step to take some of the \"art\" out of computer programmingand to replace It with more logical, intelligent, and efficient techniques. There are six types of modules needed in almost every type of program. The table below gives an overview of these modules. FUNCTIONAL MODULE DESCRIPTION 1) INPUT Performs the input of data necessary to accomplish the task 2) INPUT DATA VALIDATION Checks the validity of the incoming data and diagnoses what type of error if any, has occurred 3) PROCESSING Completes the basic task requested of the algorithm 4) OUTPUT Performs output of information needed by the user 5) ERROR SPECIFICATION Analyzes problematical points in the execution of the program and takes appropriate action 6) CLOSING Finalizes program execution The above modules should stand alone in their meaning. That is, If definedthoroughly enough, the module should be readily adaptable to anotherprogram with only minor changes in variable names. In addition, eachmodule should have only one point of entry and one point of exit. Multiple returns and branches, if used excessively, tend to bewilder the readerof your program. The term robustness is used in programming to mean the degree of completenessa program offers. A robust algorithm takes care of almost all possibilitieswith swift and precise action. The idea of modular programming, if followed carefully, yields robustness."}, "question": "task_1"}}, {"data": {"text": "Question:\nLet the label for an assembly language statementbegin in column 1 and consist of at most eight characters, the first of which is a letter followed by letters or digits. The label is followed by at least one blank. A statement without a label begins with a blank. Write a program that reads in assembly language statements and prints those statements with invalid labels.\n\nOptions:\nA. LETTER = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' DIGIT ='0123456789' LABEL = ''\\vert ANY(LETTER) (SPAN(LETTER DIGIT)@N \\textasteriskcenteredLE(N,6) +\\vertNULL) '' \\vert &NCHOR = 1 RCARD = INPUT:F(END) CARDLABEL:S(R) OUTPUT = CARD:(R) END\nB. LETTER = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' DIGIT ='0123456789' LABEL = ''\\vert ANY(LETTER) (SPAN(LETTER DIGIT)@N \\textasteriskcenteredLE(N,10) +\\vertNULL) '' \\vert &NCHOR = 1 RCARD = INPUT:F(END) CARDLABEL:S(R) OUTPUT = CARD:(R) END\nC.             LETTER = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' DIGIT ='0123456789' LABEL = ''\\vert ANY(LETTER) (SPAN(LETTER DIGIT)@N \\textasteriskcenteredLE(N,8) '' \\vert &NCHOR = 1 RCARD = INPUT:F(END) CARDLABEL:S(R) OUTPUT = CARD:(R) END\nD. LETTER = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' DIGIT ='0123456789' LABEL = ''\\vert ANY(LETTER) (SPAN(LETTER DIGIT)@N \\textasteriskcenteredLE(N,8) +\\vertNULL) '' \\vert &NCHOR = 1 RCARD = INPUT:F(END) CARDLABEL:S(R) OUTPUT = CARD:(R) END\n\nAnswer: D\n\nReference Solution:\nLETTER = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' DIGIT ='0123456789' LABEL = ''\\vert ANY(LETTER) (SPAN(LETTER DIGIT)@N \\textasteriskcenteredLE(N,8) +\\vertNULL) '' \\vert &NCHOR = 1 RCARD = INPUT:F(END) CARDLABEL:S(R) OUTPUT = CARD:(R) END The first two statements are regular assignment statements, assigning the string of letters to LETTER and a string of digits to DIGIT. The third assignment statement contains alternation - the expression where different patterns are separated by symbol \\vert (with at least one blank on each side). The value of the expression is a pattern structure that matches any string specified by any of the alternative patterns. The first alternative pattern in the third statement is ''- a regular blank, while the second pattern includes a few new features. The first of them is a primitive function ANY. ANY and the opposite function NOTANY are primitive functions whose values are pattern structures that match single characters. ANY matches any character appearing in its argument, following the function in parentheses. NOTANY matches any character not appearing in its argument. Thus the pattern structure ANY (LETTER) matches any letter of the alphabet (the structure ANY('ABCD...XYZ') would have the same meaning). How ANY LETTER then concatenates with another alternative structure needs a detailed explanation. The SPAN function returns a matched run of characters, included in concatenated strings LETTER and DIGIT (any other character met with indicates the end of the run). Matching a pattern structure against a subject string, in SNOBOL IV, is done by a procedure called the SCANNER. The scanner has a pointer (control) called the CURSOR which is positioned to the left of the character that the scanner must match. As the scanner matches one by one the characters of the string, the cursor correspondingly moves to the right. These concepts are important in understanding the function of the next variable of the second alternative structure in line 3 - @N. The unary operator @ is called the cursor position operator. At any moment of the pattern matching process, it assigns an integer, representing the cursor position at that moment, to a variable following it (in our case, N). For example, in statement 'EXAMPLE' @JUNK 'L' The cursor, at first, is located to the left of E. No match occurs; the value 1 is assigned to the variable JUNK, and the cursor moves to X. The process goes on until the cursor hits L. By that time JUNK has the value of 5. Letter L matches, execution goes to the next statement, and variable JUNK is stored with value 5. Thus, in our problem, N indicates the position of the cursor after the scanner matched all characters of the first string on the card up to the first blank. In other words, N counts the number of characters in the label. Next comes the comparison of N. The unary operator \\textasteriskcentered (asterisk) postpones the evaluation of its operand. Thus, LE(N,8) is an unevaluated expression until it appears as part of a pattern LABEL in statement 6. This way the expression is evaluated only when needed. An alternative expression for concatenation in the second part of statement 3 is a string NULL which, in SNOBOL IV indicates a string of length zero. It is different from the strings 'O' and '', each of which has a length one. The NULL string consists of no characters, no blanks, no length. A blank finishes the pattern. It is now possible to follow through the function of the pattern LABEL in the sixth statement. If the statement on the input card starts with a blank, the pattern matches at once, and the execution returns to the previous statement CARD = INPUT :F(END), reading in the next card. If, however, the statement on the card starts with a letter, the characters following that letter are examined. All the characters (including the initial letter) are counted up to the first blank (specified in pattern LABEL by the blank at the end). Also all those characters have to belong either to LETTER or to DIGIT. If, in fact, the cursor hits a symbol which belongs to neither of those two strings, the matching fails, and the card is printed out as having an invalid label. Meanwhile, the integer produced by the counting procedure is assigned to N. If all the characters are legitimate, N is compared with 8. If N appears to be less than or equal to 8, the match succeeds, and the next card is considered. In case N is greater than 8, the match fails, and the card is printed out. If the first letter is followed by no other characters (NULL string), just a blank, the match succeeds, and the next card is considered. The program terminates after consideration of the last card.", "ref_id": 4634, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Let the label for an assembly language statementbegin in column 1 and consist of at most eight characters, the first of which is a letter followed by letters or digits. The label is followed by at least one blank. A statement without a label begins with a blank. Write a program that reads in assembly language statements and prints those statements with invalid labels.", "options": ["LETTER = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' DIGIT ='0123456789' LABEL = ''\\vert ANY(LETTER) (SPAN(LETTER DIGIT)@N \\textasteriskcenteredLE(N,6) +\\vertNULL) '' \\vert &NCHOR = 1 RCARD = INPUT:F(END) CARDLABEL:S(R) OUTPUT = CARD:(R) END", "LETTER = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' DIGIT ='0123456789' LABEL = ''\\vert ANY(LETTER) (SPAN(LETTER DIGIT)@N \\textasteriskcenteredLE(N,10) +\\vertNULL) '' \\vert &NCHOR = 1 RCARD = INPUT:F(END) CARDLABEL:S(R) OUTPUT = CARD:(R) END", "LETTER = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' DIGIT ='0123456789' LABEL = ''\\vert ANY(LETTER) (SPAN(LETTER DIGIT)@N \\textasteriskcenteredLE(N,8) '' \\vert &NCHOR = 1 RCARD = INPUT:F(END) CARDLABEL:S(R) OUTPUT = CARD:(R) END", "LETTER = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' DIGIT ='0123456789' LABEL = ''\\vert ANY(LETTER) (SPAN(LETTER DIGIT)@N \\textasteriskcenteredLE(N,8) +\\vertNULL) '' \\vert &NCHOR = 1 RCARD = INPUT:F(END) CARDLABEL:S(R) OUTPUT = CARD:(R) END"], "answer": "D", "solution": "LETTER = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' DIGIT ='0123456789' LABEL = ''\\vert ANY(LETTER) (SPAN(LETTER DIGIT)@N \\textasteriskcenteredLE(N,8) +\\vertNULL) '' \\vert &NCHOR = 1 RCARD = INPUT:F(END) CARDLABEL:S(R) OUTPUT = CARD:(R) END The first two statements are regular assignment statements, assigning the string of letters to LETTER and a string of digits to DIGIT. The third assignment statement contains alternation - the expression where different patterns are separated by symbol \\vert (with at least one blank on each side). The value of the expression is a pattern structure that matches any string specified by any of the alternative patterns. The first alternative pattern in the third statement is ''- a regular blank, while the second pattern includes a few new features. The first of them is a primitive function ANY. ANY and the opposite function NOTANY are primitive functions whose values are pattern structures that match single characters. ANY matches any character appearing in its argument, following the function in parentheses. NOTANY matches any character not appearing in its argument. Thus the pattern structure ANY (LETTER) matches any letter of the alphabet (the structure ANY('ABCD...XYZ') would have the same meaning). How ANY LETTER then concatenates with another alternative structure needs a detailed explanation. The SPAN function returns a matched run of characters, included in concatenated strings LETTER and DIGIT (any other character met with indicates the end of the run). Matching a pattern structure against a subject string, in SNOBOL IV, is done by a procedure called the SCANNER. The scanner has a pointer (control) called the CURSOR which is positioned to the left of the character that the scanner must match. As the scanner matches one by one the characters of the string, the cursor correspondingly moves to the right. These concepts are important in understanding the function of the next variable of the second alternative structure in line 3 - @N. The unary operator @ is called the cursor position operator. At any moment of the pattern matching process, it assigns an integer, representing the cursor position at that moment, to a variable following it (in our case, N). For example, in statement 'EXAMPLE' @JUNK 'L' The cursor, at first, is located to the left of E. No match occurs; the value 1 is assigned to the variable JUNK, and the cursor moves to X. The process goes on until the cursor hits L. By that time JUNK has the value of 5. Letter L matches, execution goes to the next statement, and variable JUNK is stored with value 5. Thus, in our problem, N indicates the position of the cursor after the scanner matched all characters of the first string on the card up to the first blank. In other words, N counts the number of characters in the label. Next comes the comparison of N. The unary operator \\textasteriskcentered (asterisk) postpones the evaluation of its operand. Thus, LE(N,8) is an unevaluated expression until it appears as part of a pattern LABEL in statement 6. This way the expression is evaluated only when needed. An alternative expression for concatenation in the second part of statement 3 is a string NULL which, in SNOBOL IV indicates a string of length zero. It is different from the strings 'O' and '', each of which has a length one. The NULL string consists of no characters, no blanks, no length. A blank finishes the pattern. It is now possible to follow through the function of the pattern LABEL in the sixth statement. If the statement on the input card starts with a blank, the pattern matches at once, and the execution returns to the previous statement CARD = INPUT :F(END), reading in the next card. If, however, the statement on the card starts with a letter, the characters following that letter are examined. All the characters (including the initial letter) are counted up to the first blank (specified in pattern LABEL by the blank at the end). Also all those characters have to belong either to LETTER or to DIGIT. If, in fact, the cursor hits a symbol which belongs to neither of those two strings, the matching fails, and the card is printed out as having an invalid label. Meanwhile, the integer produced by the counting procedure is assigned to N. If all the characters are legitimate, N is compared with 8. If N appears to be less than or equal to 8, the match succeeds, and the next card is considered. In case N is greater than 8, the match fails, and the card is printed out. If the first letter is followed by no other characters (NULL string), just a blank, the match succeeds, and the next card is considered. The program terminates after consideration of the last card."}, "question": "task_1"}}, {"data": {"text": "Question:\nFind all integers less than 50,000 that equal to the sum of the factorials of their digits. Write a computer program to solve this problem.\n\nOptions:\nA. 1, 2, 145, 40586\nB. 1, 2, 145 and 40585\nC.             1, 2, 145, 765\nD. 1, 2, 144, 40585\n\nAnswer: B\n\nReference Solution:\nTo gain a better understanding of the problem, consider the following examples: 1) The number 7666 is not equal to the sum of its factorial digits since 7! + 6! + 6! + 6! = 5040 + 720 + 720 + 720 = 7200 \\not = 7666. 2) Let n = 145. Then 1! + 4! + 5! = 1 + 24 + 120 = 145. Hence 145 is equal to the sum of the factorials of its digits. In the writing of the program, first store the value of n! up to 9! in the memory. Then store each digit of the given number in a location cell. Actually there are only 4 numbers that satisfy the above property: 1,2,145 and 40585. But this is a problem in programming as well as number theory; so, on with the program. 5DIM D(4), F(9) 10MAT D = ZER REMEACH DIGIT OF N (5 DIGITS FOR EVERY NUMBER) REMIS STORED IN D(J). BEGIN WITH 00001. 15LET D(4) = 1 REMNOW STORE FACTORIAL VALUES. 20LET F(0) = 1 25LET F(1) = 1 30LET F(2) = 2 35LET F(3) = 6 40LET F(4) = 24 45LET F(5) = 120 50LET F(6) = 720 55LET F(7) = 5040 60LET F(8) = 40320 65LET F(9) = 362,880 70PRINT \"NUMBER IS\", \" \" , \" SUM OF FACTORIALS OF ITS DIGITS IS\" 75PRINT REMNOW ADD UP THE DIGITS IN EACH REMD(J), MULTIPLYING BY CORRESPONDING POWERS OF TEN FOR REMINCREASING J. 80LET S = D(4) + 10\\textasteriskcentered D(3) + 100\\textasteriskcentered D(2) + 1000\\textasteriskcentered D(1) + 10000\\textasteriskcentered D(0) 85LET S1 = 0 90LET W = 0 95FOR J = 0 TO 4 100IF W < > 0 THEN 115 105IF D(J) = 0 THEN 140 110LET W = 1 115LET V = D(J) 120IF V = 9 THEN 160 125IF V < > 8 THEN 135 130IF S < 40000 THEN 160 REM NOW ADD THE FACTORIAL OF V TO S1 135LET S1 = S1 + F(V) 140NEXT J REM NOW WE TEST FOR EQUALITY OF S AND S1 145IF S < > S1 THEN 160 150PRINT 155PRINT S, \" \", \" \", S1 160LET D(4) = D(4) + 1 165FOR J = 0 TO 4 170IF D(J) = 0 THEN 200 175IF D(J) < 10 THEN 200 180LET D(J) = D(J) - 10 190LET D(J-1) = D(J-1) + 1 195GO TO 165 200NEXT J 205IF D(0) < 5 THEN 80 210STOP 215END", "ref_id": 4635, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Find all integers less than 50,000 that equal to the sum of the factorials of their digits. Write a computer program to solve this problem.", "options": ["1, 2, 145, 40586", "1, 2, 145 and 40585", "1, 2, 145, 765", "1, 2, 144, 40585"], "answer": "B", "solution": "To gain a better understanding of the problem, consider the following examples: 1) The number 7666 is not equal to the sum of its factorial digits since 7! + 6! + 6! + 6! = 5040 + 720 + 720 + 720 = 7200 \\not = 7666. 2) Let n = 145. Then 1! + 4! + 5! = 1 + 24 + 120 = 145. Hence 145 is equal to the sum of the factorials of its digits. In the writing of the program, first store the value of n! up to 9! in the memory. Then store each digit of the given number in a location cell. Actually there are only 4 numbers that satisfy the above property: 1,2,145 and 40585. But this is a problem in programming as well as number theory; so, on with the program. 5DIM D(4), F(9) 10MAT D = ZER REMEACH DIGIT OF N (5 DIGITS FOR EVERY NUMBER) REMIS STORED IN D(J). BEGIN WITH 00001. 15LET D(4) = 1 REMNOW STORE FACTORIAL VALUES. 20LET F(0) = 1 25LET F(1) = 1 30LET F(2) = 2 35LET F(3) = 6 40LET F(4) = 24 45LET F(5) = 120 50LET F(6) = 720 55LET F(7) = 5040 60LET F(8) = 40320 65LET F(9) = 362,880 70PRINT \"NUMBER IS\", \" \" , \" SUM OF FACTORIALS OF ITS DIGITS IS\" 75PRINT REMNOW ADD UP THE DIGITS IN EACH REMD(J), MULTIPLYING BY CORRESPONDING POWERS OF TEN FOR REMINCREASING J. 80LET S = D(4) + 10\\textasteriskcentered D(3) + 100\\textasteriskcentered D(2) + 1000\\textasteriskcentered D(1) + 10000\\textasteriskcentered D(0) 85LET S1 = 0 90LET W = 0 95FOR J = 0 TO 4 100IF W < > 0 THEN 115 105IF D(J) = 0 THEN 140 110LET W = 1 115LET V = D(J) 120IF V = 9 THEN 160 125IF V < > 8 THEN 135 130IF S < 40000 THEN 160 REM NOW ADD THE FACTORIAL OF V TO S1 135LET S1 = S1 + F(V) 140NEXT J REM NOW WE TEST FOR EQUALITY OF S AND S1 145IF S < > S1 THEN 160 150PRINT 155PRINT S, \" \", \" \", S1 160LET D(4) = D(4) + 1 165FOR J = 0 TO 4 170IF D(J) = 0 THEN 200 175IF D(J) < 10 THEN 200 180LET D(J) = D(J) - 10 190LET D(J-1) = D(J-1) + 1 195GO TO 165 200NEXT J 205IF D(0) < 5 THEN 80 210STOP 215END"}, "question": "task_1"}}, {"data": {"text": "Question:\nDevelop a FORTRAN program segment to arrange in ascending order a set of N elements, trying to use the least number of passes possible.\n\nOptions:\nA. Merge sort\nB. Selection sort\nC.             Bubble sort\nD. Insertion sort\n\nAnswer: C\n\nReference Solution:\nOne efficient method is known as a bubble sort. With this method, each pair of adjacent elements is compared. If they are in the proper order , they are left alone. If not, the terms are reversed in order before going on to the next pair. The integers are represented in the array ID (N), where N is the total number of elements to be sorted. The variable K permits the termination of the loop: if K is still zero at the beginning of the pass , the outer loop terminates, in-dicating that no switches had to be made , so that the array is sorted, if K equals one, another pass through the list must be made. The program segment is given below: INTERGER I, J, N, ID (N), TEMP. DIMENSION ID (N) K = 1 DO 30 I = N, 2, -1 IF (K.EQ.0) GO TO 50 K = 0 DO 40 J = 1, I - 1 IF (ID (J).LE.ID (J + 1)) GO TO 30 TEMP = ID (J) ID (J) = ID (J + 1) ID (J + 1) = TEMP K = 1 GO TO 30 40CONTINUE 30CONTINUE 50DO 60 m = 1, N WRITE (5, 100) ID (N) 100FORMAT (IX, I4) 60CONTINUE", "ref_id": 4636, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Develop a FORTRAN program segment to arrange in ascending order a set of N elements, trying to use the least number of passes possible.", "options": ["Merge sort", "Selection sort", "Bubble sort", "Insertion sort"], "answer": "C", "solution": "One efficient method is known as a bubble sort. With this method, each pair of adjacent elements is compared. If they are in the proper order , they are left alone. If not, the terms are reversed in order before going on to the next pair. The integers are represented in the array ID (N), where N is the total number of elements to be sorted. The variable K permits the termination of the loop: if K is still zero at the beginning of the pass , the outer loop terminates, in-dicating that no switches had to be made , so that the array is sorted, if K equals one, another pass through the list must be made. The program segment is given below: INTERGER I, J, N, ID (N), TEMP. DIMENSION ID (N) K = 1 DO 30 I = N, 2, -1 IF (K.EQ.0) GO TO 50 K = 0 DO 40 J = 1, I - 1 IF (ID (J).LE.ID (J + 1)) GO TO 30 TEMP = ID (J) ID (J) = ID (J + 1) ID (J + 1) = TEMP K = 1 GO TO 30 40CONTINUE 30CONTINUE 50DO 60 m = 1, N WRITE (5, 100) ID (N) 100FORMAT (IX, I4) 60CONTINUE"}, "question": "task_1"}}, {"data": {"text": "Question:\nAn economist suspects that a leading indicator in the business cycle has the form xcosx. He wishes to know when the indicator will peak, i.e. achieve a maximum, in different time intervals. Write a FORTRAN program to find the maximum of xcosx in interval [a,b].\n\nOptions:\nA. Use integration to find the maximum of xcosx\nB. Use differentiation to find the maximum of xcosx\nC.             Use a binary search to find the maximum of xcosx\nD. Use the elimination scheme to find the maximum of xcosx in a given interval\n\nAnswer: D\n\nReference Solution:\nThere are many methods of computing the maximum of a function over its domain or a subset of its domain (local maximum). A method particularly suited for computer applications is the elimination scheme. To illustrate the method, let a = o, b = \\pi and suppose we wish to Maxxcosxx\\epsilon [o,\\pi].(1) 1) Place two search points close together at the centre of the interval. Let the distance between the points be \\epsilon > o. 2) Evaluate f(x) at X_L and X_R and call the results f(X_L), f(X_R). If f(X_L) \\geq f(X_R) Max f(X) lies between o and X_R and the segment [X_R \\pi] can be discarded. 3) Place two search points close together at the center of the remaining interval and repeat step (2). 4) Suppose f(X_(R)1 ) \\geq f (X_(L)1). Then Max f(X) lies in the interval [X_(L)1 ,X_R] and the segment [0, X_(L)1 ] can be discarded. 5) The process continues until an interval less than 2\\epsilon is obtained. Since the search cannot continue, the maximum is assumed to occur at the center of this interval. In the program, a statement function is used to define xcosx so that it can be referred to at any further point in the program. Also, if the search points pass a toler-ance limit, the program halts. CDEFINE THE FUNCTION Y(X) Y(X) = X\\textasteriskcenteredCOX(X) READ XL, XR, EPSI I = 1 CCALCULATE INTERIOR POINTS 10XL1 = XL + . 5\\textasteriskcentered (XR - XL - EPSI) XR1 = XL1 + EPSI YL1 = Y(XL1) YR1 = Y(XR1) PRINT YL1, YR1, XL, XL1, XR1, XR IF (YL1 - YR1) 20, 50, 30 20XL = XL1 GO TO 40 30XR = XR1 CTEST FOR END OF SEARCH 40IF (I.GE.100) GO TO 60 I = I + 1 IF (XR - XL.GT.3\\textasteriskcenteredEPSI) GO TO 10 50XMAX = .5\\textasteriskcentered(XL1 + XR1) YMAX = . 5\\textasteriskcentered (YL1 + YR1) PRINT YMAX, XMAX GO TO 70 CPRINT OUTPUT TERMINATED BECAUSE OF MAX- CIMUM ITERATION COUNT 60WRITE (6, 300) 300FORMAT (54HO THE SOLUTION HAS NOT CONVERGED AFTER 100 ITERATIONS. TERMINATE PROGRAM 70STOP END", "ref_id": 4637, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "An economist suspects that a leading indicator in the business cycle has the form xcosx. He wishes to know when the indicator will peak, i.e. achieve a maximum, in different time intervals. Write a FORTRAN program to find the maximum of xcosx in interval [a,b].", "options": ["Use integration to find the maximum of xcosx", "Use differentiation to find the maximum of xcosx", "Use a binary search to find the maximum of xcosx", "Use the elimination scheme to find the maximum of xcosx in a given interval"], "answer": "D", "solution": "There are many methods of computing the maximum of a function over its domain or a subset of its domain (local maximum). A method particularly suited for computer applications is the elimination scheme. To illustrate the method, let a = o, b = \\pi and suppose we wish to Maxxcosxx\\epsilon [o,\\pi].(1) 1) Place two search points close together at the centre of the interval. Let the distance between the points be \\epsilon > o. 2) Evaluate f(x) at X_L and X_R and call the results f(X_L), f(X_R). If f(X_L) \\geq f(X_R) Max f(X) lies between o and X_R and the segment [X_R \\pi] can be discarded. 3) Place two search points close together at the center of the remaining interval and repeat step (2). 4) Suppose f(X_(R)1 ) \\geq f (X_(L)1). Then Max f(X) lies in the interval [X_(L)1 ,X_R] and the segment [0, X_(L)1 ] can be discarded. 5) The process continues until an interval less than 2\\epsilon is obtained. Since the search cannot continue, the maximum is assumed to occur at the center of this interval. In the program, a statement function is used to define xcosx so that it can be referred to at any further point in the program. Also, if the search points pass a toler-ance limit, the program halts. CDEFINE THE FUNCTION Y(X) Y(X) = X\\textasteriskcenteredCOX(X) READ XL, XR, EPSI I = 1 CCALCULATE INTERIOR POINTS 10XL1 = XL + . 5\\textasteriskcentered (XR - XL - EPSI) XR1 = XL1 + EPSI YL1 = Y(XL1) YR1 = Y(XR1) PRINT YL1, YR1, XL, XL1, XR1, XR IF (YL1 - YR1) 20, 50, 30 20XL = XL1 GO TO 40 30XR = XR1 CTEST FOR END OF SEARCH 40IF (I.GE.100) GO TO 60 I = I + 1 IF (XR - XL.GT.3\\textasteriskcenteredEPSI) GO TO 10 50XMAX = .5\\textasteriskcentered(XL1 + XR1) YMAX = . 5\\textasteriskcentered (YL1 + YR1) PRINT YMAX, XMAX GO TO 70 CPRINT OUTPUT TERMINATED BECAUSE OF MAX- CIMUM ITERATION COUNT 60WRITE (6, 300) 300FORMAT (54HO THE SOLUTION HAS NOT CONVERGED AFTER 100 ITERATIONS. TERMINATE PROGRAM 70STOP END"}, "question": "task_1"}}, {"data": {"text": "Question:\nWrite a FORTRAN program to analyze a population according to these three genetic criteria: 1) Hair color 2) Eye color 3) Skin color The program should read a deck of cards, each of which contains for one individual the integers, 1, 2, or 3 to identify the three criteria. Output should consist of the number of individuals found to have the corresponding set of genetic factors.\n\nOptions:\nA. A FORTRAN program using a three-dimensional array to store and analyze genetic data from a deck of cards\nB. A Python program using a three-dimensional array to store and analyze genetic data\nC.             A FORTRAN program using a three-dimensional array to store and analyze genetic data from a database\nD. A FORTRAN program using a two-dimensional array to store and analyze genetic data\n\nAnswer: A\n\nReference Solution:\nWe will need a three-dimensional array to store hair, eye, and skin data. These will be in the form of five-digit integers; e.g., black hair = 01111, blue eyes = 02100, green skin = 03999. As each card is read, the program should add 1 to the appropriate cell of the array. In the output, we want to print the number of individuals that have the same set of genetic factors. Note that we are not in-terested in the individual cases, but only in the number of matches found in the population. The variable IEND appears at the end of each card; the program terminates when a card is encountered where IEND is nonzero. DIMENSION KOUNT (3,3,3) DO 10 I = 1,3/{_\\ast}INITIALIZING ARRAY{_\\ast}/ DO 20 J = 1,3 DO 30 K = 1,3 KOUNT (I, J,K) = 0 30CONTINUE 20CONTINUE 10CONTINUE 40READ (2,100) IHAIR, IEYES, ISKIN, IEND 100FORMAT (415) IF (IEND.NE.0) GO TO 50 KOUNT(IHAIR, IEYES, ISKIN) = KOUNT (IHAIR, IEYES, 1ISKIN) + 1 GO TO 40 50CONTINUE DO 60 I = 1,3 DO 61 J = 1,3 DO 62 K = 1,3 WRITE (6,100) KOUNT (I,J,K) 62CONTINUE 61CONTINUE 60CONTINUE STOP END", "ref_id": 4638, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Write a FORTRAN program to analyze a population according to these three genetic criteria: 1) Hair color 2) Eye color 3) Skin color The program should read a deck of cards, each of which contains for one individual the integers, 1, 2, or 3 to identify the three criteria. Output should consist of the number of individuals found to have the corresponding set of genetic factors.", "options": ["A FORTRAN program using a three-dimensional array to store and analyze genetic data from a deck of cards", "A Python program using a three-dimensional array to store and analyze genetic data", "A FORTRAN program using a three-dimensional array to store and analyze genetic data from a database", "A FORTRAN program using a two-dimensional array to store and analyze genetic data"], "answer": "A", "solution": "We will need a three-dimensional array to store hair, eye, and skin data. These will be in the form of five-digit integers; e.g., black hair = 01111, blue eyes = 02100, green skin = 03999. As each card is read, the program should add 1 to the appropriate cell of the array. In the output, we want to print the number of individuals that have the same set of genetic factors. Note that we are not in-terested in the individual cases, but only in the number of matches found in the population. The variable IEND appears at the end of each card; the program terminates when a card is encountered where IEND is nonzero. DIMENSION KOUNT (3,3,3) DO 10 I = 1,3/{_\\ast}INITIALIZING ARRAY{_\\ast}/ DO 20 J = 1,3 DO 30 K = 1,3 KOUNT (I, J,K) = 0 30CONTINUE 20CONTINUE 10CONTINUE 40READ (2,100) IHAIR, IEYES, ISKIN, IEND 100FORMAT (415) IF (IEND.NE.0) GO TO 50 KOUNT(IHAIR, IEYES, ISKIN) = KOUNT (IHAIR, IEYES, 1ISKIN) + 1 GO TO 40 50CONTINUE DO 60 I = 1,3 DO 61 J = 1,3 DO 62 K = 1,3 WRITE (6,100) KOUNT (I,J,K) 62CONTINUE 61CONTINUE 60CONTINUE STOP END"}, "question": "task_1"}}, {"data": {"text": "Question:\nObtain polar solutions for the following polar equations, in which the ordered pair (R, T) is interpreted as R = length of the vector going from the origin to the point R, and T = angle between polar axis and that vector: (a) R = 1 - 2 sin T (b) R = 2 + 2 sin T (c) R = 1 + 2cosT - sin^2T\n\nOptions:\nA. A variety of polar equations can be evaluated with this program by making minor adjustments.\nB. This program can only evaluate one polar equation at a time\nC.             Polar equations cannot be evaluated with this program\nD. Only sin and cos functions can be evaluated with this program\n\nAnswer: A\n\nReference Solution:\nAlthough it is not absolutely necessary, we can make use of the defined statement function. The value of T will be incremented by 15 degrees each time by establishing a loop. Conversion to radians is accomplished with k = \\pi/180. The output will appear in tabular form, with values rounded to the nearest hundredth: 1\\O REM SOLVING POLAR EQUATIONS IN 15 - 2\\O REM DEGREE STEPS 3\\O LET K = 3.14159/18\\O.\\O 4\\O PRINT \"ANGLE\", \"1-2SIN(T)\", \\textquotedblright2+2SIN(T)\", \"1+2COS(T) - SIN(T)_\\uparrow2\" 5\\O DEF FNR(X) = INT(X\\textasteriskcentered1\\O\\O)/1\\O\\O 6\\O DEF FNA(X) = 1 - 2\\textasteriskcenteredSIN(K\\textasteriskcenteredX) 7\\O DEF FNB(X) = 2 + 2\\textasteriskcenteredSIN(K\\textasteriskcenteredX) 8\\O DEF FNC(X) = 1 + 2\\textasteriskcenteredCOS(K\\textasteriskcenteredX) - SIN(K\\textasteriskcenteredX)_\\uparrow2 9\\O FOR T = \\O TO 3\\O\\O STEP 15 1\\O\\O PRINT T, FNR(FNA(T)), FNR(FNB(T)), FNR(FNC(T)) 11\\O NEXTT 12\\O END [Note: a variety of polar equations can be evaluated with this program by making minor adjustments.]", "ref_id": 4639, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Obtain polar solutions for the following polar equations, in which the ordered pair (R, T) is interpreted as R = length of the vector going from the origin to the point R, and T = angle between polar axis and that vector: (a) R = 1 - 2 sin T (b) R = 2 + 2 sin T (c) R = 1 + 2cosT - sin^2T", "options": ["A variety of polar equations can be evaluated with this program by making minor adjustments.", "This program can only evaluate one polar equation at a time", "Polar equations cannot be evaluated with this program", "Only sin and cos functions can be evaluated with this program"], "answer": "A", "solution": "Although it is not absolutely necessary, we can make use of the defined statement function. The value of T will be incremented by 15 degrees each time by establishing a loop. Conversion to radians is accomplished with k = \\pi/180. The output will appear in tabular form, with values rounded to the nearest hundredth: 1\\O REM SOLVING POLAR EQUATIONS IN 15 - 2\\O REM DEGREE STEPS 3\\O LET K = 3.14159/18\\O.\\O 4\\O PRINT \"ANGLE\", \"1-2SIN(T)\", \\textquotedblright2+2SIN(T)\", \"1+2COS(T) - SIN(T)_\\uparrow2\" 5\\O DEF FNR(X) = INT(X\\textasteriskcentered1\\O\\O)/1\\O\\O 6\\O DEF FNA(X) = 1 - 2\\textasteriskcenteredSIN(K\\textasteriskcenteredX) 7\\O DEF FNB(X) = 2 + 2\\textasteriskcenteredSIN(K\\textasteriskcenteredX) 8\\O DEF FNC(X) = 1 + 2\\textasteriskcenteredCOS(K\\textasteriskcenteredX) - SIN(K\\textasteriskcenteredX)_\\uparrow2 9\\O FOR T = \\O TO 3\\O\\O STEP 15 1\\O\\O PRINT T, FNR(FNA(T)), FNR(FNB(T)), FNR(FNC(T)) 11\\O NEXTT 12\\O END [Note: a variety of polar equations can be evaluated with this program by making minor adjustments.]"}, "question": "task_1"}}, {"data": {"text": "Question:\nDescribe in words the function and the output of the following subroutine. SUBROUTINE GCD (I,J,K) IF (I - J) 1,4,2 1 L = J J = I I = L 2L = I-(I/J){_\\ast}J IF(L) 3,4,3 3 I = J J = L GO TO 2 4 K = J RETURN END\n\nOptions:\nA. The program calculates the least common multiple of I and J.\nB. The program finds the greatest common divisor K of two positive integers I and J.\nC.             The program subtracts J from I and stores the result in K.\nD. The program adds I and J and stores the result in K.\n\nAnswer: B\n\nReference Solution:\nThe program is written to find the greatest common divisor K of two positive integers I and J. Following the first IF statement, the program pointer will go directly to 1 if the value I - J is negative, to 4 if the value is zero, and 2 if the value is positive. Statement number 1 and the following two statements interchange the values of I and J; therefore prior to statement 2, I is greater than or equal to J. Statement 2 seems useless at first glance. But do not forget that I,J,K and L represent integer variables. Therefore (I/J){_\\ast}J may not be equal to I. For example: Let 1 = 4 and J = 3. I/J then will be equal to 1.25, but will be truncated by the computer into integer 1. Then, after multiplying it by J = 3 the computer will get 3 as the result, not 4 as it had originally. In the second IF statement using the same argument as above, the program pointer will go to statements 3 or 4. Statement 3 and the fol-lowing statement replace J with I and L with J. Then the computer goes back to the statement 2 and repeats the calculations. This goes on until I will be divided by J with no remainder left to truncate. In that case value of L will become zero, and the computer will go to statement 4, equate K to J and store this value under K as the desired divisor.", "ref_id": 4640, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Describe in words the function and the output of the following subroutine. SUBROUTINE GCD (I,J,K) IF (I - J) 1,4,2 1 L = J J = I I = L 2L = I-(I/J){_\\ast}J IF(L) 3,4,3 3 I = J J = L GO TO 2 4 K = J RETURN END", "options": ["The program calculates the least common multiple of I and J.", "The program finds the greatest common divisor K of two positive integers I and J.", "The program subtracts J from I and stores the result in K.", "The program adds I and J and stores the result in K."], "answer": "B", "solution": "The program is written to find the greatest common divisor K of two positive integers I and J. Following the first IF statement, the program pointer will go directly to 1 if the value I - J is negative, to 4 if the value is zero, and 2 if the value is positive. Statement number 1 and the following two statements interchange the values of I and J; therefore prior to statement 2, I is greater than or equal to J. Statement 2 seems useless at first glance. But do not forget that I,J,K and L represent integer variables. Therefore (I/J){_\\ast}J may not be equal to I. For example: Let 1 = 4 and J = 3. I/J then will be equal to 1.25, but will be truncated by the computer into integer 1. Then, after multiplying it by J = 3 the computer will get 3 as the result, not 4 as it had originally. In the second IF statement using the same argument as above, the program pointer will go to statements 3 or 4. Statement 3 and the fol-lowing statement replace J with I and L with J. Then the computer goes back to the statement 2 and repeats the calculations. This goes on until I will be divided by J with no remainder left to truncate. In that case value of L will become zero, and the computer will go to statement 4, equate K to J and store this value under K as the desired divisor."}, "question": "task_1"}}, {"data": {"text": "Question:\nSuppose a salesman gets $6 commission on each sale as longas the sale is under $150. However, if the sale is over $150 he gets a bonus of 2% of the amount over the $150. Write a PL/I program that will take as data the values of the amountof sale and print the commission the salesman gets.\n\nOptions:\nA. A C++ program\nB. A PL/I program\nC.             A Python program\nD. A Java program\n\nAnswer: B\n\nReference Solution:\nFormally, we can express the commission C as follows. If the amountA is less than $150, then C = $6. Otherwise, if A>150, then C = 6 + 2 x (A-150)/100 /\\textasteriskcenteredCOMMISSION CALCULATION\\textasteriskcentered/ L2\\O:GET LIST (A); L3\\O:IF A< = 15\\O THEN GO TO L6\\O; L4\\O:C = 6 + 2\\textasteriskcentered(A-15\\O)/1\\O\\O; L5\\O:GO TO L7\\O; L6\\O:C = 6; L7\\O:PUT EDIT (A, C) (F (7, 2) F (7, 2)); L8\\O:PUT SKIP; L9\\O:GO TO L2\\O;", "ref_id": 4641, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Suppose a salesman gets $6 commission on each sale as longas the sale is under $150. However, if the sale is over $150 he gets a bonus of 2% of the amount over the $150. Write a PL/I program that will take as data the values of the amountof sale and print the commission the salesman gets.", "options": ["A C++ program", "A PL/I program", "A Python program", "A Java program"], "answer": "B", "solution": "Formally, we can express the commission C as follows. If the amountA is less than $150, then C = $6. Otherwise, if A>150, then C = 6 + 2 x (A-150)/100 /\\textasteriskcenteredCOMMISSION CALCULATION\\textasteriskcentered/ L2\\O:GET LIST (A); L3\\O:IF A< = 15\\O THEN GO TO L6\\O; L4\\O:C = 6 + 2\\textasteriskcentered(A-15\\O)/1\\O\\O; L5\\O:GO TO L7\\O; L6\\O:C = 6; L7\\O:PUT EDIT (A, C) (F (7, 2) F (7, 2)); L8\\O:PUT SKIP; L9\\O:GO TO L2\\O;"}, "question": "task_1"}}, {"data": {"text": "Question:\n(a) Suppose that the statement IF(I - J) 5,6,6 is replaced by IF(I - J) 6,5,5 in the program of the previous problem. Explain the effect of this change. (b) Explain what happens if the same statement is replaced byIF(J - I) 6,5,5 (c) Explain what happens if the statement GO TO 7 is omitted in the program of the previous problem.\n\nOptions:\nA. a) Outputs value of I, b) Outputs value of J, c) Prints the value of I and J\nB. a) No change, b) No change, c) Prints the value of J\nC.             a) Outputs largest of two numbers, b) Outputs smallest of two numbers, c) Prints the value of I\nD. a) Outputs smallest of two numbers, b) Outputs largest of two numbers, c) Prints the value of J or I and J\n\nAnswer: D\n\nReference Solution:\na)If we use the statement IF(I - J) 6,5,5, then whenever the value of I - J is negative the computer will go to statement number 6, which causes the output of the value of I, followed by the end of the program (i.e., STOP statement). On the other hand, if the value I - J is zero or positive, statement number 5 will be executed. Therefore, the program is written to find the smallest of two numbers. b)If the statement is replaced by IF(J - I) 6,5,5 execution will happen exactly as it did in a), except that the values of I and J will be interchanged. At the end of the output will be the largest of two numbers. c)If the GO TO 7 statement is omitted, there are two possible cases: I.If I - J < 0 (i.e., I < J), the computer will go to statement 5 and print the value of J. II.If I - J \\geq 0 (i.e., I \\geq J), the computer will go to state-ment 6 and first print the value of I, and then the value of J.", "ref_id": 4642, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "(a) Suppose that the statement IF(I - J) 5,6,6 is replaced by IF(I - J) 6,5,5 in the program of the previous problem. Explain the effect of this change. (b) Explain what happens if the same statement is replaced byIF(J - I) 6,5,5 (c) Explain what happens if the statement GO TO 7 is omitted in the program of the previous problem.", "options": ["a) Outputs value of I, b) Outputs value of J, c) Prints the value of I and J", "a) No change, b) No change, c) Prints the value of J", "a) Outputs largest of two numbers, b) Outputs smallest of two numbers, c) Prints the value of I", "a) Outputs smallest of two numbers, b) Outputs largest of two numbers, c) Prints the value of J or I and J"], "answer": "D", "solution": "a)If we use the statement IF(I - J) 6,5,5, then whenever the value of I - J is negative the computer will go to statement number 6, which causes the output of the value of I, followed by the end of the program (i.e., STOP statement). On the other hand, if the value I - J is zero or positive, statement number 5 will be executed. Therefore, the program is written to find the smallest of two numbers. b)If the statement is replaced by IF(J - I) 6,5,5 execution will happen exactly as it did in a), except that the values of I and J will be interchanged. At the end of the output will be the largest of two numbers. c)If the GO TO 7 statement is omitted, there are two possible cases: I.If I - J < 0 (i.e., I < J), the computer will go to statement 5 and print the value of J. II.If I - J \\geq 0 (i.e., I \\geq J), the computer will go to state-ment 6 and first print the value of I, and then the value of J."}, "question": "task_1"}}, {"data": {"text": "Question:\nA book publisher is in the business of producing volumes in mathematics, science and the humanities. He basically uses two kinds of labor a) skilled for writing the books b) unskilled to correct the completed volumes. His average costs per book for each type of labor and each type of book is given below: Expenses Mathematics Science Humanities Skilled Unskilled 17.00 6.00 16,00 5.00 12.00 4.00 Write a program in Basic to print the costs of skilled and unskilled labor needed to produce M books in math, S books in science, and H books in humanities, if M = 1, 2, 3, 4, 5; S = 2M + 1; H = 2M - 2.\n\nOptions:\nA. A program in C++ that calculates the costs\nB. A program in Basic that calculates the costs of skilled and unskilled labor needed to produce M books in math, S books in science, and H books in humanities, given the equations M = 1, 2, 3, 4, 5; S = 2M + 1; H = 2M - 2.\nC.             A program in Python that calculates the costs\nD. A program in Java that calculates the costs\n\nAnswer: B\n\nReference Solution:\nWe can use matrices to facilitate the solution of this problem \u250217.00 (M) + 16.00(2M + 1) + 12.00 (2M - 2)\u2502(1) \u25026.00 (M) + 5.00(2M + 1) + 4.00(2M - 2)\u2502 If we multiply (1) by the vector \u2502M\u2502 \u25022M + 1\u2502we obtain: \u25022m - 2\u2502 \u2502175001620012400 \u2502\u2502M\u2502 \u2502620055004900\u2502\u25022M + 1 \u2502 \u25022M - 2 \u2502 =\u250217500M + 16200(2M+1) + 12400(2M-2)\u2502(2) \u25026200M +5500(2M+1) + 4900(2M-2)\u2502 Adding the two rows of (2) together gives the total cost of skilled and unskilled labor. Note that costs of skilled labor comprise the first row of the result in (2) , while costs of unskilled labor comprise the second row. 10DIM A (1, 2), L(1): REM L(0), L(1) DENOTE SKILLED, UN-SKILLED LABOR 15FOR I = 0 TO 1 20FOR J = 0 TO 2 25READ X 30LET A (I, J) = X 35NEXT J 40NEXT I 45PRINT \"MATH\", \"SCIENCES\", \"HUMANITIES\", \"SKILLED LA-BOR\", \"UNSKILLED TOTAL COSTS\" 50PRINT 55FOR M = 1 TO 5 60LET S = 2\\textasteriskcenteredM-1 65LET H = 2\\textasteriskcenteredM-2 70FOR I = 0 TO 1 75LET L(I) = A(I,0)\\textasteriskcenteredM + A(I,1)\\textasteriskcenteredS + A(I,2)\\textasteriskcenteredL 80NEXT I 85PRINT M, S, H, L(0), L(l); \"\"; L(0)+L(1) 90NEXT M 95PRINT 100STOP 105DATA 17, 16, 12, 6, 5, 4 110END", "ref_id": 4643, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "A book publisher is in the business of producing volumes in mathematics, science and the humanities. He basically uses two kinds of labor a) skilled for writing the books b) unskilled to correct the completed volumes. His average costs per book for each type of labor and each type of book is given below: Expenses Mathematics Science Humanities Skilled Unskilled 17.00 6.00 16,00 5.00 12.00 4.00 Write a program in Basic to print the costs of skilled and unskilled labor needed to produce M books in math, S books in science, and H books in humanities, if M = 1, 2, 3, 4, 5; S = 2M + 1; H = 2M - 2.", "options": ["A program in C++ that calculates the costs", "A program in Basic that calculates the costs of skilled and unskilled labor needed to produce M books in math, S books in science, and H books in humanities, given the equations M = 1, 2, 3, 4, 5; S = 2M + 1; H = 2M - 2.", "A program in Python that calculates the costs", "A program in Java that calculates the costs"], "answer": "B", "solution": "We can use matrices to facilitate the solution of this problem \u250217.00 (M) + 16.00(2M + 1) + 12.00 (2M - 2)\u2502(1) \u25026.00 (M) + 5.00(2M + 1) + 4.00(2M - 2)\u2502 If we multiply (1) by the vector \u2502M\u2502 \u25022M + 1\u2502we obtain: \u25022m - 2\u2502 \u2502175001620012400 \u2502\u2502M\u2502 \u2502620055004900\u2502\u25022M + 1 \u2502 \u25022M - 2 \u2502 =\u250217500M + 16200(2M+1) + 12400(2M-2)\u2502(2) \u25026200M +5500(2M+1) + 4900(2M-2)\u2502 Adding the two rows of (2) together gives the total cost of skilled and unskilled labor. Note that costs of skilled labor comprise the first row of the result in (2) , while costs of unskilled labor comprise the second row. 10DIM A (1, 2), L(1): REM L(0), L(1) DENOTE SKILLED, UN-SKILLED LABOR 15FOR I = 0 TO 1 20FOR J = 0 TO 2 25READ X 30LET A (I, J) = X 35NEXT J 40NEXT I 45PRINT \"MATH\", \"SCIENCES\", \"HUMANITIES\", \"SKILLED LA-BOR\", \"UNSKILLED TOTAL COSTS\" 50PRINT 55FOR M = 1 TO 5 60LET S = 2\\textasteriskcenteredM-1 65LET H = 2\\textasteriskcenteredM-2 70FOR I = 0 TO 1 75LET L(I) = A(I,0)\\textasteriskcenteredM + A(I,1)\\textasteriskcenteredS + A(I,2)\\textasteriskcenteredL 80NEXT I 85PRINT M, S, H, L(0), L(l); \"\"; L(0)+L(1) 90NEXT M 95PRINT 100STOP 105DATA 17, 16, 12, 6, 5, 4 110END"}, "question": "task_1"}}, {"data": {"text": "Question:\nWrite a general purpose BASIC program which prints a table of values for any function.\n\nOptions:\nA. 1\\O REM PRINTS A TABLE OF VALUES FOR ANY FUNCTION 2\\O DEF FNA(X) = X 3\\O PRINT \"TO DEFINE A NEW FUNCTION TYPE Y; ELSE TYPE N.\" 4\\O INPUT A$ 5\\O IF A$ = \"N\" THEN 11\\O 6\\O PRINT \"TYPE YOUR FUNCTION AS A FUNCTION OF X, AFTER YOU TYPE 7\\O PRINT \"2\\O DEF FNA(X) =\"\nB. 1\\O REM PRINTS A TABLE OF VALUES FOR ANY FUNCTION 2\\O DEF FNA(X) = X 3\\O PRINT \"TO DEFINE A NEW FUNCTION TYPE Y; ELSE TYPE N.\" 4\\O INPUT A$ 5\\O IF A$ = \"Y\" THEN 11\\O\nC.             1\\O REM PRINTS A TABLE OF VALUES FOR ANY FUNCTION 2\\O DEF FNA(X) = X 3\\O PRINT \"TO DEFINE A NEW FUNCTION TYPE Y; ELSE TYPE N.\" 4\\O INPUT A$ 5\\O IF A$ = \"N\" THEN 11\\O 6\\O PRINT \"TYPE YOUR FUNCTION AS A FUNCTION OF X, AFTER YOU TYPE 7\\O PRINT \"2\\O DEF FNA(X) =\" 8\\O PRINT \"THEN HIT THE RETURN KEY AND FINALLY\"; 9\\O PRINT \"TYPE THE COMMAND RUN\" 1\\O\\O STOP 11\\O PRINT \"WHAT ARE THE MINIMUM, MAXIMUM, AND INCREASE IN X\"\nD. 1\\O REM PRINTS A TABLE OF VALUES FOR ANY FUNCTION 2\\O DEF FNA(X) = X 3\\O PRINT \"TO DEFINE A NEW FUNCTION TYPE Y; ELSE TYPE N.\" 4\\O INPUT A$ 5\\O IF A$ = \"N\" THEN 11\\O 6\\O PRINT \"TYPE YOUR FUNCTION AS A FUNCTION OF X, AFTER YOU TYPE 7\\O PRINT \"2\\O DEF FNA(X) =\" 8\\O PRINT \"THEN HIT THE RETURN KEY AND FINALLY\"; 9\\O PRINT \"TYPE THE COMMAND RUN\" 1\\O\\O STOP 11\\O PRINT \"WHAT ARE THE MINIMUM, MAXIMUM, AND INCREASE IN X\" 12\\O INPUT X1, X2, D 13\\O FOR I = X1 TO X2 STEP D 14\\O PRINT \"X; I; \"F(X) =\"; FNA (I) 15\\O NEXT I 16\\O END\n\nAnswer: D\n\nReference Solution:\nThe solution uses the notion of string variables and user defined functions. This program also makes use of the STOP statement, which, in BASIC, essentially terminates the execution of the program In the same fashion as the END statement. A term with $ following a single letter is used to record character data. 1\\O REM PRINTS A TABLE OF VALUES FOR ANY FUNCTION 2\\O DEF FNA(X) = X 3\\O PRINT \"TO DEFINE A NEW FUNCTION TYPE Y; ELSE TYPE N.\" 4\\O INPUT A$ 5\\O IF A$ = \"N\" THEN 11\\O 6\\O PRINT \"TYPE YOUR FUNCTION AS A FUNCTION OF X, AFTER YOU TYPE'' 7\\O PRINT \"2\\O DEF FNA(X) =\" 8\\O PRINT \"THEN HIT THE RETURN KEY AND FINALLY\"; 9\\O PRINT \"TYPE THE COMMAND RUN\" 1\\O\\O STOP 11\\O PRINT \"WHAT ARE THE MINIMUM, MAXIMUM, AND INCREASE IN X\" 12\\O INPUT X1, X2, D 13\\O FOR I = X1 TO X2 STEP D 14\\O PRINT \"X; I; \"F(X) =\"; FNA (I) 15\\O NEXT I 16\\O END", "ref_id": 4644, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Write a general purpose BASIC program which prints a table of values for any function.", "options": ["1\\O REM PRINTS A TABLE OF VALUES FOR ANY FUNCTION 2\\O DEF FNA(X) = X 3\\O PRINT \"TO DEFINE A NEW FUNCTION TYPE Y; ELSE TYPE N.\" 4\\O INPUT A$ 5\\O IF A$ = \"N\" THEN 11\\O 6\\O PRINT \"TYPE YOUR FUNCTION AS A FUNCTION OF X, AFTER YOU TYPE 7\\O PRINT \"2\\O DEF FNA(X) =\"", "1\\O REM PRINTS A TABLE OF VALUES FOR ANY FUNCTION 2\\O DEF FNA(X) = X 3\\O PRINT \"TO DEFINE A NEW FUNCTION TYPE Y; ELSE TYPE N.\" 4\\O INPUT A$ 5\\O IF A$ = \"Y\" THEN 11\\O", "1\\O REM PRINTS A TABLE OF VALUES FOR ANY FUNCTION 2\\O DEF FNA(X) = X 3\\O PRINT \"TO DEFINE A NEW FUNCTION TYPE Y; ELSE TYPE N.\" 4\\O INPUT A$ 5\\O IF A$ = \"N\" THEN 11\\O 6\\O PRINT \"TYPE YOUR FUNCTION AS A FUNCTION OF X, AFTER YOU TYPE 7\\O PRINT \"2\\O DEF FNA(X) =\" 8\\O PRINT \"THEN HIT THE RETURN KEY AND FINALLY\"; 9\\O PRINT \"TYPE THE COMMAND RUN\" 1\\O\\O STOP 11\\O PRINT \"WHAT ARE THE MINIMUM, MAXIMUM, AND INCREASE IN X\"", "1\\O REM PRINTS A TABLE OF VALUES FOR ANY FUNCTION 2\\O DEF FNA(X) = X 3\\O PRINT \"TO DEFINE A NEW FUNCTION TYPE Y; ELSE TYPE N.\" 4\\O INPUT A$ 5\\O IF A$ = \"N\" THEN 11\\O 6\\O PRINT \"TYPE YOUR FUNCTION AS A FUNCTION OF X, AFTER YOU TYPE 7\\O PRINT \"2\\O DEF FNA(X) =\" 8\\O PRINT \"THEN HIT THE RETURN KEY AND FINALLY\"; 9\\O PRINT \"TYPE THE COMMAND RUN\" 1\\O\\O STOP 11\\O PRINT \"WHAT ARE THE MINIMUM, MAXIMUM, AND INCREASE IN X\" 12\\O INPUT X1, X2, D 13\\O FOR I = X1 TO X2 STEP D 14\\O PRINT \"X; I; \"F(X) =\"; FNA (I) 15\\O NEXT I 16\\O END"], "answer": "D", "solution": "The solution uses the notion of string variables and user defined functions. This program also makes use of the STOP statement, which, in BASIC, essentially terminates the execution of the program In the same fashion as the END statement. A term with $ following a single letter is used to record character data. 1\\O REM PRINTS A TABLE OF VALUES FOR ANY FUNCTION 2\\O DEF FNA(X) = X 3\\O PRINT \"TO DEFINE A NEW FUNCTION TYPE Y; ELSE TYPE N.\" 4\\O INPUT A$ 5\\O IF A$ = \"N\" THEN 11\\O 6\\O PRINT \"TYPE YOUR FUNCTION AS A FUNCTION OF X, AFTER YOU TYPE'' 7\\O PRINT \"2\\O DEF FNA(X) =\" 8\\O PRINT \"THEN HIT THE RETURN KEY AND FINALLY\"; 9\\O PRINT \"TYPE THE COMMAND RUN\" 1\\O\\O STOP 11\\O PRINT \"WHAT ARE THE MINIMUM, MAXIMUM, AND INCREASE IN X\" 12\\O INPUT X1, X2, D 13\\O FOR I = X1 TO X2 STEP D 14\\O PRINT \"X; I; \"F(X) =\"; FNA (I) 15\\O NEXT I 16\\O END"}, "question": "task_1"}}, {"data": {"text": "Question:\n(a)Write a FORTRAN program to find approximate solutions to the first order differential equationdy/dx= f(x,y) with initial condition y(X_0) = Y_0 using Euler's method. (b)Write a FORTRAN program to find approximate solutions to the second order differential equation d^2y/dx^2 = g(x,y,y') with initial conditions y(x_0) = Y_0 and y'(x_0) = y'_0 using Euler's method.\n\nOptions:\nA. Runge-Kutta method, differential equation, and FORTRAN main program\nB. Euler's method, difference equation, and FORTRAN main program\nC.             Laplace's method, integral equation, and FORTRAN main program\nD. Taylor's method, difference equation, and FORTRAN main program\n\nAnswer: B\n\nReference Solution:\n(a) Euler's method assumes that during the interval (x,x+\\Deltax),dy/dx remains constant and that \\Deltay/\\Deltax=dy/dx= f(x,y) \\Rightarrow\\Deltay=\\Deltaxf(x,y). Thus, y_new=y_old+\\Deltay=y_old+\\Deltaxf(x_old_ ,y_old). Or, stating this as a difference equation: yn+1=y_n+\\Deltaxf(x_n,y_n)(1) forn = 0,1,...,N. The FORTRAN main program is: READ N, DELTAX,X,Y PRINT, T,X,Y DO 1\\O I = 1,N X = X + DELTAX CUSE EQUATION (1) Y= Y + DELTAX \\textasteriskcentered F(X,Y) PRINT, X,Y 1\\OCONTINUE STOP END Note: F(X,Y) must be defined in a FUNCTION subprogram (b) Rewrite the equation as a system of simultaneous first-order equations:y' =dy/dx= z z' =dz/dx= g(x,y,z) with initial conditions y(x_0) = y_0 and z(x_0) = y'(x_0) = y'_0 The FORTRAN main program is: READ, N, DELTAX,X,X,Z PRINT, X,Y,Z DO 1\\O I = 1,NZPRIME = G(X,Y,Z) X = X + DELTAX Y = Y + DELTAX \\textasteriskcentered Z Z = Z + DELTAX \\textasteriskcentered ZPRIME PRINT, X,Y,Z 10CONTINUE STOP END Note:Again, G(X,Y,Z) must be defined. Also, for a fixed value of Ax, the error increases as \\vertx - x_0\\vert increases. In addition, for a fixed value ofx_n, the error increases as\\Deltaxincreases and is of order (\\Deltax)^2 .", "ref_id": 4645, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "(a)Write a FORTRAN program to find approximate solutions to the first order differential equationdy/dx= f(x,y) with initial condition y(X_0) = Y_0 using Euler's method. (b)Write a FORTRAN program to find approximate solutions to the second order differential equation d^2y/dx^2 = g(x,y,y') with initial conditions y(x_0) = Y_0 and y'(x_0) = y'_0 using Euler's method.", "options": ["Runge-Kutta method, differential equation, and FORTRAN main program", "Euler's method, difference equation, and FORTRAN main program", "Laplace's method, integral equation, and FORTRAN main program", "Taylor's method, difference equation, and FORTRAN main program"], "answer": "B", "solution": "(a) Euler's method assumes that during the interval (x,x+\\Deltax),dy/dx remains constant and that \\Deltay/\\Deltax=dy/dx= f(x,y) \\Rightarrow\\Deltay=\\Deltaxf(x,y). Thus, y_new=y_old+\\Deltay=y_old+\\Deltaxf(x_old_ ,y_old). Or, stating this as a difference equation: yn+1=y_n+\\Deltaxf(x_n,y_n)(1) forn = 0,1,...,N. The FORTRAN main program is: READ N, DELTAX,X,Y PRINT, T,X,Y DO 1\\O I = 1,N X = X + DELTAX CUSE EQUATION (1) Y= Y + DELTAX \\textasteriskcentered F(X,Y) PRINT, X,Y 1\\OCONTINUE STOP END Note: F(X,Y) must be defined in a FUNCTION subprogram (b) Rewrite the equation as a system of simultaneous first-order equations:y' =dy/dx= z z' =dz/dx= g(x,y,z) with initial conditions y(x_0) = y_0 and z(x_0) = y'(x_0) = y'_0 The FORTRAN main program is: READ, N, DELTAX,X,X,Z PRINT, X,Y,Z DO 1\\O I = 1,NZPRIME = G(X,Y,Z) X = X + DELTAX Y = Y + DELTAX \\textasteriskcentered Z Z = Z + DELTAX \\textasteriskcentered ZPRIME PRINT, X,Y,Z 10CONTINUE STOP END Note:Again, G(X,Y,Z) must be defined. Also, for a fixed value of Ax, the error increases as \\vertx - x_0\\vert increases. In addition, for a fixed value ofx_n, the error increases as\\Deltaxincreases and is of order (\\Deltax)^2 ."}, "question": "task_1"}}, {"data": {"text": "Question:\nWrite a program using PL / I, to sort an integer array into ascending order using a bubble sort.\n\nOptions:\nA. QUICK-SORT Program\nB. MERGE-SORT Program\nC.             INSERTION-SORT Program\nD. BUBBLE-SORT Program\n\nAnswer: D\n\nReference Solution:\nBUBBLE-SORT Program INTEGER I, J, K, ID (N), TEMP /\\textasteriskcentered THE CONTENTS OF THE ARRAY ID AND ITS DIMENSION N ARE ASSUMED GIVEN \\textasteriskcentered / I = N; K = 1;/ \\textasteriskcentered K IS FLAG \\not = 0 ON THE FIRST PASS AND WHEN SWITCHES ARE MADE ON THE PREVIOUS PASS \\textasteriskcentered / DO WHILE (I \\geq 2) AND K \\not = 0; J = 1; K = 0; DO WHILE (J \\leq I - 1); IF ID (J) > ID (J + l) THEN DO, TEMP = ID (J); ID (J) = ID (J + 1); ID (J + 1) = TEMP; / \\textasteriskcentered SWITCH ENTRIES ID (J) & ID (J + 1) \\textasteriskcentered / K = 1; END If; J = J + 1; END DO; I = I - 1;/ \\textasteriskcentered COUTER I DECREMTED FROM N TO 2 ON SUCCESSIVE PASSES \\textasteriskcentered / END DO; END BUBBLE.SORT;", "ref_id": 4646, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Write a program using PL / I, to sort an integer array into ascending order using a bubble sort.", "options": ["QUICK-SORT Program", "MERGE-SORT Program", "INSERTION-SORT Program", "BUBBLE-SORT Program"], "answer": "D", "solution": "BUBBLE-SORT Program INTEGER I, J, K, ID (N), TEMP /\\textasteriskcentered THE CONTENTS OF THE ARRAY ID AND ITS DIMENSION N ARE ASSUMED GIVEN \\textasteriskcentered / I = N; K = 1;/ \\textasteriskcentered K IS FLAG \\not = 0 ON THE FIRST PASS AND WHEN SWITCHES ARE MADE ON THE PREVIOUS PASS \\textasteriskcentered / DO WHILE (I \\geq 2) AND K \\not = 0; J = 1; K = 0; DO WHILE (J \\leq I - 1); IF ID (J) > ID (J + l) THEN DO, TEMP = ID (J); ID (J) = ID (J + 1); ID (J + 1) = TEMP; / \\textasteriskcentered SWITCH ENTRIES ID (J) & ID (J + 1) \\textasteriskcentered / K = 1; END If; J = J + 1; END DO; I = I - 1;/ \\textasteriskcentered COUTER I DECREMTED FROM N TO 2 ON SUCCESSIVE PASSES \\textasteriskcentered / END DO; END BUBBLE.SORT;"}, "question": "task_1"}}, {"data": {"text": "Question:\nA PL/I program has variables U, V, W, X, Y, Z which are de-claredas follows: DCL UBIT(4),V FIXED (4,1), WCHAR(5),X FLOAT(4), YCHAR(3),Z FIXED(3); The Data Card for the same program contains the following in-formation: U = '1101'B, V = 981\\textbullet2; U = '1101'B, V = 123\\textbullet4, W = '123\\textbullet4', X = \\textbullet1052E + 02, Y = 'PQR', Z = - 249; a) Show what will be entered into memory storage in the com-puteras a result of the statements: GET DATA; followed alittle later in the program by the statement: GETDATA(Z,V,W,Y,U,X) ; b) In the same program at a later stage, the contents of the memorylocations corresponding to U, V, W, X, Y and Z werechanged to 0100 769\\textbullet2 144\\textbullet7 \\textbullet0129E - 03 BOG - 47 respectively. Show what will be printed out by the following statements: PUTDATA(U,Y); PUT SKIP DATA(X); PUT SKIPDATA(W,V,Z);\n\nOptions:\nA. U = '0100', Y = ' BOG', X = 0.0129E - 03, W = '144.7', V = 769.2, Z = - 47\nB. U = '1101', Y = 'PQR', X = 0.1052E + 02, W = '123.4', V = 981.2, Z = - 249\nC.             U = '0100', Y = ' BOG', X = 0.1052E + 02, W = '144.7', V = 769.2, Z = - 47\nD. U = '1101', Y = 'PQR', X = 0.0129E - 03, W = '123.4', V = 981.2, Z = - 249\n\nAnswer: A\n\nReference Solution:\na) The GET DATA; statement reads in the values of all the variablesavailable up to the first .semi-colon on the card. Hence, the memorystorage is filled in with con-tents as follows: Name of memory location Content of the memory location U 1101 V 981.2 W X Y Z The next statement, which is GET DATA (U,V,W,X,Y,Z); will read in the valuesof the variables up to the next semicolon on the data card. If the newvalues of the variables are different, the memory contents will be changedaccordingly. Hence, the latest memory contents are as follows: Name of memory location Content of the memory location U 1101 V 123.4 W 123.4 X \\textbullet1052e + 02 Y PQR Z - 249 b) As a result of the PUT DATA statements, the following is printed out: U = '0100'BY = ' BOG'; U = '0100'BY = ' BOG'; (BLANK LINE) X = \\textbullet0129E - 03; (BLANK LINE) W = '144\\textbullet7'V = 769\\textbullet2Z = - 47;", "ref_id": 4647, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "A PL/I program has variables U, V, W, X, Y, Z which are de-claredas follows: DCL UBIT(4),V FIXED (4,1), WCHAR(5),X FLOAT(4), YCHAR(3),Z FIXED(3); The Data Card for the same program contains the following in-formation: U = '1101'B, V = 981\\textbullet2; U = '1101'B, V = 123\\textbullet4, W = '123\\textbullet4', X = \\textbullet1052E + 02, Y = 'PQR', Z = - 249; a) Show what will be entered into memory storage in the com-puteras a result of the statements: GET DATA; followed alittle later in the program by the statement: GETDATA(Z,V,W,Y,U,X) ; b) In the same program at a later stage, the contents of the memorylocations corresponding to U, V, W, X, Y and Z werechanged to 0100 769\\textbullet2 144\\textbullet7 \\textbullet0129E - 03 BOG - 47 respectively. Show what will be printed out by the following statements: PUTDATA(U,Y); PUT SKIP DATA(X); PUT SKIPDATA(W,V,Z);", "options": ["U = '0100', Y = ' BOG', X = 0.0129E - 03, W = '144.7', V = 769.2, Z = - 47", "U = '1101', Y = 'PQR', X = 0.1052E + 02, W = '123.4', V = 981.2, Z = - 249", "U = '0100', Y = ' BOG', X = 0.1052E + 02, W = '144.7', V = 769.2, Z = - 47", "U = '1101', Y = 'PQR', X = 0.0129E - 03, W = '123.4', V = 981.2, Z = - 249"], "answer": "A", "solution": "a) The GET DATA; statement reads in the values of all the variablesavailable up to the first .semi-colon on the card. Hence, the memorystorage is filled in with con-tents as follows: Name of memory location Content of the memory location U 1101 V 981.2 W X Y Z The next statement, which is GET DATA (U,V,W,X,Y,Z); will read in the valuesof the variables up to the next semicolon on the data card. If the newvalues of the variables are different, the memory contents will be changedaccordingly. Hence, the latest memory contents are as follows: Name of memory location Content of the memory location U 1101 V 123.4 W 123.4 X \\textbullet1052e + 02 Y PQR Z - 249 b) As a result of the PUT DATA statements, the following is printed out: U = '0100'BY = ' BOG'; U = '0100'BY = ' BOG'; (BLANK LINE) X = \\textbullet0129E - 03; (BLANK LINE) W = '144\\textbullet7'V = 769\\textbullet2Z = - 47;"}, "question": "task_1"}}, {"data": {"text": "Question:\nLook at the followingpseudocodedprogram. Can you think of an instance in which the program would get stuck in an infinite loop ? Modify the program to deal with this possibility. integer N, NSUM NSUM \\leftarrow 0 input N do while N \\not = 0 NSUM \\leftarrow NSUM + N N \\leftarrow N - 1 end do while output NSUM end program\n\nOptions:\nA. Include an IF-THEN-ELSE clause in the DO-WHILE construct\nB. Use a recursive function instead of a loop\nC.             Add a break statement after N becomes 0\nD. Use a FOR loop instead of DO-WHILE\n\nAnswer: A\n\nReference Solution:\nA problem arises if N is a negative number. Say we input for N the value -6. On the initial pass through the loop, NSUM takes on a value of -6. But when the next statement is encountered, N becomes -7. The loop will continue to decrement the value of N so that N will never equal 0. Hence, the loop is Infinite as written. Probably the programmer wants to sum the digits between -6 and 0. To accomplish this, we can include an IF-THEN-ELSE clause in the DO- WHILE construct: do while N \\not = 0 NSUM \\leftarrow NSUM + N if N < 0 then N \\leftarrow N + 1 else N \\leftarrow N - 1 end if end do while Now the program can handle both positive and negative values of N.", "ref_id": 4648, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Look at the followingpseudocodedprogram. Can you think of an instance in which the program would get stuck in an infinite loop ? Modify the program to deal with this possibility. integer N, NSUM NSUM \\leftarrow 0 input N do while N \\not = 0 NSUM \\leftarrow NSUM + N N \\leftarrow N - 1 end do while output NSUM end program", "options": ["Include an IF-THEN-ELSE clause in the DO-WHILE construct", "Use a recursive function instead of a loop", "Add a break statement after N becomes 0", "Use a FOR loop instead of DO-WHILE"], "answer": "A", "solution": "A problem arises if N is a negative number. Say we input for N the value -6. On the initial pass through the loop, NSUM takes on a value of -6. But when the next statement is encountered, N becomes -7. The loop will continue to decrement the value of N so that N will never equal 0. Hence, the loop is Infinite as written. Probably the programmer wants to sum the digits between -6 and 0. To accomplish this, we can include an IF-THEN-ELSE clause in the DO- WHILE construct: do while N \\not = 0 NSUM \\leftarrow NSUM + N if N < 0 then N \\leftarrow N + 1 else N \\leftarrow N - 1 end if end do while Now the program can handle both positive and negative values of N."}, "question": "task_1"}}, {"data": {"text": "Question:\nWrite a subprogram in FORTRAN to add two numbers in any baseK. Use the arrays L(I) and M(I) for I = 2,3,4...30 to store thedigits of the numbers, saving L(l) and M(l) for the sign. Also letN(I) hold the answer, with N(l) for the sign.\n\nOptions:\nA. SUBROUTINE MULTIPLY(L,M,N,K)\nB. SUBROUTINE DIVIDE(L,M,N,K)\nC.             SUBROUTINE ADD(L,M,N,K)\nD. FUNCTION ADD(L,M,N,K)\n\nAnswer: C\n\nReference Solution:\nFirst you must decide which way the digits are to be added. In other words, you could enter the sum of 4379 + 2512 as either: L(2)L(3)L(4)L(5) 4379 +M(2)M(3)M(4)M(5) 2512 oras L(30)L(29)L(28)L(27) 9734 +M(30)M(29)M(28)M(27) 2152 We will use the latter example, because it leaves us room for an over-flowon the final digit. Hence, we need a decrementing loop. Also noticethat the maximum number of digits we can have is 28 because of thisoverflow problem. SUBROUTINEADD(L,M,N,K) INTEGER L( L( 3\\O), M(3\\O), N(3\\O), K 3\\O), M(3\\O), N(3\\O), K NN = 3\\O NN = 3\\O DO 2\\O J = 2, NN DO 2\\O J = 2, NN I = NN - J + 1 I = NN - J + 1 15N(I) = L(I) + M(I) N( I) = L(I) + M(I) IF (N(I). LT.K) GO TO 20 N(I) = N(I) - K N(I - 1) = L(I - 1) + M(I - 1) + 1 I = I - 1 GO TO 15 2\\OCONTINUE", "ref_id": 4649, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Write a subprogram in FORTRAN to add two numbers in any baseK. Use the arrays L(I) and M(I) for I = 2,3,4...30 to store thedigits of the numbers, saving L(l) and M(l) for the sign. Also letN(I) hold the answer, with N(l) for the sign.", "options": ["SUBROUTINE MULTIPLY(L,M,N,K)", "SUBROUTINE DIVIDE(L,M,N,K)", "SUBROUTINE ADD(L,M,N,K)", "FUNCTION ADD(L,M,N,K)"], "answer": "C", "solution": "First you must decide which way the digits are to be added. In other words, you could enter the sum of 4379 + 2512 as either: L(2)L(3)L(4)L(5) 4379 +M(2)M(3)M(4)M(5) 2512 oras L(30)L(29)L(28)L(27) 9734 +M(30)M(29)M(28)M(27) 2152 We will use the latter example, because it leaves us room for an over-flowon the final digit. Hence, we need a decrementing loop. Also noticethat the maximum number of digits we can have is 28 because of thisoverflow problem. SUBROUTINEADD(L,M,N,K) INTEGER L( L( 3\\O), M(3\\O), N(3\\O), K 3\\O), M(3\\O), N(3\\O), K NN = 3\\O NN = 3\\O DO 2\\O J = 2, NN DO 2\\O J = 2, NN I = NN - J + 1 I = NN - J + 1 15N(I) = L(I) + M(I) N( I) = L(I) + M(I) IF (N(I). LT.K) GO TO 20 N(I) = N(I) - K N(I - 1) = L(I - 1) + M(I - 1) + 1 I = I - 1 GO TO 15 2\\OCONTINUE"}, "question": "task_1"}}, {"data": {"text": "Question:\na) .1_10 = (.19999...)_16 b) .875_10 = (.513)_6 c) .2_10 = (.001100110011...)_2\n\nOptions:\nA. .1_10 = (.19999...)_16, .875_10 = (.512)_6, .2_10 = (.001100110011...)_2\nB. .1_10 = (.19999...)_16, .875_10 = (.514)_6, .2_10 = (.001100110010...)_2\nC.             .1_10 = (.19999...)_15, .875_10 = (.513)_6, .2_10 = (.001100110011...)_2\nD. .1_10 = (.19999...)_16, .875_10 = (.513)_6, .2_10 = (.001100110011...)_2\n\nAnswer: D\n\nReference Solution:\na) To convert fractions from decimal to hexadecimal, we begin the followingprocedure: Multiply the base you want (in this case 16) by the fractionto be converted. .100 \u00d7 16 = 1.600 Now, the first digit to the left of the decimal point becomes the first digit to theright of the hexadecimal point. Thus, we begin constructing our hexadecimalfraction with .1 . Subtract the first digit from the product obtained above. 1.600 - 1.000 .600 Repeat the multiplication process. Then you will have obtained the next digitof the hexadecimal fraction. .600 \u00d7 16 = 9.600 The digit 9 becomes the next digit on the right side of the hexadecimal point. Do the subtraction as before and you will see that our fraction is now.19. The process will repeat infinitely because there will always be a remainderleft from the subtraction. Hence, we prove the original equality. b) In general, we can express a fraction f converted to base b as the following: f = a_-1 \u00d7 b^-1 + a_-2 \u00d7 b^-2 + a_-3 \u00d7 b^-3+ ... wherea_-1, a_-2,... are digits from 0 to b - 1. If we do this for .875_10, we get thesethree steps: Multiplying .875 by 6 yields the integer 5 plus the fraction.250. Multiplying .250 by 6 yields the integer 1 plus the fraction .500. Multiplying .500 by 6 yields the Integer part 3 plus the fraction .000. Putting this all together, we prove that .875_10 = (.513)_6. c) Conversions from decimal to binary are simple, but the student often getscaught up in the tedium of writing only 1's and 0's. For this ex-ample, wewill bore you only with the first four steps, since the digits repeat after thatanyway: Multiplying .2 by 2 yields the integer 0 plus the fraction.4. Multiplying .4 by 2 yields the integer 0 plus the fraction.8. Multiplying .8 by 2 yields the integer 1 plus the fraction.6. Multiplying .6 by 2 yields the integer 1 plus the fraction.2. Another notation for repeating digitsis todraw a line over those digitswhich repeat. Hence, .2 = (.00110011)_2-.", "ref_id": 4650, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "a) .1_10 = (.19999...)_16 b) .875_10 = (.513)_6 c) .2_10 = (.001100110011...)_2", "options": [".1_10 = (.19999...)_16, .875_10 = (.512)_6, .2_10 = (.001100110011...)_2", ".1_10 = (.19999...)_16, .875_10 = (.514)_6, .2_10 = (.001100110010...)_2", ".1_10 = (.19999...)_15, .875_10 = (.513)_6, .2_10 = (.001100110011...)_2", ".1_10 = (.19999...)_16, .875_10 = (.513)_6, .2_10 = (.001100110011...)_2"], "answer": "D", "solution": "a) To convert fractions from decimal to hexadecimal, we begin the followingprocedure: Multiply the base you want (in this case 16) by the fractionto be converted. .100 \u00d7 16 = 1.600 Now, the first digit to the left of the decimal point becomes the first digit to theright of the hexadecimal point. Thus, we begin constructing our hexadecimalfraction with .1 . Subtract the first digit from the product obtained above. 1.600 - 1.000 .600 Repeat the multiplication process. Then you will have obtained the next digitof the hexadecimal fraction. .600 \u00d7 16 = 9.600 The digit 9 becomes the next digit on the right side of the hexadecimal point. Do the subtraction as before and you will see that our fraction is now.19. The process will repeat infinitely because there will always be a remainderleft from the subtraction. Hence, we prove the original equality. b) In general, we can express a fraction f converted to base b as the following: f = a_-1 \u00d7 b^-1 + a_-2 \u00d7 b^-2 + a_-3 \u00d7 b^-3+ ... wherea_-1, a_-2,... are digits from 0 to b - 1. If we do this for .875_10, we get thesethree steps: Multiplying .875 by 6 yields the integer 5 plus the fraction.250. Multiplying .250 by 6 yields the integer 1 plus the fraction .500. Multiplying .500 by 6 yields the Integer part 3 plus the fraction .000. Putting this all together, we prove that .875_10 = (.513)_6. c) Conversions from decimal to binary are simple, but the student often getscaught up in the tedium of writing only 1's and 0's. For this ex-ample, wewill bore you only with the first four steps, since the digits repeat after thatanyway: Multiplying .2 by 2 yields the integer 0 plus the fraction.4. Multiplying .4 by 2 yields the integer 0 plus the fraction.8. Multiplying .8 by 2 yields the integer 1 plus the fraction.6. Multiplying .6 by 2 yields the integer 1 plus the fraction.2. Another notation for repeating digitsis todraw a line over those digitswhich repeat. Hence, .2 = (.00110011)_2-."}, "question": "task_1"}}, {"data": {"text": "Question:\nExplain how initialization is done for array variables. Can the statementDCL A(8) FIXED(3) INIT(0) initialize the ele-ments ofthe array A?\n\nOptions:\nA. No, it does not initialize any element.\nB. Yes, it initializes all elements to 1.\nC.             Yes, it initializes all elements to 0.\nD. No, it only initializes the first element to 0.\n\nAnswer: D\n\nReference Solution:\nIn the case of an array, each element of the array must be explicitly initialized. For example, DCLA(8) FIXED(3) INIT((8)0); In the above statement ((8)0) means that all 8 elements are initialized to zero. The given statement DCLA(8) FIXED(3) INIT(O); cannot initialize allthe elements of the array A. It means that only the first element is initializedto 0. The remaining seven elements have no specified initial value. DCL A (2:6, 3:5)FLOAT(3) INIT((9),2); meansthat the first 9 elements are initialized to a value of 2 in the floating pointform. That is, the initial values of the first nine elements are stored in thecomputer memory as 0\\textbullet200E+01. Now, the arrayA(2:6, 3:5)has a total numberof elements = (6 - (2 - 1)) \u00d7 (5 - (3 - 1)) = (6 - 1) \u00d7 (5 - 2) = 5 \u00d7 3 = 15 elements. This means that the remaining (15 - 9) = 6 elements have no ini-tial values specified. Moreover, if a ROW MAJOR ORDER is followed in numbering the arrayelements, as is usual, then, ElementsA(2,3),A(2,4),A(2,5), A(3,3),A(3,4),A(3,5), A(4,3),A(4,4),A(4,5), eachhave an initial value of 0\\textbullet200E + 01. And, ElementsA(5,3),A(5,4),A(5,5), A(6,3),A(6,4),A(6,5), haveno initial values specified for them. Finally, consider the following array declaration: DCLB(2,3,2) FIXED(2) INIT((5)0,(4)1,(3)2); In the above, array B is a 2\u00d73\u00d72 = 12 element array. The ele-ments have a FIXED(2) attribute. The initial values of the first 5 elements are stored as 00; of the next 4 elements as 01; and of the last 3 elements as 02. That is, B(1,1,1),B(1,1,2),B(1,2,1),B(1,2,2) and B(1,3,1) have an initialvalue of 0. And, B(1,3,2),B(2,1,1), B.(2,1,2) and B (2,2,1) have an initial value of 1, while B(2,2,2),B(2,3,1) and B(2,3,2) have an initial value of 2.", "ref_id": 4651, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Explain how initialization is done for array variables. Can the statementDCL A(8) FIXED(3) INIT(0) initialize the ele-ments ofthe array A?", "options": ["No, it does not initialize any element.", "Yes, it initializes all elements to 1.", "Yes, it initializes all elements to 0.", "No, it only initializes the first element to 0."], "answer": "D", "solution": "In the case of an array, each element of the array must be explicitly initialized. For example, DCLA(8) FIXED(3) INIT((8)0); In the above statement ((8)0) means that all 8 elements are initialized to zero. The given statement DCLA(8) FIXED(3) INIT(O); cannot initialize allthe elements of the array A. It means that only the first element is initializedto 0. The remaining seven elements have no specified initial value. DCL A (2:6, 3:5)FLOAT(3) INIT((9),2); meansthat the first 9 elements are initialized to a value of 2 in the floating pointform. That is, the initial values of the first nine elements are stored in thecomputer memory as 0\\textbullet200E+01. Now, the arrayA(2:6, 3:5)has a total numberof elements = (6 - (2 - 1)) \u00d7 (5 - (3 - 1)) = (6 - 1) \u00d7 (5 - 2) = 5 \u00d7 3 = 15 elements. This means that the remaining (15 - 9) = 6 elements have no ini-tial values specified. Moreover, if a ROW MAJOR ORDER is followed in numbering the arrayelements, as is usual, then, ElementsA(2,3),A(2,4),A(2,5), A(3,3),A(3,4),A(3,5), A(4,3),A(4,4),A(4,5), eachhave an initial value of 0\\textbullet200E + 01. And, ElementsA(5,3),A(5,4),A(5,5), A(6,3),A(6,4),A(6,5), haveno initial values specified for them. Finally, consider the following array declaration: DCLB(2,3,2) FIXED(2) INIT((5)0,(4)1,(3)2); In the above, array B is a 2\u00d73\u00d72 = 12 element array. The ele-ments have a FIXED(2) attribute. The initial values of the first 5 elements are stored as 00; of the next 4 elements as 01; and of the last 3 elements as 02. That is, B(1,1,1),B(1,1,2),B(1,2,1),B(1,2,2) and B(1,3,1) have an initialvalue of 0. And, B(1,3,2),B(2,1,1), B.(2,1,2) and B (2,2,1) have an initial value of 1, while B(2,2,2),B(2,3,1) and B(2,3,2) have an initial value of 2."}, "question": "task_1"}}, {"data": {"text": "Question:\nExplain the 'END OF FILE Condition' method of ending a Explain the 'END OF FILE Condition' method of ending a programin PL/I.\n\nOptions:\nA. The end-file condition occurs when the file is not found\nB. The end-file condition occurs when the file is corrupted\nC.             The end-file condition occurs when the file is empty\nD. The end-file condition occurs when an attempt is made to acquire data from the input file after the last data from the file has already been read.\n\nAnswer: D\n\nReference Solution:\nThe end-file condition occurs when an attempt is made to acquire datafrom the input file after the last data from the file has already been read. Hence, this end of the file condition has to be specified for the computerby using the key-word ENDFILE, followed by parentheses containingthe name of the file. The file in question could be a deck of cards being v read in througha card reader, in which case we will use the form: ON ENDFILE(SYSIN)... This way we tell the computer what to do when the end- file conditionis reached. For example, the statement: ONENDFILE(SYSIN) GOTO FINISH; tellsthe computer to go to a statementlabelled'FINISH' when the ENDFILE condition is reached on the SYSIN FILE. The following program illustrates the use of thisstate-ment : SUM: PROCOPTIONS(MAIN); DCL (X,SUM)FIXED(4)INIT(0); ONENDFILE(SYSIN) GOTO FINISH; LOOP: GET LIST(X); SUM=SUM+X; GOTO LOOP; FINISH: PUTLIST(SUM); /\\textasteriskcentered WE KEEP REPEATING THE LOOP, UNTIL FINALLY WE FIND THAT WHEN THE GET LIST(X) STATEMENT IS EXECUTED, THERE IS NO MORE DATA X LEFT TO BE FETCHED. NOW THE COMPUTER REMEMBERS THAT BEFORE IT HAD STARTED EXECUTING THE LOOPS, IT HAD ALREADY BEEN TOLD THAT ON ENDFILE CONDITION, IT SHOULD GO TO THE STATEMENT LABELLED 'FINISH'.SO THIS IS WHAT IT DOES \\textasteriskcentered/ END SUM; Note: The best place for inserting the ENDFILE condition statement is afterthe DCL statement but beforetheGET LIST statement, so that the computer will read it before it does any GET LIST.", "ref_id": 4652, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Explain the 'END OF FILE Condition' method of ending a Explain the 'END OF FILE Condition' method of ending a programin PL/I.", "options": ["The end-file condition occurs when the file is not found", "The end-file condition occurs when the file is corrupted", "The end-file condition occurs when the file is empty", "The end-file condition occurs when an attempt is made to acquire data from the input file after the last data from the file has already been read."], "answer": "D", "solution": "The end-file condition occurs when an attempt is made to acquire datafrom the input file after the last data from the file has already been read. Hence, this end of the file condition has to be specified for the computerby using the key-word ENDFILE, followed by parentheses containingthe name of the file. The file in question could be a deck of cards being v read in througha card reader, in which case we will use the form: ON ENDFILE(SYSIN)... This way we tell the computer what to do when the end- file conditionis reached. For example, the statement: ONENDFILE(SYSIN) GOTO FINISH; tellsthe computer to go to a statementlabelled'FINISH' when the ENDFILE condition is reached on the SYSIN FILE. The following program illustrates the use of thisstate-ment : SUM: PROCOPTIONS(MAIN); DCL (X,SUM)FIXED(4)INIT(0); ONENDFILE(SYSIN) GOTO FINISH; LOOP: GET LIST(X); SUM=SUM+X; GOTO LOOP; FINISH: PUTLIST(SUM); /\\textasteriskcentered WE KEEP REPEATING THE LOOP, UNTIL FINALLY WE FIND THAT WHEN THE GET LIST(X) STATEMENT IS EXECUTED, THERE IS NO MORE DATA X LEFT TO BE FETCHED. NOW THE COMPUTER REMEMBERS THAT BEFORE IT HAD STARTED EXECUTING THE LOOPS, IT HAD ALREADY BEEN TOLD THAT ON ENDFILE CONDITION, IT SHOULD GO TO THE STATEMENT LABELLED 'FINISH'.SO THIS IS WHAT IT DOES \\textasteriskcentered/ END SUM; Note: The best place for inserting the ENDFILE condition statement is afterthe DCL statement but beforetheGET LIST statement, so that the computer will read it before it does any GET LIST."}, "question": "task_1"}}, {"data": {"text": "Question:\nWrite an APL program to build 10 rows of Pascal's triangle.\n\nOptions:\nA. \nablaPASCAL [1]P \\leftarrow 1 [2]P [3]\nightarrow 2 \u00d7 N \\geq\nho\\Rho\\leftarrow (0,P) + (P,0) \nabla\nB. \nablaPASCAL [1]P \\leftarrow 1 [2]P [3]\nightarrow 2 \u00d7 N \\geq\nho\\Rho\\leftarrow (0,P) + (P,0)\nC.             P \\leftarrow 1 [2]P [3]\nightarrow 2 \u00d7 N \\geq\nho\\Rho\\leftarrow (0,P) + (P,0)\nD. \nablaPASCAL [1]P \\leftarrow 1 [2]P [3]\nightarrow 2 \u00d7 N \\geq\nho\\Rho\\leftarrow (P,0) + (0,P) \nabla\n\nAnswer: A\n\nReference Solution:\nEach row ofpascal'striangle is a set of binomial coefficients of (x + y)^n-1, n > 0. Another way of representing these coefficients is (^N_K) for N = 1,2,....., and for K = 0, 1, 2,..., such that (^N_K) = [n!] / [K!(N - K)!] or,= [N(N-1) .... (N-K+1)] / [K!] Our strategy rests on the fact that each number in the triangle is the sum of two numbers right above it. For ex-ample, let us take rows 1 to 5. ROWS N = 11K = 0 N = 211K = 1 N = 3121K = 2 N = 41331K = 3 N = 514641K = 4 To get from row 4 to row 5, we can do the following: ROW 41331 +1331 14641 By taking a row, moving it one place to the right, and then adding it to itself, we can generate the next row. In APL, the symbol used for catenation is the comma. Catenation means \"chaining\" elements together. This can be done by the statement P \\leftarrow (0,P) + (P,0) . This statement will do the following: 01331 +13310 A zerocatenatedwith string P in (0,P) part, moves P one place to the right, while the zero in the second part, (P,0), just adds itself to the string P. Then, the addition is performed, and the new row is created. The program is given below: \\nablaPASCAL [1]P \\leftarrow 1 [2]P [3]\\rightarrow 2 \u00d7 N \\geq\\rho\\Rho\\leftarrow (0,P) + (P,0) \\nabla Line [3] contains the symbol \\rho, which is called the re-shaping operator. When you enter the value for N (in this case, N = 10), \\rho determines the number of times P \\leftarrow (0,P) + (P,0) is to be executed. When ten branches have been execut-ed, the comparison N \\geq \\rho will be false or, in APL, it will have the value zero. This zero will then be multiplied by 2 telling the program to branch to instruction zero, which is the way of indicating the termination of the program.", "ref_id": 4653, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Write an APL program to build 10 rows of Pascal's triangle.", "options": ["\nablaPASCAL [1]P \\leftarrow 1 [2]P [3]\nightarrow 2 \u00d7 N \\geq\nho\\Rho\\leftarrow (0,P) + (P,0) \nabla", "\nablaPASCAL [1]P \\leftarrow 1 [2]P [3]\nightarrow 2 \u00d7 N \\geq\nho\\Rho\\leftarrow (0,P) + (P,0)", "P \\leftarrow 1 [2]P [3]\nightarrow 2 \u00d7 N \\geq\nho\\Rho\\leftarrow (0,P) + (P,0)", "\nablaPASCAL [1]P \\leftarrow 1 [2]P [3]\nightarrow 2 \u00d7 N \\geq\nho\\Rho\\leftarrow (P,0) + (0,P) \nabla"], "answer": "A", "solution": "Each row ofpascal'striangle is a set of binomial coefficients of (x + y)^n-1, n > 0. Another way of representing these coefficients is (^N_K) for N = 1,2,....., and for K = 0, 1, 2,..., such that (^N_K) = [n!] / [K!(N - K)!] or,= [N(N-1) .... (N-K+1)] / [K!] Our strategy rests on the fact that each number in the triangle is the sum of two numbers right above it. For ex-ample, let us take rows 1 to 5. ROWS N = 11K = 0 N = 211K = 1 N = 3121K = 2 N = 41331K = 3 N = 514641K = 4 To get from row 4 to row 5, we can do the following: ROW 41331 +1331 14641 By taking a row, moving it one place to the right, and then adding it to itself, we can generate the next row. In APL, the symbol used for catenation is the comma. Catenation means \"chaining\" elements together. This can be done by the statement P \\leftarrow (0,P) + (P,0) . This statement will do the following: 01331 +13310 A zerocatenatedwith string P in (0,P) part, moves P one place to the right, while the zero in the second part, (P,0), just adds itself to the string P. Then, the addition is performed, and the new row is created. The program is given below: \\nablaPASCAL [1]P \\leftarrow 1 [2]P [3]\\rightarrow 2 \u00d7 N \\geq\\rho\\Rho\\leftarrow (0,P) + (P,0) \\nabla Line [3] contains the symbol \\rho, which is called the re-shaping operator. When you enter the value for N (in this case, N = 10), \\rho determines the number of times P \\leftarrow (0,P) + (P,0) is to be executed. When ten branches have been execut-ed, the comparison N \\geq \\rho will be false or, in APL, it will have the value zero. This zero will then be multiplied by 2 telling the program to branch to instruction zero, which is the way of indicating the termination of the program."}, "question": "task_1"}}, {"data": {"text": "Question:\nWrite a program which counts the number of times each letter is used in input text.\n\nOptions:\nA. Python program\nB. SNOBOL IV program\nC.             C++ program\nD. Java program\n\nAnswer: B\n\nReference Solution:\n1&TRTM = 1 2CHAR = LEN(1) .CH 3LETTERS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 4COUNT = TABLE (30) 5READOUTPUT = INPUT:F(DISPLAY) 6TEXT = OUTPUT 7NEXTTEXT CHAR =:F(READ) 8COUNT <CH> = COUNT <CH> + 1:(NEXT) 9DISPLAYOUTPUT = 10LOOPLETTERS CHAR =: F (END) 11OUTPUT = NE(COUNT<CH>) CH 'OCCURS' +COUNT <CH> 'TIMES'(LOOP) 12END The first statement includes a keyword '&TRIM'. Keywords in SNOBGL IV allow access to several parameters and switches internal to the SNOBOL IV system. Keywords begin with ampersand (&) followed by certain identifiers. For example, keyword &TRIM controls the handling of trailing blanks on input of data. If the value of &TRIM is nonzero, trailing blanks are deleted. Other keywords will be explained upon occurrence in the programs. The second statement, CHAR = LEN (1). CH, includes two important features. First, LEN (1), is an example of primitive (Built-in) functions. This function returns a pattern that matches any string of the length specified by the integer in parentheses. INPUT, PUNCH, and OUTPUT are some other primitive functions. The second important feature of the second statement is that it is an example of conditional value assignment (in this case .CH). The conditional value assignment operator (.) is separated from its operands by blanks. In the state-ment CHAR = LEN (1) . CH, variable CHAR is assigned the very first found string of length one, and, in case of success, assigns the same string to CH, which is used as an array subscript later in the program. The fourth statement, COUNT = TABLE (30), introduces the use of tables. Tables of variables can be created by using the primitive function TABLE, for example: T = TABLE ( ) In a very similar way arrays of variables are constructed by using the primitive function ARRAY, for example: A = ARRAY ( ) The arguments of an array, written in parentheses, describe the number of dimensions, the bounds of each dimension, and the initial value of each variable in the array. Thus A = ARRAY (10,1.0) creates and assigns to Aaone-dimensional array of 10 variables, each initialized to the real value 1.0. A table is similar to a one-dimensional array. However, instead of referencing an element with an integer, any data object can be used. In this program, letters of the alphabet are used as subscripts for table elements. The fifth statement of the program introduces the most important feature of the flow of control - a transfer to alabelledstatement. It is specified in the GOTO field which appears at the end of a statement and is separated from the rest of the statement by a colon. Two types of transfers can be specified in the GOTO field: conditional and unconditional, A conditional transfer consists of letters F or S corresponding to failure or success respectively, followed by a label enclosed within parentheses. Thus OUTPUT = INPUT: F(DISPLAY) makes the computerprint outwhatever appears on the data card. If, however, there is no data in the input file, i.e., an end of file is encountered, the transfer is made to the statement labeled display. An unconditional transfer is indicated by the absence of an F or S before the enclosing parentheses. For example, consider state-ment #8 of this program: COUNT<CH> = COUNT<CH> + 1: (NEXT) Each time this statement is executed, the transfer is made to the statementlabelledNEXT. Statement #11 uses one of the primitive functions of a specific group called NUMERICAL PREDICATES. The main ones include: LT - less than... LE - less than or equal to... EQ - equal to... NE - not equal to... GE - greater or equal to... GT - greater than... Statement OUTPUT = NE (COUNT<CH>).... prints out whatever is following the parentheses if the value of COUNT<CH> is not equal to zero. Finally, a statement that is longer than one line can be continued onto successive lines by starting the continuation lines with a period or plus sign. This program employs a plus sign for continua-tion of statement #11. Also note, that the statements in this program are numbered only for easy reference. All labels in SNOBCL IV start with a letter, as was mentioned earlier. If a statement does not start with a label, it must start with at least one blank. The general flow of this program is as follows: statement 1 - deletes trailing blanks; statement 2 - indicates that CHAR and CH will be assigned the first one-character string matched; statement 3 - assigns a string of the 26 letters of the alphabet to variable LETTERS; statement 4 - sets a 30-element table and assigns it to COUNT; statement 5 - prints out the first card of the input text; statement 6 - assigns it to variable TEXT; statement 7 - tests the text for presence of the first one-character string (which is the first letter of the first word in the text), deletes them all one at a time, adding 1 to COUNT<CH> in statement 8 each time around; statement 8 - goes back to statement 7 every time after adding 1 to COUNT<CH>; statement 7 - repeats the loop until all the appearances of each letter are counted, and the table COUNT is set up. Then COUNT fails when no more characters are left; the transfer is made back to statement #5; statement 5 - repeats the whole procedure for every following input card, adding missing members (if there are any) to the table COUNT. Finally it fails when there is no input left and transfers the execution to statement #9; statement 9 - prints a blank line; statement 10 - tests string LETTERS for the presence of a one- character string, finds 26 of them, assigns the first one (i.e., A) to CHAR and deletes it from LETTERS; statement 11 - since CH takes the same value as CHAR, looks in the table for C0UNT<A> which represents the number of times letter A appeared in the text. If finds it, outputs the letter A and the number of its occurrences. In any case it goes back to statement #10; statement 10 - repeats the same procedure for every letter. It fails when no more letters are left and finishes the program.", "ref_id": 4654, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Write a program which counts the number of times each letter is used in input text.", "options": ["Python program", "SNOBOL IV program", "C++ program", "Java program"], "answer": "B", "solution": "1&TRTM = 1 2CHAR = LEN(1) .CH 3LETTERS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 4COUNT = TABLE (30) 5READOUTPUT = INPUT:F(DISPLAY) 6TEXT = OUTPUT 7NEXTTEXT CHAR =:F(READ) 8COUNT <CH> = COUNT <CH> + 1:(NEXT) 9DISPLAYOUTPUT = 10LOOPLETTERS CHAR =: F (END) 11OUTPUT = NE(COUNT<CH>) CH 'OCCURS' +COUNT <CH> 'TIMES'(LOOP) 12END The first statement includes a keyword '&TRIM'. Keywords in SNOBGL IV allow access to several parameters and switches internal to the SNOBOL IV system. Keywords begin with ampersand (&) followed by certain identifiers. For example, keyword &TRIM controls the handling of trailing blanks on input of data. If the value of &TRIM is nonzero, trailing blanks are deleted. Other keywords will be explained upon occurrence in the programs. The second statement, CHAR = LEN (1). CH, includes two important features. First, LEN (1), is an example of primitive (Built-in) functions. This function returns a pattern that matches any string of the length specified by the integer in parentheses. INPUT, PUNCH, and OUTPUT are some other primitive functions. The second important feature of the second statement is that it is an example of conditional value assignment (in this case .CH). The conditional value assignment operator (.) is separated from its operands by blanks. In the state-ment CHAR = LEN (1) . CH, variable CHAR is assigned the very first found string of length one, and, in case of success, assigns the same string to CH, which is used as an array subscript later in the program. The fourth statement, COUNT = TABLE (30), introduces the use of tables. Tables of variables can be created by using the primitive function TABLE, for example: T = TABLE ( ) In a very similar way arrays of variables are constructed by using the primitive function ARRAY, for example: A = ARRAY ( ) The arguments of an array, written in parentheses, describe the number of dimensions, the bounds of each dimension, and the initial value of each variable in the array. Thus A = ARRAY (10,1.0) creates and assigns to Aaone-dimensional array of 10 variables, each initialized to the real value 1.0. A table is similar to a one-dimensional array. However, instead of referencing an element with an integer, any data object can be used. In this program, letters of the alphabet are used as subscripts for table elements. The fifth statement of the program introduces the most important feature of the flow of control - a transfer to alabelledstatement. It is specified in the GOTO field which appears at the end of a statement and is separated from the rest of the statement by a colon. Two types of transfers can be specified in the GOTO field: conditional and unconditional, A conditional transfer consists of letters F or S corresponding to failure or success respectively, followed by a label enclosed within parentheses. Thus OUTPUT = INPUT: F(DISPLAY) makes the computerprint outwhatever appears on the data card. If, however, there is no data in the input file, i.e., an end of file is encountered, the transfer is made to the statement labeled display. An unconditional transfer is indicated by the absence of an F or S before the enclosing parentheses. For example, consider state-ment #8 of this program: COUNT<CH> = COUNT<CH> + 1: (NEXT) Each time this statement is executed, the transfer is made to the statementlabelledNEXT. Statement #11 uses one of the primitive functions of a specific group called NUMERICAL PREDICATES. The main ones include: LT - less than... LE - less than or equal to... EQ - equal to... NE - not equal to... GE - greater or equal to... GT - greater than... Statement OUTPUT = NE (COUNT<CH>).... prints out whatever is following the parentheses if the value of COUNT<CH> is not equal to zero. Finally, a statement that is longer than one line can be continued onto successive lines by starting the continuation lines with a period or plus sign. This program employs a plus sign for continua-tion of statement #11. Also note, that the statements in this program are numbered only for easy reference. All labels in SNOBCL IV start with a letter, as was mentioned earlier. If a statement does not start with a label, it must start with at least one blank. The general flow of this program is as follows: statement 1 - deletes trailing blanks; statement 2 - indicates that CHAR and CH will be assigned the first one-character string matched; statement 3 - assigns a string of the 26 letters of the alphabet to variable LETTERS; statement 4 - sets a 30-element table and assigns it to COUNT; statement 5 - prints out the first card of the input text; statement 6 - assigns it to variable TEXT; statement 7 - tests the text for presence of the first one-character string (which is the first letter of the first word in the text), deletes them all one at a time, adding 1 to COUNT<CH> in statement 8 each time around; statement 8 - goes back to statement 7 every time after adding 1 to COUNT<CH>; statement 7 - repeats the loop until all the appearances of each letter are counted, and the table COUNT is set up. Then COUNT fails when no more characters are left; the transfer is made back to statement #5; statement 5 - repeats the whole procedure for every following input card, adding missing members (if there are any) to the table COUNT. Finally it fails when there is no input left and transfers the execution to statement #9; statement 9 - prints a blank line; statement 10 - tests string LETTERS for the presence of a one- character string, finds 26 of them, assigns the first one (i.e., A) to CHAR and deletes it from LETTERS; statement 11 - since CH takes the same value as CHAR, looks in the table for C0UNT<A> which represents the number of times letter A appeared in the text. If finds it, outputs the letter A and the number of its occurrences. In any case it goes back to statement #10; statement 10 - repeats the same procedure for every letter. It fails when no more letters are left and finishes the program."}, "question": "task_1"}}, {"data": {"text": "Question:\nWrite a program which uses a bubble sort procedure to put given strings in lexical order.\n\nOptions:\nA. Quick Sort Program\nB. Insertion Sort Program\nC.             Merge Sort Program\nD. Bubble Sort Program\n\nAnswer: D\n\nReference Solution:\nThe function of BUBBLE sort is based on the function of a simple exchange sort, i.e., when an element, compared to the previous, or next one, is found to be out of order, it is moved to a preceding or following place respectively. The described procedure is continuously performed until that element is properly placed. The solution of this problem is as follows: \\textasteriskcenteredBUBBLE SORT PROGRAM &TRIM = 1 DEFINE ('SORT(N)I') DEFINE('SWITCH(I)TEMP') DEFINE('BUBBLE(J)') \\textasteriskcentered1:F(ERROR) N = INPUT A = ARRAY(N) \\textasteriskcentered2 READI = I +1 A<I> = INPUT:F(GO)S(READ) \\textasteriskcentered3 GOSORT(N) \\textasteriskcentered4 M = 1 PRINTOUTPUT = A<M>:F(END) M = M + 1:(PRINT) \\textasteriskcentered5 SORTI = LT(I,N-1) I +1:F(RETURN) LGT(A<I>,A<I>+ 1>):F(SORT) SWITCH(I) BUBBLE(I):(SORT) SWITCHTEMP =A<I> A<I> = A<I + 1> A<I + 1> =TEMP:(RETUN) BUBBLEJ = GT(J,1) J- 1:F(RETURN) LGT(A<J>,A<J + 1>):F(RETURN) SWITCH(J):(BUBBLE) END Any statement in SNOBOL IV, starting with an asterisk in column 1, is a comment (or remark) statement. These statements are not executable and are usually used to explain the functions of different parts of the program. There are three functions used in this program, which are defined in the beginning of the program. Their procedures are given right after the comment numbered 5. The first card of the input data for this program must contain the number of strings to be sorted, otherwise the program stalls. The part of the program between the comments numbered 1 and 2 reads that number, assigns it to N, and sets up an array of N members. The next program segment (between comments 2 and 3) fills the array with the input items. Notice that counter I is not initialized to zero, because in SNOBOL IV the initial value of the variables is a null string. The statement between the comments 3 and 4 calls and executes the SORT function. Since the entry point label is omitted in the DEFINE statement, the computer looks for the statement labeled SORT, as the initial statement of the function procedure, and finds it right after the comment 5. The function LGT(X, Y), included in the second statement of the SORT function procedure, compares lexically strings X and Y, and succeeds if X follows Y alphabetically. Thus, LGT (SPACE, BLANK) will succeed, while LGT (CAT, DOG) will fail. The next two statements of the SORT function procedure call and execute functions SWITCH and BUBBLE. Function SWITCH makes the two strings switch their places, while the BUBBLE function compares the string with the preceding one and switches them around, if needed, continuously, until the first string is finally properly placed. Thus, the major function SORT works as follows: The first statement (I = LT(I,N-1) I + 1) checks if a currently considered string is numbered 1 through N-1 (there is no need to specially consider the last string N, because, when the string N-1 is considered, it is compared with the string numbered N). The next statement checks the alphabetical order of that string and the one following it in the array. If the order is correct, the next string is considered. If the order is wrong, the fol-lowing string moves up one place, is compared with the next string, moves up again, if needed, and so on, until it is properly placed. When all the input items are considered, the program execution returns to the main part, i.e., to the section between comments 4 and 5 and one by one prints all the input strings in a just arranged alphabetical order. For the input:3 COMPUTER ARRAY BRANCH THE OUTPUT IS:ARRAY BRANCH COMPUTER", "ref_id": 4655, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Write a program which uses a bubble sort procedure to put given strings in lexical order.", "options": ["Quick Sort Program", "Insertion Sort Program", "Merge Sort Program", "Bubble Sort Program"], "answer": "D", "solution": "The function of BUBBLE sort is based on the function of a simple exchange sort, i.e., when an element, compared to the previous, or next one, is found to be out of order, it is moved to a preceding or following place respectively. The described procedure is continuously performed until that element is properly placed. The solution of this problem is as follows: \\textasteriskcenteredBUBBLE SORT PROGRAM &TRIM = 1 DEFINE ('SORT(N)I') DEFINE('SWITCH(I)TEMP') DEFINE('BUBBLE(J)') \\textasteriskcentered1:F(ERROR) N = INPUT A = ARRAY(N) \\textasteriskcentered2 READI = I +1 A<I> = INPUT:F(GO)S(READ) \\textasteriskcentered3 GOSORT(N) \\textasteriskcentered4 M = 1 PRINTOUTPUT = A<M>:F(END) M = M + 1:(PRINT) \\textasteriskcentered5 SORTI = LT(I,N-1) I +1:F(RETURN) LGT(A<I>,A<I>+ 1>):F(SORT) SWITCH(I) BUBBLE(I):(SORT) SWITCHTEMP =A<I> A<I> = A<I + 1> A<I + 1> =TEMP:(RETUN) BUBBLEJ = GT(J,1) J- 1:F(RETURN) LGT(A<J>,A<J + 1>):F(RETURN) SWITCH(J):(BUBBLE) END Any statement in SNOBOL IV, starting with an asterisk in column 1, is a comment (or remark) statement. These statements are not executable and are usually used to explain the functions of different parts of the program. There are three functions used in this program, which are defined in the beginning of the program. Their procedures are given right after the comment numbered 5. The first card of the input data for this program must contain the number of strings to be sorted, otherwise the program stalls. The part of the program between the comments numbered 1 and 2 reads that number, assigns it to N, and sets up an array of N members. The next program segment (between comments 2 and 3) fills the array with the input items. Notice that counter I is not initialized to zero, because in SNOBOL IV the initial value of the variables is a null string. The statement between the comments 3 and 4 calls and executes the SORT function. Since the entry point label is omitted in the DEFINE statement, the computer looks for the statement labeled SORT, as the initial statement of the function procedure, and finds it right after the comment 5. The function LGT(X, Y), included in the second statement of the SORT function procedure, compares lexically strings X and Y, and succeeds if X follows Y alphabetically. Thus, LGT (SPACE, BLANK) will succeed, while LGT (CAT, DOG) will fail. The next two statements of the SORT function procedure call and execute functions SWITCH and BUBBLE. Function SWITCH makes the two strings switch their places, while the BUBBLE function compares the string with the preceding one and switches them around, if needed, continuously, until the first string is finally properly placed. Thus, the major function SORT works as follows: The first statement (I = LT(I,N-1) I + 1) checks if a currently considered string is numbered 1 through N-1 (there is no need to specially consider the last string N, because, when the string N-1 is considered, it is compared with the string numbered N). The next statement checks the alphabetical order of that string and the one following it in the array. If the order is correct, the next string is considered. If the order is wrong, the fol-lowing string moves up one place, is compared with the next string, moves up again, if needed, and so on, until it is properly placed. When all the input items are considered, the program execution returns to the main part, i.e., to the section between comments 4 and 5 and one by one prints all the input strings in a just arranged alphabetical order. For the input:3 COMPUTER ARRAY BRANCH THE OUTPUT IS:ARRAY BRANCH COMPUTER"}, "question": "task_1"}}, {"data": {"text": "Question:\nWrite a FORTRAN program to compute the coefficient of rank correlation for the following data: X Y 1. .3 10 2. .6 15 3. .9 30 4. 1.2 35 5. 1.5 25 6. 1.8 30 7. 2.1 50 8. 2.4 45\n\nOptions:\nA. .875\nB. .873\nC.             .870\nD. .880\n\nAnswer: B\n\nReference Solution:\nThe correlation coefficient r is an appropriate measure of association between two variables when cardinal ordering is in-appropriate. Sometimes scores can only be ranked in order without any information concerning the distance between two elements in the ranking. For example, two judges in a beauty contest may give dif-ferent rankings. The correlation between them will depend on ordinal properties (first, second, third, etc.), not on cardinal properties (1, 1.5, 2.3, etc.). To find the coefficient of rank correlation between X and Y, first order Y's from smallest to largest, provided that X's are initially given in increasing order. X Rank of X Y Rank of Y .3 X_1 = 1 10 Y_1 = 1 .6 X_2 = 2 15 Y_2 = 2 .9 X_3 = 3 20 y_3 = 3 1.2 X_4 = 4 35 Y_4 = 6 1.5 X_5 = 5 25 Y_5 = 4 1.8 X_6 = 6 30 Y_6 = 5 2.1 X_7 = 7 50 Y_7 = 8 2.4 X_8 = 8 45 Y_8 = 7 The correlation coefficient r is equal to r = [\\sum(x-x) (y-y)] / [(\\sum(x-x)^2)^1/2 (\\sum(y-y)^2)^1/2] This formula can be modified into a rank correlation coefficient. Omitting the details of the transformation: r_s= 1 - {[6^n\\sum_i_=1 d^2] / [n(n^2-1)]} where = d^2 = (x_i-y_i)^2, the difference in ranks between thei-thx score and i-thy score squared. The 6 in the numerator arises from the sum ^n\\sum_i_=1 i^2 = [n(n+1)(2n+1)] / 6 which is computed during the transformation. Observe that if the rankings of x_i and y_i are identical, r_s = 1 - {[6 (0)] / [n(n^2-1)]} = 1. For the given data x_i-y_i (x_i-y_i)^2 0 0 0 0 0 0 -2 4 1 1 +1 1 -1 1 1 1 \\sum(x_i-y_i)^2 = 8n = 8 and r_s= 1 - {[6 (8)] / [8(63)]} = .873 The first task of the FORTRAN program for computing the rank cor-relation coefficient is the ordering of the giveny'sin ascending order. This can be accomplished using the subroutine \"SORT\", developed in the chapter named \"DATA STRUCTURES\". Assuming this is already done, the program looks as follows: INTEGER YFIN(N), XFIN(N) DIMENSION Y(N),YFIN(N), XFIN(N), M(N) READ, N READ, Y(I) CALL SORT (Y(J)) I = 1 J = 1 10IF(Y(J) - Y(I)) 2,3,2 2K = 0 6IF(Y(J) - Y(I+1). EQ.O) GO TO 5 K = K + 1 I= I + 1 GO TO 6 5YFIN(J) = I I = I - K GO TO 7 3YFIN(J) = I 7I = I + 1 J = J + 1 IF(J.EQ.N+1) GO TO 11 GO TO 10 11M(N) = 0 DO 12 L = 1,N M(L) = (XFIN(L) - YFIN (L)) \\textasteriskcentered\\textasteriskcentered2 M(N) = M(N) + M(L) 12CONTINUE RCC = 1 - 6\\textasteriskcenteredM(N) / (N\\textasteriskcentered(N\\textasteriskcentered\\textasteriskcentered2 - 1)) PRINT, RCC STOP END", "ref_id": 4656, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Write a FORTRAN program to compute the coefficient of rank correlation for the following data: X Y 1. .3 10 2. .6 15 3. .9 30 4. 1.2 35 5. 1.5 25 6. 1.8 30 7. 2.1 50 8. 2.4 45", "options": [".875", ".873", ".870", ".880"], "answer": "B", "solution": "The correlation coefficient r is an appropriate measure of association between two variables when cardinal ordering is in-appropriate. Sometimes scores can only be ranked in order without any information concerning the distance between two elements in the ranking. For example, two judges in a beauty contest may give dif-ferent rankings. The correlation between them will depend on ordinal properties (first, second, third, etc.), not on cardinal properties (1, 1.5, 2.3, etc.). To find the coefficient of rank correlation between X and Y, first order Y's from smallest to largest, provided that X's are initially given in increasing order. X Rank of X Y Rank of Y .3 X_1 = 1 10 Y_1 = 1 .6 X_2 = 2 15 Y_2 = 2 .9 X_3 = 3 20 y_3 = 3 1.2 X_4 = 4 35 Y_4 = 6 1.5 X_5 = 5 25 Y_5 = 4 1.8 X_6 = 6 30 Y_6 = 5 2.1 X_7 = 7 50 Y_7 = 8 2.4 X_8 = 8 45 Y_8 = 7 The correlation coefficient r is equal to r = [\\sum(x-x) (y-y)] / [(\\sum(x-x)^2)^1/2 (\\sum(y-y)^2)^1/2] This formula can be modified into a rank correlation coefficient. Omitting the details of the transformation: r_s= 1 - {[6^n\\sum_i_=1 d^2] / [n(n^2-1)]} where = d^2 = (x_i-y_i)^2, the difference in ranks between thei-thx score and i-thy score squared. The 6 in the numerator arises from the sum ^n\\sum_i_=1 i^2 = [n(n+1)(2n+1)] / 6 which is computed during the transformation. Observe that if the rankings of x_i and y_i are identical, r_s = 1 - {[6 (0)] / [n(n^2-1)]} = 1. For the given data x_i-y_i (x_i-y_i)^2 0 0 0 0 0 0 -2 4 1 1 +1 1 -1 1 1 1 \\sum(x_i-y_i)^2 = 8n = 8 and r_s= 1 - {[6 (8)] / [8(63)]} = .873 The first task of the FORTRAN program for computing the rank cor-relation coefficient is the ordering of the giveny'sin ascending order. This can be accomplished using the subroutine \"SORT\", developed in the chapter named \"DATA STRUCTURES\". Assuming this is already done, the program looks as follows: INTEGER YFIN(N), XFIN(N) DIMENSION Y(N),YFIN(N), XFIN(N), M(N) READ, N READ, Y(I) CALL SORT (Y(J)) I = 1 J = 1 10IF(Y(J) - Y(I)) 2,3,2 2K = 0 6IF(Y(J) - Y(I+1). EQ.O) GO TO 5 K = K + 1 I= I + 1 GO TO 6 5YFIN(J) = I I = I - K GO TO 7 3YFIN(J) = I 7I = I + 1 J = J + 1 IF(J.EQ.N+1) GO TO 11 GO TO 10 11M(N) = 0 DO 12 L = 1,N M(L) = (XFIN(L) - YFIN (L)) \\textasteriskcentered\\textasteriskcentered2 M(N) = M(N) + M(L) 12CONTINUE RCC = 1 - 6\\textasteriskcenteredM(N) / (N\\textasteriskcentered(N\\textasteriskcentered\\textasteriskcentered2 - 1)) PRINT, RCC STOP END"}, "question": "task_1"}}, {"data": {"text": "Question:\nFor principal P, a bank pays R interest compounded annually . Define a function in FORTRAN which calculates the deposit at the end of n years. Use the formula NEW DEPOSIT = P ((1+R)^n- 1)/R\n\nOptions:\nA. FUNCTION DP (P, R, N) DP = P*(1.+R)**N - 1.)/R RETURN END\nB. FUNCTION PD (R, N, P) PD = P*((1.+R) **N) - 1.)/R END\nC.             FUNCTION CD (P, R, N) CD = P*((1.+R) ^N) - 1.) RETURN END\nD. FUNCTION ND (P, R, N) ND = P*((1.+R) **N) - 1.)/R RETURN END\n\nAnswer: D\n\nReference Solution:\nLet P be the original principal. After 1 year, the new principal will be P_1 = P (1+R). After two years, it will be P_2 = P1(1+R) = P (1+R) (1+R) =P(1+R) ^2. After n years, it will be P_n = P (1+R)^n. By NEW DEPOSIT is understood the amount in the bank after n years less the original principal. In FORTRAN we can write FUNCTION ND (P, R, N) ND = P\\textasteriskcentered(((1.+R) \\textasteriskcentered\\textasteriskcenteredN) - 1.)/R RETURN END [Note: Remember to declare variables as INTEGER or REAL in the main program.]", "ref_id": 4657, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "For principal P, a bank pays R interest compounded annually . Define a function in FORTRAN which calculates the deposit at the end of n years. Use the formula NEW DEPOSIT = P ((1+R)^n- 1)/R", "options": ["FUNCTION DP (P, R, N) DP = P*(1.+R)**N - 1.)/R RETURN END", "FUNCTION PD (R, N, P) PD = P*((1.+R) **N) - 1.)/R END", "FUNCTION CD (P, R, N) CD = P*((1.+R) ^N) - 1.) RETURN END", "FUNCTION ND (P, R, N) ND = P*((1.+R) **N) - 1.)/R RETURN END"], "answer": "D", "solution": "Let P be the original principal. After 1 year, the new principal will be P_1 = P (1+R). After two years, it will be P_2 = P1(1+R) = P (1+R) (1+R) =P(1+R) ^2. After n years, it will be P_n = P (1+R)^n. By NEW DEPOSIT is understood the amount in the bank after n years less the original principal. In FORTRAN we can write FUNCTION ND (P, R, N) ND = P\\textasteriskcentered(((1.+R) \\textasteriskcentered\\textasteriskcenteredN) - 1.)/R RETURN END [Note: Remember to declare variables as INTEGER or REAL in the main program.]"}, "question": "task_1"}}, {"data": {"text": "Question:\nChange the Subroutine of the previous problem into a FUNCTION SUBPROGRAM and explain the procedure.\n\nOptions:\nA. Add a new subroutine\nB. Change the function name to SUBROUTINE\nC.             Remove all parameters\nD. Replace SUBROUTINE with FUNCTION, remove parameter K, assign the values of I and J to independent variables M and N\n\nAnswer: D\n\nReference Solution:\nIn FORTRAN, there is another kind of subprogram, called the FUNCTION SUBPROGRAM. The Function Subprogram may replace the subroutine if the result obtained by the SUBROUTINE is a single value. In order to get a function subprogram from the subroutine of the previous problem, 3 changes have to be made. FUNCTIONIGCD(I,J) that is, the word SUBROUTINE is replaced by FUNCTION. Parameter K is not being used anymore because the name of the function will be assigned the value of the greatest common divisor. The divisor value obtained by the subprogram is an integer; therefore the name of the FUNCTION subprogram must begin with the corresponding letter (i.e., I,J,...,N). time it appears in the statement, i.e., statement 4, (K = J), has to be changed into IGCD = J. parameters . It was observed in the Subroutine program GCD that the values of I and J were changed, therefore some modifications must be made before this subroutine can become a function subprogram. The simplest modification would be to assign the values of I and J to two independent variables, say M and N, and then use them in place of I and J. Therefore, the modified FUNCTION SUBPROGRAM will take the following form: FUNCTION IGCD (I,J) M = I N = J IF (M - N) 1,4,2 1 L = N N = M M = L 2 L = M - (M/N){_\\ast}N IF( L)3,4,3 3 M = N N = L GO TO 2 4 IGCD = N RETURN END", "ref_id": 4658, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Change the Subroutine of the previous problem into a FUNCTION SUBPROGRAM and explain the procedure.", "options": ["Add a new subroutine", "Change the function name to SUBROUTINE", "Remove all parameters", "Replace SUBROUTINE with FUNCTION, remove parameter K, assign the values of I and J to independent variables M and N"], "answer": "D", "solution": "In FORTRAN, there is another kind of subprogram, called the FUNCTION SUBPROGRAM. The Function Subprogram may replace the subroutine if the result obtained by the SUBROUTINE is a single value. In order to get a function subprogram from the subroutine of the previous problem, 3 changes have to be made. FUNCTIONIGCD(I,J) that is, the word SUBROUTINE is replaced by FUNCTION. Parameter K is not being used anymore because the name of the function will be assigned the value of the greatest common divisor. The divisor value obtained by the subprogram is an integer; therefore the name of the FUNCTION subprogram must begin with the corresponding letter (i.e., I,J,...,N). time it appears in the statement, i.e., statement 4, (K = J), has to be changed into IGCD = J. parameters . It was observed in the Subroutine program GCD that the values of I and J were changed, therefore some modifications must be made before this subroutine can become a function subprogram. The simplest modification would be to assign the values of I and J to two independent variables, say M and N, and then use them in place of I and J. Therefore, the modified FUNCTION SUBPROGRAM will take the following form: FUNCTION IGCD (I,J) M = I N = J IF (M - N) 1,4,2 1 L = N N = M M = L 2 L = M - (M/N){_\\ast}N IF( L)3,4,3 3 M = N N = L GO TO 2 4 IGCD = N RETURN END"}, "question": "task_1"}}, {"data": {"text": "Question:\nAssume that a gasoline company has a computer facility to take care of billing customers when they buy gasoline with credit cards. The computer is used to make out the check to the station, prepare a master list and create mailing lists and bills. Each customer's information is punched on the card, which contains the gas station number and name, the customer's number and name, and certain billing codes. Can you think of any things that could happen that would make the program useless?\n\nOptions:\nA. The program becomes useless when it cannot handle large data.\nB. The program becomes useless when the customer does not use credit cards.\nC.             The program becomes useless when there is a power outage.\nD. The program becomes useless when it cannot handle special cases such as customer death, relocation, sending invalid checks, requesting duplicate bills, or changing names.\n\nAnswer: D\n\nReference Solution:\nAlthough this doesn't sound like a complicated computer problem, in reality programmers tend to forget about \"trivial\" details that often become troublesome. For example: a)What if the customer dies? The program must be able to accommodate uncollectable bills. b)What if a customer moves? The program should be able to alter addresses. c)What if a customer sends invalid checks? d)What if the customer loses his bill and wants a duplicate? e)What if a customer changes his or her name? Appropriate actions should be taken in these special cases. If the program doesn't take these possibilities into account, the output will be meaningless when these eventualities arise.", "ref_id": 4659, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Assume that a gasoline company has a computer facility to take care of billing customers when they buy gasoline with credit cards. The computer is used to make out the check to the station, prepare a master list and create mailing lists and bills. Each customer's information is punched on the card, which contains the gas station number and name, the customer's number and name, and certain billing codes. Can you think of any things that could happen that would make the program useless?", "options": ["The program becomes useless when it cannot handle large data.", "The program becomes useless when the customer does not use credit cards.", "The program becomes useless when there is a power outage.", "The program becomes useless when it cannot handle special cases such as customer death, relocation, sending invalid checks, requesting duplicate bills, or changing names."], "answer": "D", "solution": "Although this doesn't sound like a complicated computer problem, in reality programmers tend to forget about \"trivial\" details that often become troublesome. For example: a)What if the customer dies? The program must be able to accommodate uncollectable bills. b)What if a customer moves? The program should be able to alter addresses. c)What if a customer sends invalid checks? d)What if the customer loses his bill and wants a duplicate? e)What if a customer changes his or her name? Appropriate actions should be taken in these special cases. If the program doesn't take these possibilities into account, the output will be meaningless when these eventualities arise."}, "question": "task_1"}}, {"data": {"text": "Question:\nWrite a BASIC program which keeps track of the numbers of items in stock for four different classes of items. To be specific, let the four classes of items be denoted by 1\\O\\O1, 1\\O\\O2, 1\\O\\O3 and 1\\O\\O4. Consider the case where the following 7 (seven) items are in stock: 1\\O\\O1, 1\\O\\O2, 1\\O\\O2, 1\\O\\O3, 1\\O\\O4, 1\\O\\O3, 1\\O\\O1.\n\nOptions:\nA. Use of a single counter for all classes\nB. Initialization of each variable to one instead of zero\nC.             Use of separate counters without the ON-GO TO statement\nD. Separate counters K1, K2, K3, and K4 for the four classes and use of the ON-GO TO statement\n\nAnswer: D\n\nReference Solution:\nIt is convenient to introduce separate counters K1, K2, K3, and K4 for the four classes. It is also convenient to utilize the ON-GO TO statement. Thus if we say 5\\O ON X GO TO 9\\O, 7\\O, 11\\O control will be transferred to statements 9\\O, 7\\O, or 11\\O if the truncated value of X is 1, 2, or 3 respectively 1\\OREM INVENTORY PROGRAM FOR 4 CLASSES 2\\OREM K1, K2, K3, K4 ARE THE COUNTERS 3\\ODATA 1\\O\\O1, 1\\O\\O2, 1\\O\\O2, 1\\O\\O3, 1\\O\\O4, 1\\O\\O3, 1\\O\\O1 4\\OLET K1 = K2 = K3 = K4 = \\O 5\\OFOR I = 1 TO 7 6\\OREAD X 7\\OON X - 1\\O\\O\\O GO TO 8\\O, 1\\O\\O, 12\\O, 14\\O 8\\OLET K1 = K1 + 1 9\\OGO TO 16\\O 1\\O\\OLET K2 = K2 + 1 11\\OGO TO 16\\O 12\\OLET K3 = K3 + 1 13\\OGO TO 16\\O 14\\OLET K4 = K4 + 1 15\\OGO TO 16\\O 16\\ONEXT I 17\\OPRINT \"ITEM 1\\O\\O1;\\textquotedblright; Kl;\"IN STOCK\" 18\\OPRINT \"ITEM 1\\O\\O2;\"; K2; \"IN STOCK\" 19\\OPRINT \"ITEM 1\\O\\O3;\"; K3; \"IN STOCK\" 2\\O\\OPRINT \"ITEM 1\\O\\O4;\"; K4; \"IN STOCK\" 21\\OEND Some computers do not accept multiple assignment state-ments. In that case, in statement 40 each variable should be initialized to zero separately.", "ref_id": 4660, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Write a BASIC program which keeps track of the numbers of items in stock for four different classes of items. To be specific, let the four classes of items be denoted by 1\\O\\O1, 1\\O\\O2, 1\\O\\O3 and 1\\O\\O4. Consider the case where the following 7 (seven) items are in stock: 1\\O\\O1, 1\\O\\O2, 1\\O\\O2, 1\\O\\O3, 1\\O\\O4, 1\\O\\O3, 1\\O\\O1.", "options": ["Use of a single counter for all classes", "Initialization of each variable to one instead of zero", "Use of separate counters without the ON-GO TO statement", "Separate counters K1, K2, K3, and K4 for the four classes and use of the ON-GO TO statement"], "answer": "D", "solution": "It is convenient to introduce separate counters K1, K2, K3, and K4 for the four classes. It is also convenient to utilize the ON-GO TO statement. Thus if we say 5\\O ON X GO TO 9\\O, 7\\O, 11\\O control will be transferred to statements 9\\O, 7\\O, or 11\\O if the truncated value of X is 1, 2, or 3 respectively 1\\OREM INVENTORY PROGRAM FOR 4 CLASSES 2\\OREM K1, K2, K3, K4 ARE THE COUNTERS 3\\ODATA 1\\O\\O1, 1\\O\\O2, 1\\O\\O2, 1\\O\\O3, 1\\O\\O4, 1\\O\\O3, 1\\O\\O1 4\\OLET K1 = K2 = K3 = K4 = \\O 5\\OFOR I = 1 TO 7 6\\OREAD X 7\\OON X - 1\\O\\O\\O GO TO 8\\O, 1\\O\\O, 12\\O, 14\\O 8\\OLET K1 = K1 + 1 9\\OGO TO 16\\O 1\\O\\OLET K2 = K2 + 1 11\\OGO TO 16\\O 12\\OLET K3 = K3 + 1 13\\OGO TO 16\\O 14\\OLET K4 = K4 + 1 15\\OGO TO 16\\O 16\\ONEXT I 17\\OPRINT \"ITEM 1\\O\\O1;\\textquotedblright; Kl;\"IN STOCK\" 18\\OPRINT \"ITEM 1\\O\\O2;\"; K2; \"IN STOCK\" 19\\OPRINT \"ITEM 1\\O\\O3;\"; K3; \"IN STOCK\" 2\\O\\OPRINT \"ITEM 1\\O\\O4;\"; K4; \"IN STOCK\" 21\\OEND Some computers do not accept multiple assignment state-ments. In that case, in statement 40 each variable should be initialized to zero separately."}, "question": "task_1"}}, {"data": {"text": "Question:\nWrite a program in PL/I to calculate a table of returns on an investment of original amount A which is compounded yearly at P percent return, for Y years.\n\nOptions:\nA. T = A(1 - P/100)^Y\nB. T = A(1 + P/100)^Y - 1\nC.             T =A(1 + P/100)^Y\nD. T = A + P/100^Y\n\nAnswer: C\n\nReference Solution:\nAfter Y years the original amount A will grow to T =A(1 + P/100)^Y The program below reads in values of A,P, and Y. Then it calculates the corresponding value of T and prints out A, P, Y, and T. /\\textasteriskcenteredCOMPOUND INTEREST\\textasteriskcentered/ ON ENDFILE (SYSIN) GO TO L60 L10:GET LIST (A, P, Y); L20:T = A\\textasteriskcentered(1 + P/100) \\textasteriskcentered\\textasteriskcenteredY; L30:PUT EDIT (A, P, Y, T) (F (16,4)) ; L40:PUT SKIP; L50:GO TO L10; L60:END", "ref_id": 4661, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Write a program in PL/I to calculate a table of returns on an investment of original amount A which is compounded yearly at P percent return, for Y years.", "options": ["T = A(1 - P/100)^Y", "T = A(1 + P/100)^Y - 1", "T =A(1 + P/100)^Y", "T = A + P/100^Y"], "answer": "C", "solution": "After Y years the original amount A will grow to T =A(1 + P/100)^Y The program below reads in values of A,P, and Y. Then it calculates the corresponding value of T and prints out A, P, Y, and T. /\\textasteriskcenteredCOMPOUND INTEREST\\textasteriskcentered/ ON ENDFILE (SYSIN) GO TO L60 L10:GET LIST (A, P, Y); L20:T = A\\textasteriskcentered(1 + P/100) \\textasteriskcentered\\textasteriskcenteredY; L30:PUT EDIT (A, P, Y, T) (F (16,4)) ; L40:PUT SKIP; L50:GO TO L10; L60:END"}, "question": "task_1"}}, {"data": {"text": "Question:\nUsing either the Subroutine Subprogram or Function Subprogram of the previous two problems obtain the greatest common divisor of L1 and L2, and add it to NN. Assume the Main Program is written, and integer values are assigned to L1, L2, and NN.\n\nOptions:\nA. NN = NN + IGCD(L1, L2)\nB. NN = NN * IGCD(L1, L2)\nC.             NN = IGCD(L1, L2)\nD. NN = IGCD(NN, L1, L2)\n\nAnswer: A\n\nReference Solution:\nThis is a good example of some of the advantages of using FUNCTION SUBPROGRAMS. We could use the following statements for the Subroutine: CALL GCD (L1, L2, M) NN = NN + M However, for the FUNCTION SUBPROGRAM we only need one statement: NN = NN + IGCD(L1, L2) Notice that the function subprogram is used in expressions wherever needed, in a way similar to the built-in functions such as SQRT (square root), IABS (Absolute Value of I),etc.", "ref_id": 4662, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Using either the Subroutine Subprogram or Function Subprogram of the previous two problems obtain the greatest common divisor of L1 and L2, and add it to NN. Assume the Main Program is written, and integer values are assigned to L1, L2, and NN.", "options": ["NN = NN + IGCD(L1, L2)", "NN = NN * IGCD(L1, L2)", "NN = IGCD(L1, L2)", "NN = IGCD(NN, L1, L2)"], "answer": "A", "solution": "This is a good example of some of the advantages of using FUNCTION SUBPROGRAMS. We could use the following statements for the Subroutine: CALL GCD (L1, L2, M) NN = NN + M However, for the FUNCTION SUBPROGRAM we only need one statement: NN = NN + IGCD(L1, L2) Notice that the function subprogram is used in expressions wherever needed, in a way similar to the built-in functions such as SQRT (square root), IABS (Absolute Value of I),etc."}, "question": "task_1"}}, {"data": {"text": "Question:\nDevelop a BASIC program that produces a horizontal bar graph for some given distribution. Use the DIM statement to dimension any arrays that might occur.\n\nOptions:\nA. BASIC program for a horizontal bar graph\nB. Python program for a horizontal bar graph\nC.             Java program for a horizontal bar graph\nD. C++ program for a horizontal bar graph\n\nAnswer: A\n\nReference Solution:\nThis program will produce a bar graph (a histogram) of a distribution. In this case, the distribution will represent student's grades for a math course. The frequency of a particular grade will be given in the graph as a series ofx's. The array A(J) will serve as the counter for each class mark. The program terminates upon the reading of a negative data point. 1\\O REM GRADE DISTRIBUTION GRAPH 2\\O DIM A (4) 25 REM INITIALIZE ALL A(L) TO ZERO 3\\O FOR L = 1 TO 4 4\\O LET A(L) = \\O 5\\O NEXT L 6\\O READ X 7\\O IF X = -1 THEN 12\\O 75 REM STANDARDIZE X VALUES 8\\O LET J = (X/10) - 5 9\\O LET A(J) = A(J) + 1 1\\O\\O GO TO 6\\O 11\\O FOR G = 1 TO 4 12\\O PRINT 5\\O + 1\\O \\textasteriskcentered G ; \"TO\"; 5\\O + 1\\O \\textasteriskcentered G + 9; 13\\O FOR W = 1 TO A(G) 14\\O PRINT \"X\"; 15\\O NEXT W 16\\O PRINT 17\\O NEXT G 18\\O DATA 77, 85, 96, 75, 81, 68, 73, 78 19\\O DATA 91, 72, 82, 74, 61, -1 2\\O\\O END Sample Output: RUN 6\\O TO 69 XX 7\\O TO 79 XXXXXX 8\\O TO 89 XXX 9\\O TO 99 XX READY A word about format: you may wish to include letter correlates for the number grades, such as A = 90 - 100, etc. This will make clear the ranges for the various class marks. By adding a PRINT statement with this information, you can make clear to the reader what the histogram is trying to show.", "ref_id": 4663, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Develop a BASIC program that produces a horizontal bar graph for some given distribution. Use the DIM statement to dimension any arrays that might occur.", "options": ["BASIC program for a horizontal bar graph", "Python program for a horizontal bar graph", "Java program for a horizontal bar graph", "C++ program for a horizontal bar graph"], "answer": "A", "solution": "This program will produce a bar graph (a histogram) of a distribution. In this case, the distribution will represent student's grades for a math course. The frequency of a particular grade will be given in the graph as a series ofx's. The array A(J) will serve as the counter for each class mark. The program terminates upon the reading of a negative data point. 1\\O REM GRADE DISTRIBUTION GRAPH 2\\O DIM A (4) 25 REM INITIALIZE ALL A(L) TO ZERO 3\\O FOR L = 1 TO 4 4\\O LET A(L) = \\O 5\\O NEXT L 6\\O READ X 7\\O IF X = -1 THEN 12\\O 75 REM STANDARDIZE X VALUES 8\\O LET J = (X/10) - 5 9\\O LET A(J) = A(J) + 1 1\\O\\O GO TO 6\\O 11\\O FOR G = 1 TO 4 12\\O PRINT 5\\O + 1\\O \\textasteriskcentered G ; \"TO\"; 5\\O + 1\\O \\textasteriskcentered G + 9; 13\\O FOR W = 1 TO A(G) 14\\O PRINT \"X\"; 15\\O NEXT W 16\\O PRINT 17\\O NEXT G 18\\O DATA 77, 85, 96, 75, 81, 68, 73, 78 19\\O DATA 91, 72, 82, 74, 61, -1 2\\O\\O END Sample Output: RUN 6\\O TO 69 XX 7\\O TO 79 XXXXXX 8\\O TO 89 XXX 9\\O TO 99 XX READY A word about format: you may wish to include letter correlates for the number grades, such as A = 90 - 100, etc. This will make clear the ranges for the various class marks. By adding a PRINT statement with this information, you can make clear to the reader what the histogram is trying to show."}, "question": "task_1"}}, {"data": {"text": "Question:\nThe following table gives the number of items sold daily at a super-market. Week 1 Week 2 Sunday 900 800 Monday 400 500 Tuesday 500 300 Wednesday 600 300 Thursday 300 400 Friday 700 600 Saturday 1100 900 Write a FORTRAN program to compute a seven day moving average.\n\nOptions:\nA. The sales are stable\nB. The sales are increasing\nC.             The sales are falling\nD. The sales are unpredictable\n\nAnswer: C\n\nReference Solution:\nObservations taken over periods of time typically show seasonal variability. The purpose of moving averages is to reduce these variations to enable us to spot the trend. First, find the average daily sales from Sunday to Saturday of the first week. This figure is placed in the table next to Wednesday - the midpoint of the examined period. Then find the average from Monday of the first week to Sunday of the second week, etc. Proceed-ing in this way we obtain the seven-day moving average for the given data. 7 day M.A. 7 day M.A. Sunday 571 Monday 586 Tuesday 571 Wednesday 643 543 Thursday 629 Friday 643 Saturday 614 From the table, it can be seen that the sales are falling. Perhaps the supermarket should start an advertising campaign; The program looks as follows: DIMENSION X(14), AV(7) L = 1 M = 7 SUM = 0 DO 2 I = 1,14 READ X(I) 2CONTINUE 10DO L J = L,M SUM = X(J) + SUM 1CONTINUE AV(L) = SUM/7 L = L + 1 M = M + 1 IF (M.EQ. 15) GO TO 11 GO TO 10 11DO 12 I = 1,7 PRINT AV(I) 12CONTINUE STOP END", "ref_id": 4664, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "The following table gives the number of items sold daily at a super-market. Week 1 Week 2 Sunday 900 800 Monday 400 500 Tuesday 500 300 Wednesday 600 300 Thursday 300 400 Friday 700 600 Saturday 1100 900 Write a FORTRAN program to compute a seven day moving average.", "options": ["The sales are stable", "The sales are increasing", "The sales are falling", "The sales are unpredictable"], "answer": "C", "solution": "Observations taken over periods of time typically show seasonal variability. The purpose of moving averages is to reduce these variations to enable us to spot the trend. First, find the average daily sales from Sunday to Saturday of the first week. This figure is placed in the table next to Wednesday - the midpoint of the examined period. Then find the average from Monday of the first week to Sunday of the second week, etc. Proceed-ing in this way we obtain the seven-day moving average for the given data. 7 day M.A. 7 day M.A. Sunday 571 Monday 586 Tuesday 571 Wednesday 643 543 Thursday 629 Friday 643 Saturday 614 From the table, it can be seen that the sales are falling. Perhaps the supermarket should start an advertising campaign; The program looks as follows: DIMENSION X(14), AV(7) L = 1 M = 7 SUM = 0 DO 2 I = 1,14 READ X(I) 2CONTINUE 10DO L J = L,M SUM = X(J) + SUM 1CONTINUE AV(L) = SUM/7 L = L + 1 M = M + 1 IF (M.EQ. 15) GO TO 11 GO TO 10 11DO 12 I = 1,7 PRINT AV(I) 12CONTINUE STOP END"}, "question": "task_1"}}, {"data": {"text": "Question:\nWrite a program to create, initialize, insert, delete,search, etc., a Hash Table, using PL / I.\n\nOptions:\nA. PL / I uses a single-dimensional array to simulate a Hash Table\nB. PL / I does not support Hash Table operations\nC.             PL / I has no Hash Table as a standard data structure type. Hence, we shall use a two-dimensional array to simulate a Hash Table.\nD. PL / I has a built-in Hash Table\n\nAnswer: C\n\nReference Solution:\nPL / Ihasno Hash Table as a standard data struc-ture type. Hence, we shall use a two-dimensional array to simulate a Hash Table. Creation of Hash Table: DCLHASHTAB(N, 2)CHAR (6) VAR, MARKER FIXED (3); / \\textasteriskcenteredWehave created an array named HASHTAB of N, say, 180 data items each of which can be a character variable, ofupto6 characters. This is our Hash Table. \\textasteriskcentered / / \\textasteriskcenteredThevariable MARKER will be useful later as a pointer \\textasteriskcentered / / \\textasteriskcenteredForany location J of the Table, the first element HASH-TAB (J, 1) will store a data item and the second element HASHTAB(J, 2) will store a pointer , if necessary, to the next linked element having the same HASH address . \\textasteriskcentered / Search and Insert: / \\textasteriskcenteredAssumethat the value of the HASHING function has turned out to be J \\textasteriskcentered / IF J<1\\mid >N THEN GO TO ('recalculate' error routine); / \\textasteriskcenteredWecheck if the Hashed address is within bounds of our table \\textasteriskcentered / DO WHILE HASHTAB (J, 1)\\rceil= 0; / \\textasteriskcentered We check if location is empty \\textasteriskcentered / MARKER = J J = J + 1; / \\textasteriskcentered If not empty, look at the next location \\textasteriskcentered / IF J = N THEN J = 1; / \\textasteriskcentered If we reach the end then we go round to the top of the array \\textasteriskcentered / If J = MARKER THEN GO TO (table full error routine); / \\textasteriskcenteredWecome back around to the starting point again, which indicates the Table has no empty spaces left \\textasteriskcentered / HASHTAB( MARKER, 2) = J; / \\textasteriskcenteredPointer of location calculated by the hashing function points to the new location J, \\textasteriskcentered / End; / \\textasteriskcentered End of DO WHILE \\textasteriskcentered / HASHTAB (J, 1) = DATA; / \\textasteriskcentered If we find the new location HASHTAB (J, 1) to be empty we do not enter the DO WHILE block, and jump to this statement, where we insert the data item. \\textasteriskcentered / Search and Read Out; / \\textasteriskcenteredAssumethat we are looking for a data item denoted by KEY, and whose HASH function value has been calculated as J \\textasteriskcentered / DO WHILE HASHTAB (J, 1)\\rceil= KEY; MARKER = J / \\textasteriskcenteredWestore the original value of J in the variable MARKER \\textasteriskcentered / J = HASHTAB (J, 2); / \\textasteriskcenteredWechange the value of J to that pointed to by the pointer part of J \\textasteriskcentered / If j = 0 THEN GO TO ('not available' error routine); / \\textasteriskcenteredThismeans there are no more linkages to search, and the data item is not in the table \\textasteriskcentered /. End; / \\textasteriskcentered End of DO WHILE \\textasteriskcentered / Y = HASHTAB (J, 1); / \\textasteriskcentered If the position denoted by J is equal to the Key, we do not enter the DO WHILE, but come to this statement, and read out the value written in the location into some required location Y \\textasteriskcentered / HASHTAB (MARKER, 2) = HASHTAB (J, 2); / \\textasteriskcenteredWenow complete the pointer linkages of the chain by making the pointer of the previous element , stored in Marker, to point to the next element to the deleted element \\textasteriskcentered / End;", "ref_id": 4665, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Write a program to create, initialize, insert, delete,search, etc., a Hash Table, using PL / I.", "options": ["PL / I uses a single-dimensional array to simulate a Hash Table", "PL / I does not support Hash Table operations", "PL / I has no Hash Table as a standard data structure type. Hence, we shall use a two-dimensional array to simulate a Hash Table.", "PL / I has a built-in Hash Table"], "answer": "C", "solution": "PL / Ihasno Hash Table as a standard data struc-ture type. Hence, we shall use a two-dimensional array to simulate a Hash Table. Creation of Hash Table: DCLHASHTAB(N, 2)CHAR (6) VAR, MARKER FIXED (3); / \\textasteriskcenteredWehave created an array named HASHTAB of N, say, 180 data items each of which can be a character variable, ofupto6 characters. This is our Hash Table. \\textasteriskcentered / / \\textasteriskcenteredThevariable MARKER will be useful later as a pointer \\textasteriskcentered / / \\textasteriskcenteredForany location J of the Table, the first element HASH-TAB (J, 1) will store a data item and the second element HASHTAB(J, 2) will store a pointer , if necessary, to the next linked element having the same HASH address . \\textasteriskcentered / Search and Insert: / \\textasteriskcenteredAssumethat the value of the HASHING function has turned out to be J \\textasteriskcentered / IF J<1\\mid >N THEN GO TO ('recalculate' error routine); / \\textasteriskcenteredWecheck if the Hashed address is within bounds of our table \\textasteriskcentered / DO WHILE HASHTAB (J, 1)\\rceil= 0; / \\textasteriskcentered We check if location is empty \\textasteriskcentered / MARKER = J J = J + 1; / \\textasteriskcentered If not empty, look at the next location \\textasteriskcentered / IF J = N THEN J = 1; / \\textasteriskcentered If we reach the end then we go round to the top of the array \\textasteriskcentered / If J = MARKER THEN GO TO (table full error routine); / \\textasteriskcenteredWecome back around to the starting point again, which indicates the Table has no empty spaces left \\textasteriskcentered / HASHTAB( MARKER, 2) = J; / \\textasteriskcenteredPointer of location calculated by the hashing function points to the new location J, \\textasteriskcentered / End; / \\textasteriskcentered End of DO WHILE \\textasteriskcentered / HASHTAB (J, 1) = DATA; / \\textasteriskcentered If we find the new location HASHTAB (J, 1) to be empty we do not enter the DO WHILE block, and jump to this statement, where we insert the data item. \\textasteriskcentered / Search and Read Out; / \\textasteriskcenteredAssumethat we are looking for a data item denoted by KEY, and whose HASH function value has been calculated as J \\textasteriskcentered / DO WHILE HASHTAB (J, 1)\\rceil= KEY; MARKER = J / \\textasteriskcenteredWestore the original value of J in the variable MARKER \\textasteriskcentered / J = HASHTAB (J, 2); / \\textasteriskcenteredWechange the value of J to that pointed to by the pointer part of J \\textasteriskcentered / If j = 0 THEN GO TO ('not available' error routine); / \\textasteriskcenteredThismeans there are no more linkages to search, and the data item is not in the table \\textasteriskcentered /. End; / \\textasteriskcentered End of DO WHILE \\textasteriskcentered / Y = HASHTAB (J, 1); / \\textasteriskcentered If the position denoted by J is equal to the Key, we do not enter the DO WHILE, but come to this statement, and read out the value written in the location into some required location Y \\textasteriskcentered / HASHTAB (MARKER, 2) = HASHTAB (J, 2); / \\textasteriskcenteredWenow complete the pointer linkages of the chain by making the pointer of the previous element , stored in Marker, to point to the next element to the deleted element \\textasteriskcentered / End;"}, "question": "task_1"}}, {"data": {"text": "Question:\nWrite a program which, using a recursive function, determines and prints out the steps necessary to move N discs from one needle to another in the Tower of Hanoi game.\n\nOptions:\nA. HANOI(N,NS,ND,NI)RETURN\nB. HANOI(N,O,NS,ND)\nC.             HANOI(N,NS,ND,NI)\nD. HANOI(N,NS,NI,ND)END\n\nAnswer: C\n\nReference Solution:\nA Tower of Hanoi is a game where N discs of decreasing size are stacked on a needle. There are two empty needles nearby. The aim is to move all the discs from the original needle to a second needle using, when necessary, the third needle as temporary storage. Only one disc can be moved at a time, and at no time may a larger disc rest upon a smaller disc. A recursive procedure has the property that the function Itself is called in the procedure. While convenient, recursive procedures may lead to computational inefficiencies. Nevertheless, recursion is frequently the most natural way of expressing a function, and may considerably simplify programming. The solution of this problem is as follows: \\textasteriskcenteredTHE TOWER OF HANOL GAME DEFINE(`HANOI(N,NS,ND,NI)'):(HANOI.END) HANOIEQ(N,O):S(RETURN HANOI(N- 1,NS,NI,ND) OUTPUT= 'MOVE DISC 'N' FROM 'NS' TO 'ND HANOI(N- 1,NI,ND,NS)(RETURN) HANOI.END TESTHANOI(5, 'A' , 'C' ,'B') END In this case N is equal to 5. On entry to the function HANOI, the value of N is compared with zero. If N is zero, no discs are moved, and the function returns. If N is not zero, HANOI is called recursively to move N - 1 discs from the starting needle (NS) to the intermediate storage needle (NI) Having done that, the command to move the Nth disc from the starting needle to the destination needle (ND) is printed. Finally, HANOI is called a second time to move the N - 1 discs from intermediate storage to the destination needle. The output for this program is as follows MOVE DISC 1 FROM A TO C MOVE DISC 2 FROM A TO B MOVE DISC 1 FROM C TO B MOVE DISC 3 FROM A TO C MOVE DISC 1 FROM B TO A MOVE DISC 2 FROM B TO C MOVE DISC 1 FROM A TO C MOVE DISC 4 FROM A TO B MOVE DISC 1 FROM C TO B MOVE DISC 2 FROM C TO A MOVE DISC 1 FROM B TO A MOVE DISC 3 FROM C TO B MOVE DISC 1 FROM A TO C MOVE DISC 2 FROM A TO B MOVE DISC 1 FROM C TO B MOVE DISC 5 FROM A TO C MOVE DISC 1 FROM B TO A MOVE DISC 2 FROM B TO C MOVE DISC 1 FROM A TO C MOVE DISC 3 FROM B TO A MOVE DISC 1 FROM C TO B MOVE DISC 2 FROM C TO A MOVE DISC 1 FROM B TO A MOVE DISC 4 FROM B TO C MOVE DISC 1 FROM A TO C MOVE DISC 2 FROM A TO B MOVE DISC 1 FROM C TO B MOVE DISC 3 FROM A TO C MOVE DISC 1 FROM B TO A MOVE DISC 2 FROM B TO C MOVE DISC 1 FROM A TO C", "ref_id": 4666, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Write a program which, using a recursive function, determines and prints out the steps necessary to move N discs from one needle to another in the Tower of Hanoi game.", "options": ["HANOI(N,NS,ND,NI)RETURN", "HANOI(N,O,NS,ND)", "HANOI(N,NS,ND,NI)", "HANOI(N,NS,NI,ND)END"], "answer": "C", "solution": "A Tower of Hanoi is a game where N discs of decreasing size are stacked on a needle. There are two empty needles nearby. The aim is to move all the discs from the original needle to a second needle using, when necessary, the third needle as temporary storage. Only one disc can be moved at a time, and at no time may a larger disc rest upon a smaller disc. A recursive procedure has the property that the function Itself is called in the procedure. While convenient, recursive procedures may lead to computational inefficiencies. Nevertheless, recursion is frequently the most natural way of expressing a function, and may considerably simplify programming. The solution of this problem is as follows: \\textasteriskcenteredTHE TOWER OF HANOL GAME DEFINE(`HANOI(N,NS,ND,NI)'):(HANOI.END) HANOIEQ(N,O):S(RETURN HANOI(N- 1,NS,NI,ND) OUTPUT= 'MOVE DISC 'N' FROM 'NS' TO 'ND HANOI(N- 1,NI,ND,NS)(RETURN) HANOI.END TESTHANOI(5, 'A' , 'C' ,'B') END In this case N is equal to 5. On entry to the function HANOI, the value of N is compared with zero. If N is zero, no discs are moved, and the function returns. If N is not zero, HANOI is called recursively to move N - 1 discs from the starting needle (NS) to the intermediate storage needle (NI) Having done that, the command to move the Nth disc from the starting needle to the destination needle (ND) is printed. Finally, HANOI is called a second time to move the N - 1 discs from intermediate storage to the destination needle. The output for this program is as follows MOVE DISC 1 FROM A TO C MOVE DISC 2 FROM A TO B MOVE DISC 1 FROM C TO B MOVE DISC 3 FROM A TO C MOVE DISC 1 FROM B TO A MOVE DISC 2 FROM B TO C MOVE DISC 1 FROM A TO C MOVE DISC 4 FROM A TO B MOVE DISC 1 FROM C TO B MOVE DISC 2 FROM C TO A MOVE DISC 1 FROM B TO A MOVE DISC 3 FROM C TO B MOVE DISC 1 FROM A TO C MOVE DISC 2 FROM A TO B MOVE DISC 1 FROM C TO B MOVE DISC 5 FROM A TO C MOVE DISC 1 FROM B TO A MOVE DISC 2 FROM B TO C MOVE DISC 1 FROM A TO C MOVE DISC 3 FROM B TO A MOVE DISC 1 FROM C TO B MOVE DISC 2 FROM C TO A MOVE DISC 1 FROM B TO A MOVE DISC 4 FROM B TO C MOVE DISC 1 FROM A TO C MOVE DISC 2 FROM A TO B MOVE DISC 1 FROM C TO B MOVE DISC 3 FROM A TO C MOVE DISC 1 FROM B TO A MOVE DISC 2 FROM B TO C MOVE DISC 1 FROM A TO C"}, "question": "task_1"}}, {"data": {"text": "Question:\nWrite a program which concatenates two strings \"I LOVE\" and \"YOU.\\textquotedblright, checks for presence of the character \\textquotedblleft.\\textquotedblright, replaces it with \\textquotedblleft!\\textquotedblright, and prints out the final string.\n\nOptions:\nA. LOVE YOU!\nB. I LOVE YOU!\nC.             YOU! I LOVE\nD. I LOVE YOU.\n\nAnswer: B\n\nReference Solution:\nConcatenation is the basic operation for combining two strings to form a third. The general form of this operation is represented by the following statements: variable 1 = string 1 variable 2 = string 2 variable 3 = string 1 string 2 There must be at least one blank space on each side of the \"=\" sign (as well as any other arithmetic operator, except the unary minus) and between strings 1 and 2 in variable 3. The simple pattern matching statement has the form subject pattern where the two fields are separated by at least one blank. This statement tells the computer to check the string indicated by subject forthe occurrence of a string specified by the pattern. A replacement statement has the form subject pattern = object The left part of this statement operates identically with the pattern matching statement. If a match occurs, the object string replaces the pattern string in the subject string. The program follows: WORD 1 = 'I LOVE' WORD 2 = 'YOU.' WORDS = WORD 1 WORD 2 WORDS ' . ' = ' ! ' OUTPUT = WORDS END Note, that END is a label, indicating the end of program. Labels appear beforethe statements and consist of a letter or a digit followed by any number of other characters up to a blank. Also note, that single quotation marks can be used as well as double quotations.", "ref_id": 4667, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Write a program which concatenates two strings \"I LOVE\" and \"YOU.\\textquotedblright, checks for presence of the character \\textquotedblleft.\\textquotedblright, replaces it with \\textquotedblleft!\\textquotedblright, and prints out the final string.", "options": ["LOVE YOU!", "I LOVE YOU!", "YOU! I LOVE", "I LOVE YOU."], "answer": "B", "solution": "Concatenation is the basic operation for combining two strings to form a third. The general form of this operation is represented by the following statements: variable 1 = string 1 variable 2 = string 2 variable 3 = string 1 string 2 There must be at least one blank space on each side of the \"=\" sign (as well as any other arithmetic operator, except the unary minus) and between strings 1 and 2 in variable 3. The simple pattern matching statement has the form subject pattern where the two fields are separated by at least one blank. This statement tells the computer to check the string indicated by subject forthe occurrence of a string specified by the pattern. A replacement statement has the form subject pattern = object The left part of this statement operates identically with the pattern matching statement. If a match occurs, the object string replaces the pattern string in the subject string. The program follows: WORD 1 = 'I LOVE' WORD 2 = 'YOU.' WORDS = WORD 1 WORD 2 WORDS ' . ' = ' ! ' OUTPUT = WORDS END Note, that END is a label, indicating the end of program. Labels appear beforethe statements and consist of a letter or a digit followed by any number of other characters up to a blank. Also note, that single quotation marks can be used as well as double quotations."}, "question": "task_1"}}, {"data": {"text": "Question:\nExplain what is known as the 'Count and/or Compare' methodof stopping a computer job.\n\nOptions:\nA. A method where the programmer sets a limit to the amount of memory used by the program\nB. A method where the programmer sets a maximum limit to the amount of times a loop is carried out or a maximum limit to the value of the result of his program. When this maximum limit is reached, the computer is instructed to exit the loop and carry out the remainder of the program.\nC.             A method where the programmer sets a minimum limit to the loops\nD. A method where the programmer allows the loop to run indefinitely\n\nAnswer: B\n\nReference Solution:\nSometimes, computer programs may be such that the computer will enterinto a segment of the program which makes the computer do an endlessnumber of loops. This will happen because the programmer has notprovided the instructions which control the exit from the loop. In such a casethe program will be terminated by the operating system when the allotedtime for the job has been exhausted. The careful programmer always watches out for these pit-falls in his program, and if there is a possibility of end-lessloopings(e.g., in a programthat calculates the sum of all even numbers greater than one), he normallyplaces a maxi-mum limit to the amount times the loop is carried out, or, a maximum limit to the value of the result of his program. When this maximum limit is reached, the computer is in-structed to exitthe loop and carry out the remainder of the program. This method is illustrated in the program below: SUM: PROCOPTIONS(MAIN); DCL (X,SUM)FIXED(4)INIT(0); LOOP: GET LIST(X); /\\textasteriskcentered A VALUE OF X IS READ OFF A CARD \\textasteriskcentered/ SUM=SUM+X ; IF SUM>100 THEN GOTO FINISH; /\\textasteriskcentered HERE, WE SET A MAXIMUM LIMIT OF 100 TO THE VALUE THAT THE SUM OF ALL THE DIFFERENT NUMBERS 'X' WHICH ARE READ FROM THE CARD/CARDS, CAN REACH \\textasteriskcentered/ GOTO LOOP; FINISH: PUTLIST(SUM); END SUM;", "ref_id": 4668, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Explain what is known as the 'Count and/or Compare' methodof stopping a computer job.", "options": ["A method where the programmer sets a limit to the amount of memory used by the program", "A method where the programmer sets a maximum limit to the amount of times a loop is carried out or a maximum limit to the value of the result of his program. When this maximum limit is reached, the computer is instructed to exit the loop and carry out the remainder of the program.", "A method where the programmer sets a minimum limit to the loops", "A method where the programmer allows the loop to run indefinitely"], "answer": "B", "solution": "Sometimes, computer programs may be such that the computer will enterinto a segment of the program which makes the computer do an endlessnumber of loops. This will happen because the programmer has notprovided the instructions which control the exit from the loop. In such a casethe program will be terminated by the operating system when the allotedtime for the job has been exhausted. The careful programmer always watches out for these pit-falls in his program, and if there is a possibility of end-lessloopings(e.g., in a programthat calculates the sum of all even numbers greater than one), he normallyplaces a maxi-mum limit to the amount times the loop is carried out, or, a maximum limit to the value of the result of his program. When this maximum limit is reached, the computer is in-structed to exitthe loop and carry out the remainder of the program. This method is illustrated in the program below: SUM: PROCOPTIONS(MAIN); DCL (X,SUM)FIXED(4)INIT(0); LOOP: GET LIST(X); /\\textasteriskcentered A VALUE OF X IS READ OFF A CARD \\textasteriskcentered/ SUM=SUM+X ; IF SUM>100 THEN GOTO FINISH; /\\textasteriskcentered HERE, WE SET A MAXIMUM LIMIT OF 100 TO THE VALUE THAT THE SUM OF ALL THE DIFFERENT NUMBERS 'X' WHICH ARE READ FROM THE CARD/CARDS, CAN REACH \\textasteriskcentered/ GOTO LOOP; FINISH: PUTLIST(SUM); END SUM;"}, "question": "task_1"}}, {"data": {"text": "Question:\nExplain what is meant by Initialization or Initial Attributes. Explain how a variable is initialized. Also, explain how initialization is done, and what is stored in the computer memory by the following statement: DCL A FIXED(3,2) INITIAL(1\\textbullet5), B FIXED(2,1) INIT (2\\textbullet25) , C FLOAT(4) INIT(170), J INIT(10010B), P INIT(-11E2).\n\nOptions:\nA. A variable can only be initialized at the beginning of the program.\nB. A variable is initialized by assigning an initial value or attribute to it, which can be done anywhere within the program but must be done before the variable appears in an expression. A variable's initialization is stored in the computer memory.\nC.             Initialization refers to the process of setting a variable to a default value.\nD. Initialization values are not stored in the computer memory.\n\nAnswer: B\n\nReference Solution:\nIt is often necessary that a variable appearing in a program have a value before it is used in expressions in the program. This value is given to the variable by explicit-ly assigning an initial value or initial attribute to the variable. The assigning of an initial attribute is called Initialization. Initialization can be done by means of a statement as follows: A = 3 \\textbullet 2; B= - 4E - 1; C = 2 In the above, A is given an initial value of 3\\textbullet2. B is ini-tialized to a floating point value of -0\\textbullet4, and the initial value of C is 2. Initialization can be done anywhere within the body of the program, but it must be done before the variable appears in an expression in the program. A good place to do the initialization of the variables in a program is immediately following the DECLARE statements. A better and shorter way is to initialize the variables simultaneously as they are declared, that is, do the initial-ization in the DECLARE statement itself. This is done as il-lustrated below: DCL A FIXED(3,2) INITIAL(1\\textbullet5), B FIXED(2,1) INIT (2\\textbullet25), C FLOAT(4) INIT(170), J INIT(10010B), P INIT( - 11E2) ; In the above, INIT is a short form for INITIAL. A is de-clared as FIXED(3,2) with an initial value of 1\\textbullet5. Hence, the initial value stored in memory for A is 1\\textbullet50. B is de-clared as FIXED(2,1) with an initial value of 2\\textbullet25. Therefore, the value stored for B is as follows: 2\\textbullet2. Notice the 5 is truncated because the declaration FIXED(2,1) specifies only one position to the right of the decimal. C is declared as FLOAT (4) with an initial value of 170. Therefore, the value stored for C is as follows: 0\\textbullet1700E + 03. If a PUT DATA(C) statement were used in the program before the value of C was changed, the print out for C would be as follows: C = 1\\textbullet700E + 02. For J, except for the initial value, no other attributes are declared. Hence, by Default Rules, J receives the following attributes: BIN REAL FIXED 15,0). The initial value of J is 10010B, which is stored in memory. A PUT DATA(J) statement would print out as below: J = 000000000010010B For P, by Default Rules, the attributes are as follows: DEC REAL FLOAT(6). Hence, the value of P stored in memory is as follows: -0\\textbullet110000E + 04. A PUT DATA(P) statement will cause a print out as follows: P = - 1\\textbullet10000E + 03", "ref_id": 4669, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Explain what is meant by Initialization or Initial Attributes. Explain how a variable is initialized. Also, explain how initialization is done, and what is stored in the computer memory by the following statement: DCL A FIXED(3,2) INITIAL(1\\textbullet5), B FIXED(2,1) INIT (2\\textbullet25) , C FLOAT(4) INIT(170), J INIT(10010B), P INIT(-11E2).", "options": ["A variable can only be initialized at the beginning of the program.", "A variable is initialized by assigning an initial value or attribute to it, which can be done anywhere within the program but must be done before the variable appears in an expression. A variable's initialization is stored in the computer memory.", "Initialization refers to the process of setting a variable to a default value.", "Initialization values are not stored in the computer memory."], "answer": "B", "solution": "It is often necessary that a variable appearing in a program have a value before it is used in expressions in the program. This value is given to the variable by explicit-ly assigning an initial value or initial attribute to the variable. The assigning of an initial attribute is called Initialization. Initialization can be done by means of a statement as follows: A = 3 \\textbullet 2; B= - 4E - 1; C = 2 In the above, A is given an initial value of 3\\textbullet2. B is ini-tialized to a floating point value of -0\\textbullet4, and the initial value of C is 2. Initialization can be done anywhere within the body of the program, but it must be done before the variable appears in an expression in the program. A good place to do the initialization of the variables in a program is immediately following the DECLARE statements. A better and shorter way is to initialize the variables simultaneously as they are declared, that is, do the initial-ization in the DECLARE statement itself. This is done as il-lustrated below: DCL A FIXED(3,2) INITIAL(1\\textbullet5), B FIXED(2,1) INIT (2\\textbullet25), C FLOAT(4) INIT(170), J INIT(10010B), P INIT( - 11E2) ; In the above, INIT is a short form for INITIAL. A is de-clared as FIXED(3,2) with an initial value of 1\\textbullet5. Hence, the initial value stored in memory for A is 1\\textbullet50. B is de-clared as FIXED(2,1) with an initial value of 2\\textbullet25. Therefore, the value stored for B is as follows: 2\\textbullet2. Notice the 5 is truncated because the declaration FIXED(2,1) specifies only one position to the right of the decimal. C is declared as FLOAT (4) with an initial value of 170. Therefore, the value stored for C is as follows: 0\\textbullet1700E + 03. If a PUT DATA(C) statement were used in the program before the value of C was changed, the print out for C would be as follows: C = 1\\textbullet700E + 02. For J, except for the initial value, no other attributes are declared. Hence, by Default Rules, J receives the following attributes: BIN REAL FIXED 15,0). The initial value of J is 10010B, which is stored in memory. A PUT DATA(J) statement would print out as below: J = 000000000010010B For P, by Default Rules, the attributes are as follows: DEC REAL FLOAT(6). Hence, the value of P stored in memory is as follows: -0\\textbullet110000E + 04. A PUT DATA(P) statement will cause a print out as follows: P = - 1\\textbullet10000E + 03"}, "question": "task_1"}}, {"data": {"text": "Question:\nWrite a program which converts a number in base ten [with value\\leq 2^20 ] into the corresponding representation in base two.\n\nOptions:\nA. Add the highest power of two\nB. Subtract off the highest power of two contained in the number and continue until the exponent of the power of two subtracted off is zero.\nC.             Subtract the lowest power of two\nD. Multiply by the highest power of two\n\nAnswer: B\n\nReference Solution:\nThe method upon which our solution is based is to subtract off the highestpower of two contained in the given number. The remainder then becomesthe new number and we continue subtracting off powers of two untilthe exponent of the power of two subtracted off is zero. Thus, if N, the originalnumber, is given by N = I \\textasteriskcentered (2\\textasteriskcentered\\textasteriskcenteredE) + R (I = integer quotient, R = remainder), thenwe can calculate I from I =INT(N/(2\\textasteriskcentered\\textasteriskcenteredE)), sothat R = N - I\\textasteriskcentered(2\\textasteriskcentered\\textasteriskcenteredE). RbecomesN in the next iteration. 1\\OREAD N 2\\OPRINT N; \\textquotedblleftBASE TEN= \\textquotedblright 3\\OFOR E = 20TO0STEP - 1 4\\OLET I=INT(N/2\\uparrowE) 5\\OPRINT I; 6\\OLET R = N - I\\textasteriskcentered2\\uparrowE 7\\OLET N = R 8\\ONEXT E 85PRINT \\textquotedblleftBASE TWO\\textquotedblright 86PRINT 9\\OGO TO 10 1\\O\\ODATA999999.,16 11\\OEND", "ref_id": 4670, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Write a program which converts a number in base ten [with value\\leq 2^20 ] into the corresponding representation in base two.", "options": ["Add the highest power of two", "Subtract off the highest power of two contained in the number and continue until the exponent of the power of two subtracted off is zero.", "Subtract the lowest power of two", "Multiply by the highest power of two"], "answer": "B", "solution": "The method upon which our solution is based is to subtract off the highestpower of two contained in the given number. The remainder then becomesthe new number and we continue subtracting off powers of two untilthe exponent of the power of two subtracted off is zero. Thus, if N, the originalnumber, is given by N = I \\textasteriskcentered (2\\textasteriskcentered\\textasteriskcenteredE) + R (I = integer quotient, R = remainder), thenwe can calculate I from I =INT(N/(2\\textasteriskcentered\\textasteriskcenteredE)), sothat R = N - I\\textasteriskcentered(2\\textasteriskcentered\\textasteriskcenteredE). RbecomesN in the next iteration. 1\\OREAD N 2\\OPRINT N; \\textquotedblleftBASE TEN= \\textquotedblright 3\\OFOR E = 20TO0STEP - 1 4\\OLET I=INT(N/2\\uparrowE) 5\\OPRINT I; 6\\OLET R = N - I\\textasteriskcentered2\\uparrowE 7\\OLET N = R 8\\ONEXT E 85PRINT \\textquotedblleftBASE TWO\\textquotedblright 86PRINT 9\\OGO TO 10 1\\O\\ODATA999999.,16 11\\OEND"}, "question": "task_1"}}, {"data": {"text": "Question:\nWhat is the difference between a basic assemblerlanguage macroinstruction and a machine or imperative instruction. Indicate what, if any, relationship exists between them.\n\nOptions:\nA. Macro instructions are single abbreviations for groups of instructions, which must be expanded before translation to object code. Assembler instruction is usually a subset of the macro.\nB. Assembler instruction is a larger set than the macro\nC.             Macro instructions are complex codes that cannot be translated to object code\nD. Macro instructions and assembler instructions have no relation\n\nAnswer: A\n\nReference Solution:\nIn assembler language, as in any other computer language, we oftenfind it necessary to repeat a contiguous group or block of instructions. This block, of course, may consist of any combination of codespermitted by the assem-bler. Having to do repetition, the assembler languagepro-grammer will find a macro instruction facility useful. Macro instructions(or just Macros) are single abbreviations for groups of instructions. So in writing a macro instruc-tion, the programmer in effect definesa single line of code to represent a group of instructions. Each timethis line occurs in the program, the macro facility will sub-stitute the blockof instructions. This process is similar to calling a subroutine in a highlevel language. After the substitution, this block of code is translated toma-chine language. Hence, unlike the assembler instruction,which is translateddirectly to object code, the macro must first be expanded (substitutingthe block of code for the macro is referred to as expanding themacro) before its translation to object code. Although the macro may contain other types of instruc-tions, we can clearlysee that the assembler instruction is usually a subset of the macro.", "ref_id": 4671, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "What is the difference between a basic assemblerlanguage macroinstruction and a machine or imperative instruction. Indicate what, if any, relationship exists between them.", "options": ["Macro instructions are single abbreviations for groups of instructions, which must be expanded before translation to object code. Assembler instruction is usually a subset of the macro.", "Assembler instruction is a larger set than the macro", "Macro instructions are complex codes that cannot be translated to object code", "Macro instructions and assembler instructions have no relation"], "answer": "A", "solution": "In assembler language, as in any other computer language, we oftenfind it necessary to repeat a contiguous group or block of instructions. This block, of course, may consist of any combination of codespermitted by the assem-bler. Having to do repetition, the assembler languagepro-grammer will find a macro instruction facility useful. Macro instructions(or just Macros) are single abbreviations for groups of instructions. So in writing a macro instruc-tion, the programmer in effect definesa single line of code to represent a group of instructions. Each timethis line occurs in the program, the macro facility will sub-stitute the blockof instructions. This process is similar to calling a subroutine in a highlevel language. After the substitution, this block of code is translated toma-chine language. Hence, unlike the assembler instruction,which is translateddirectly to object code, the macro must first be expanded (substitutingthe block of code for the macro is referred to as expanding themacro) before its translation to object code. Although the macro may contain other types of instruc-tions, we can clearlysee that the assembler instruction is usually a subset of the macro."}, "question": "task_1"}}, {"data": {"text": "Question:\nWritepseudocodeto describe an algorithm to find a particularsubarrayin a larger array of characters.\n\nOptions:\nA. SUBARRAY IS EMPTY\nB. NO, MAIN ARRAY NOT FOUND\nC.             YES, MAIN ARRAY FOUND\nD. YES, SUBARRAY FOUND or NO, SUBARRAY NOT FOUND\n\nAnswer: D\n\nReference Solution:\nSuppose that the main array is M(I), I = 1,2,3,...,N and thesubarray is S(I), I = 1,2,3,...,K, where K \\leq N. The idea is to compare successive elements of M(I) with S(1) until a match is found. If so, then the subsequent values of M(I) must be compared with S(2), S(3),...,S(K) to find the entiresubarray. It is assumed that both the main array and thesubarrayhave already been read in. The program will output \"yes\" if thesubarrayis found, \"no\" if not found. A logical flag is used to indicate if a match has been found. The beginning and end of nests are indicated by a dotted line. do for I = 1 to N - K + 1 by 1 if M(I) = S(1) then do FLAG \\leftarrow 'TRUE' do for J = I + 1 to I + K - 1 by 1 if M(J) \\not = S(J - I + 1) then FLAG \\leftarrow 'FALSE' exit do for end if end do for if FLAG = 'TRUE' exit do for end if end do for if FLAG = 'TRUE' then output \"YES, SUBARRAY FOUND\" else output \"NO, SUBARRAY NOT FOUND\" end if then else end program", "ref_id": 4672, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Writepseudocodeto describe an algorithm to find a particularsubarrayin a larger array of characters.", "options": ["SUBARRAY IS EMPTY", "NO, MAIN ARRAY NOT FOUND", "YES, MAIN ARRAY FOUND", "YES, SUBARRAY FOUND or NO, SUBARRAY NOT FOUND"], "answer": "D", "solution": "Suppose that the main array is M(I), I = 1,2,3,...,N and thesubarray is S(I), I = 1,2,3,...,K, where K \\leq N. The idea is to compare successive elements of M(I) with S(1) until a match is found. If so, then the subsequent values of M(I) must be compared with S(2), S(3),...,S(K) to find the entiresubarray. It is assumed that both the main array and thesubarrayhave already been read in. The program will output \"yes\" if thesubarrayis found, \"no\" if not found. A logical flag is used to indicate if a match has been found. The beginning and end of nests are indicated by a dotted line. do for I = 1 to N - K + 1 by 1 if M(I) = S(1) then do FLAG \\leftarrow 'TRUE' do for J = I + 1 to I + K - 1 by 1 if M(J) \\not = S(J - I + 1) then FLAG \\leftarrow 'FALSE' exit do for end if end do for if FLAG = 'TRUE' exit do for end if end do for if FLAG = 'TRUE' then output \"YES, SUBARRAY FOUND\" else output \"NO, SUBARRAY NOT FOUND\" end if then else end program"}, "question": "task_1"}}, {"data": {"text": "Question:\nModify the automobile suspension program of parti) of the previous problem so that it is possible to find a value for D - the damping coef-ficient, that will not allow the displacement of the mass x(t) to exceed 1.6, given K = 400.0, M = 2.0, E(t) = h = 1.0. Start with D = 6.0 and increase it by one unit whenever it is found that x(t) > 1.6, until the desired damping is found.\n\nOptions:\nA. Keep D constant if XCOR > 1.6\nB. Decrease D by 0.5 if XCOR > 1.6\nC.             Increase D by 1 if XCOR > 1.6\nD. Decrease D by 1 if XCOR > 1.6\n\nAnswer: C\n\nReference Solution:\nThe modification is made when the value of XCOR is found with desired accuracy. We test to see if XCOR \\leq 1.6. If so, the program proceeds as in parti) of the previous problem. If not, D is increased by 1 and variables are reinitialized so that the algorithm may begin again using the new value of D. The program follows: REAL K/400.0/,M/2.0/,N,T/0.0/,XCOR/0.0/, VCOR/0.0/, H/1. 0/, D/ 6.0/ F(Y,Z) = (H - D{_\\ast}Y - K{_\\ast}Z)/M READ N, TFIN, ACCUR DT = (TFIN - T)/N 50 50X = XCOR V = VC0R A = F(V,X) PRINT T,X,D T = T + DT IF (T.GT.TFIN) STOP XPRED = X + V{_\\ast}DT VPRED = V + A{_\\ast}DT 100XDOT = VPRED VDOT = F(V,XPRED) XCOR = X + 0.5{_\\ast}(V + XDOT){_\\ast}DT VCOR = V + 0.5{_\\ast}(A + VDOT){_\\ast}DT XDIF = ABS(XCOR - XPRED) VDIF = ABS(VCOR - VPRED) IF (XDIF .LE.ACCUR.AND.VDIF.LE.ACCUR) GO TO 110 XPRED = XCOR VPRED = VC0R GO TO 100 110IF (XCOR.LE.1.6) GO TO 50 D = D + 1.0 T = 0.0 XCOR = 0.0 VCOR =0.0 GO TO 50 END", "ref_id": 4673, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Modify the automobile suspension program of parti) of the previous problem so that it is possible to find a value for D - the damping coef-ficient, that will not allow the displacement of the mass x(t) to exceed 1.6, given K = 400.0, M = 2.0, E(t) = h = 1.0. Start with D = 6.0 and increase it by one unit whenever it is found that x(t) > 1.6, until the desired damping is found.", "options": ["Keep D constant if XCOR > 1.6", "Decrease D by 0.5 if XCOR > 1.6", "Increase D by 1 if XCOR > 1.6", "Decrease D by 1 if XCOR > 1.6"], "answer": "C", "solution": "The modification is made when the value of XCOR is found with desired accuracy. We test to see if XCOR \\leq 1.6. If so, the program proceeds as in parti) of the previous problem. If not, D is increased by 1 and variables are reinitialized so that the algorithm may begin again using the new value of D. The program follows: REAL K/400.0/,M/2.0/,N,T/0.0/,XCOR/0.0/, VCOR/0.0/, H/1. 0/, D/ 6.0/ F(Y,Z) = (H - D{_\\ast}Y - K{_\\ast}Z)/M READ N, TFIN, ACCUR DT = (TFIN - T)/N 50 50X = XCOR V = VC0R A = F(V,X) PRINT T,X,D T = T + DT IF (T.GT.TFIN) STOP XPRED = X + V{_\\ast}DT VPRED = V + A{_\\ast}DT 100XDOT = VPRED VDOT = F(V,XPRED) XCOR = X + 0.5{_\\ast}(V + XDOT){_\\ast}DT VCOR = V + 0.5{_\\ast}(A + VDOT){_\\ast}DT XDIF = ABS(XCOR - XPRED) VDIF = ABS(VCOR - VPRED) IF (XDIF .LE.ACCUR.AND.VDIF.LE.ACCUR) GO TO 110 XPRED = XCOR VPRED = VC0R GO TO 100 110IF (XCOR.LE.1.6) GO TO 50 D = D + 1.0 T = 0.0 XCOR = 0.0 VCOR =0.0 GO TO 50 END"}, "question": "task_1"}}, {"data": {"text": "Question:\nA PL/I program uses the EDIT form of input. The declare statementof the program is as follows: DCL(A,B,C,D,E,F) FIXED(5,2) ; GCHAR(15)VAR, H CHAR(4) ; A data card used by the program has the following informationpunched on it (Note: The symbolbdenotes a blankspace). \\downarrowcol.8\\downarrowcol.34 AB-123 \\textbullet 45b123 \\textbullet 459123 \\textbullet 456bb12345b18 \\textbullet b 345912345B2GbCARS CARS CARS Show what will be stored in the memory locations correspond-ingto A, B, C, D, E, F, G and H when the followingstatement is executed: GETEDIT(A, B, C, D, E, F, G, H) [COL(10), F(7, 2), F(7, 2), X(2), F(4, 1), COL(34), F(5, 2), X(1), F(6, 3), F(1, 1), X(5), A(3), X(1), A(4)];\n\nOptions:\nA. A 123.45, B -123.45, C 023.40, D 123.45, E 011.83, F 000.90, G B2G, H CARS\nB. A -123.45, B 123.45, C 023.40, D 123.45, E 011.83, F 000.90, G B2G, H CARS\nC.             A -123.45, B 123.45, C 123.40, D 023.45, E 011.83, F 000.90, G B2G, H CARS\nD. A -123.45, B 123.45, C 023.40, D 123.45, E 011.83, F 900.90, G B2G, H CARS\n\nAnswer: B\n\nReference Solution:\nAs a result of the GET EDIT statement, the data card will be read in thefollowing manner: All entries on the data card up to col. 10 are ignored. Starting from col. 10, a numerical fieldF(7,2) is read off, for A. Thus, a value -123\\textbullet45 is stored for A. This brings the computer to col. 17 ofthe card. Next, a numeric fieldF(7,2) for B is read off. Thus, a value 123\\textbullet45 is stored for B. This brings the computer to col. 24 of the card. The nextinstruction is X(2), i.e., skip 2 columns. Hence the computer ignores the91, and goes to col. 26 of the card. Now, it must read a numeric field ofF(4,1) corresponding to C. Thus, a value 23\\textbullet4 is read off, and the computercomes to col. 30 of the card. However, C is declared as FIXED(5,2). Therefore, the value 23\\textbullet4 which is read from the card is storedas 023\\textbullet40 in the memory location corresponding to C. The next 4 columns of the card are to be skipped be-cause the programmust jump to col. 34 of the card according to the next instruction. Starting from col. 34, a numeric field ofF(5,2) is to be read. Thus, 12345 are read off from the card and assigned to D. And, as D is specified aformat of F(5,2), therefore 12345 is stored for D as 123\\textbullet45. The program comesto col. 39 Column 39 is skipped due toX(1), and the program reaches col. 40. The next instruction isF(6,3) corresponding to E. So, 1\\textbullet8345 are read fromthe card and assigned to E. However, E is specified a format of F(6,3). The format specifications wants E to be of the form XX\\textbulletXXX. In caseof a conflict between the format specification and the value read from thecard, the value read from the card gets pre-ference. Hence, E becomes 1\\textbullet8345. Now, E is declared asFIXED(5,2). Thus, the memory al-located for E on the basis of the declare statement (DCL) expects E to be of the form XXX\\textbulletXX. Hence, the value stored in memory for E is 001\\textbullet83. Note that the extra two decimal places to the right of 3 are truncated. Next to be read is a fieldF(1,1) corresponding to F which is declaredas FIXED(5,2). Thus,F(1,1) reads off a single digit, 9, from the card. The value of F stored is 000\\textbullet90. The next 5 card columns are skipped due toX(5). The next instructionspecifies A(3). This means a character field of 3 characters is tobe read off from the card cor-responding to G. Thus, B2G is stored for G. (2 is treated as a character). The next card column is to be skipped be- causeof X(1). Finally, a value CARS is read off for H, corresponding to thespecification A(4). The contents of the memory locations are shown below: Name of the memory location Content of the memory location A -123\\textbullet45 B 123\\textbullet45 C 023\\textbullet40 D 123\\textbullet45 E 011\\textbullet83 F 000\\textbullet90 G B2G H CARS", "ref_id": 4674, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "A PL/I program uses the EDIT form of input. The declare statementof the program is as follows: DCL(A,B,C,D,E,F) FIXED(5,2) ; GCHAR(15)VAR, H CHAR(4) ; A data card used by the program has the following informationpunched on it (Note: The symbolbdenotes a blankspace). \\downarrowcol.8\\downarrowcol.34 AB-123 \\textbullet 45b123 \\textbullet 459123 \\textbullet 456bb12345b18 \\textbullet b 345912345B2GbCARS CARS CARS Show what will be stored in the memory locations correspond-ingto A, B, C, D, E, F, G and H when the followingstatement is executed: GETEDIT(A, B, C, D, E, F, G, H) [COL(10), F(7, 2), F(7, 2), X(2), F(4, 1), COL(34), F(5, 2), X(1), F(6, 3), F(1, 1), X(5), A(3), X(1), A(4)];", "options": ["A 123.45, B -123.45, C 023.40, D 123.45, E 011.83, F 000.90, G B2G, H CARS", "A -123.45, B 123.45, C 023.40, D 123.45, E 011.83, F 000.90, G B2G, H CARS", "A -123.45, B 123.45, C 123.40, D 023.45, E 011.83, F 000.90, G B2G, H CARS", "A -123.45, B 123.45, C 023.40, D 123.45, E 011.83, F 900.90, G B2G, H CARS"], "answer": "B", "solution": "As a result of the GET EDIT statement, the data card will be read in thefollowing manner: All entries on the data card up to col. 10 are ignored. Starting from col. 10, a numerical fieldF(7,2) is read off, for A. Thus, a value -123\\textbullet45 is stored for A. This brings the computer to col. 17 ofthe card. Next, a numeric fieldF(7,2) for B is read off. Thus, a value 123\\textbullet45 is stored for B. This brings the computer to col. 24 of the card. The nextinstruction is X(2), i.e., skip 2 columns. Hence the computer ignores the91, and goes to col. 26 of the card. Now, it must read a numeric field ofF(4,1) corresponding to C. Thus, a value 23\\textbullet4 is read off, and the computercomes to col. 30 of the card. However, C is declared as FIXED(5,2). Therefore, the value 23\\textbullet4 which is read from the card is storedas 023\\textbullet40 in the memory location corresponding to C. The next 4 columns of the card are to be skipped be-cause the programmust jump to col. 34 of the card according to the next instruction. Starting from col. 34, a numeric field ofF(5,2) is to be read. Thus, 12345 are read off from the card and assigned to D. And, as D is specified aformat of F(5,2), therefore 12345 is stored for D as 123\\textbullet45. The program comesto col. 39 Column 39 is skipped due toX(1), and the program reaches col. 40. The next instruction isF(6,3) corresponding to E. So, 1\\textbullet8345 are read fromthe card and assigned to E. However, E is specified a format of F(6,3). The format specifications wants E to be of the form XX\\textbulletXXX. In caseof a conflict between the format specification and the value read from thecard, the value read from the card gets pre-ference. Hence, E becomes 1\\textbullet8345. Now, E is declared asFIXED(5,2). Thus, the memory al-located for E on the basis of the declare statement (DCL) expects E to be of the form XXX\\textbulletXX. Hence, the value stored in memory for E is 001\\textbullet83. Note that the extra two decimal places to the right of 3 are truncated. Next to be read is a fieldF(1,1) corresponding to F which is declaredas FIXED(5,2). Thus,F(1,1) reads off a single digit, 9, from the card. The value of F stored is 000\\textbullet90. The next 5 card columns are skipped due toX(5). The next instructionspecifies A(3). This means a character field of 3 characters is tobe read off from the card cor-responding to G. Thus, B2G is stored for G. (2 is treated as a character). The next card column is to be skipped be- causeof X(1). Finally, a value CARS is read off for H, corresponding to thespecification A(4). The contents of the memory locations are shown below: Name of the memory location Content of the memory location A -123\\textbullet45 B 123\\textbullet45 C 023\\textbullet40 D 123\\textbullet45 E 011\\textbullet83 F 000\\textbullet90 G B2G H CARS"}, "question": "task_1"}}, {"data": {"text": "Question:\nHow is an ARRAY declared inPL/I? Explain using examples.\n\nOptions:\nA. An array in PL/I is declared using the format: DCL ARRAY NAME (DIMENSION ATTRIBUTES) DATA ATTRIBUTES;\nB. An array in PL/I is declared using the format: ARRAY (DIMENSION ATTRIBUTES) NAME DCL DATA ATTRIBUTES;\nC.             An array in PL/I is declared using the format: NAME ARRAY DCL (DIMENSION ATTRIBUTES) DATA ATTRIBUTES;\nD. An array in PL/I is declared using the format: ARRAY NAME DCL (DIMENSION ATTRIBUTES) DATA ATTRIBUTES;\n\nAnswer: A\n\nReference Solution:\nEvery identifier to be used as an array name requires explicit declaration. The declaration must also de-fine the subscripting to be used whenthe array elements are referenced. For declaration of an array variable, the declar-ation has the following format: DCL ARRAY NAME (DIMENSION ATTRIBUTES) DATA ATTRIBUTES; Array names can be any variable names and every element within thearray is referenced by the array name declared. The use of the dimension attribute in an array declara-tion is governedby the following rules. 1. The dimension attribute has the form of one or more boundary specificationsenclosed within a pair of parentheses. If two or more boundaryspecifications are used in the list, they are separated by commas. The number of boundary speci-fications in the dimension attributeestablishes dimensional-ity of the array variable. 2. A boundary specification is composed of two, possib-ly signed, decimalinteger constants, separated by a colon. The first integer value specifiesthe lower bound and the second the upper bound of that particulardimension. For example DECLAREA(-1:2, 8:10); In the above, A is the name of the array. It could have been any other nametoo, e.g., NANCY, PETE, POOR, etc.. But the same name cannot beused to refer to more than one data struc-ture or data item. Also note thatin the above, A is a two dimensional array as there are two boundary, specifications. The first subscript may assume any one of the integer values-1, 0, 1, or 2. The second subscript may assume any one of the integervalues in the range of 8 through 10. Thus, in the first subscript thereare 4 elements and the second sub-script has 3 elements so the arrayA contains 4 \u00d7 3=12 elements. 3. In a boundary specification, the lower bound must have its value lessthan or equal to the value of the upper bound. The dimension attributes, e.g.,(3:5), (-3:0, 0:3), (9:9, 1:1), arewell formed. But, (5:3) is not well formed because the lower bound is greater thanthe higher bound. If the lower bound is not specified it is assumed to havea numeric value of one. For example, the dimension attributes (17,26,5) and (1:17, 1:26, 1:5) areequivalent. 4. The dimension attribute must always appear as the first attribute followingthe variable name declared. Using the above 4 rules a well-formed declare statement can be written. E.g., consider the following declare state-ment: DECLAREB(5,12) FIXED DEC(8,3); The above statement is a well-formeddeclarestatement. It establishes a twodimensional array B, with upper bounds 5 and 12. The elements are fixeddecimal numbers with preci-sion of the type XXXXX.XXX. However, thefollowing declare statement is wrong. DECLARE BFIXED(5,12) DEC(8,3); The machine would be unable to distinguish between dimension and precisionattributes when written as above. The declara-tions for more than onearray can sometimes be condensed. For example, consider the following: DECLARE (A, B, MATRIX) (10, 1:9, -2:5) FLOAT; DECLARE (X FIXED, Y FLOAT) (17, 20); This is how the array structure is declared. In the above, A, B and MATRIX are3-dimensional arrays with 10\u00d79\u00d78=720 elements in each. All theelements have a Float-ing Point number representation. X and Y are both 2-dimensional arrays, each of 17 \u00d7 20 = 340 elements. But, the elements of X have a Fixed Point repre-sentation, and the elements of Y have a Floating Point re-presentation.", "ref_id": 4675, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "How is an ARRAY declared inPL/I? Explain using examples.", "options": ["An array in PL/I is declared using the format: DCL ARRAY NAME (DIMENSION ATTRIBUTES) DATA ATTRIBUTES;", "An array in PL/I is declared using the format: ARRAY (DIMENSION ATTRIBUTES) NAME DCL DATA ATTRIBUTES;", "An array in PL/I is declared using the format: NAME ARRAY DCL (DIMENSION ATTRIBUTES) DATA ATTRIBUTES;", "An array in PL/I is declared using the format: ARRAY NAME DCL (DIMENSION ATTRIBUTES) DATA ATTRIBUTES;"], "answer": "A", "solution": "Every identifier to be used as an array name requires explicit declaration. The declaration must also de-fine the subscripting to be used whenthe array elements are referenced. For declaration of an array variable, the declar-ation has the following format: DCL ARRAY NAME (DIMENSION ATTRIBUTES) DATA ATTRIBUTES; Array names can be any variable names and every element within thearray is referenced by the array name declared. The use of the dimension attribute in an array declara-tion is governedby the following rules. 1. The dimension attribute has the form of one or more boundary specificationsenclosed within a pair of parentheses. If two or more boundaryspecifications are used in the list, they are separated by commas. The number of boundary speci-fications in the dimension attributeestablishes dimensional-ity of the array variable. 2. A boundary specification is composed of two, possib-ly signed, decimalinteger constants, separated by a colon. The first integer value specifiesthe lower bound and the second the upper bound of that particulardimension. For example DECLAREA(-1:2, 8:10); In the above, A is the name of the array. It could have been any other nametoo, e.g., NANCY, PETE, POOR, etc.. But the same name cannot beused to refer to more than one data struc-ture or data item. Also note thatin the above, A is a two dimensional array as there are two boundary, specifications. The first subscript may assume any one of the integer values-1, 0, 1, or 2. The second subscript may assume any one of the integervalues in the range of 8 through 10. Thus, in the first subscript thereare 4 elements and the second sub-script has 3 elements so the arrayA contains 4 \u00d7 3=12 elements. 3. In a boundary specification, the lower bound must have its value lessthan or equal to the value of the upper bound. The dimension attributes, e.g.,(3:5), (-3:0, 0:3), (9:9, 1:1), arewell formed. But, (5:3) is not well formed because the lower bound is greater thanthe higher bound. If the lower bound is not specified it is assumed to havea numeric value of one. For example, the dimension attributes (17,26,5) and (1:17, 1:26, 1:5) areequivalent. 4. The dimension attribute must always appear as the first attribute followingthe variable name declared. Using the above 4 rules a well-formed declare statement can be written. E.g., consider the following declare state-ment: DECLAREB(5,12) FIXED DEC(8,3); The above statement is a well-formeddeclarestatement. It establishes a twodimensional array B, with upper bounds 5 and 12. The elements are fixeddecimal numbers with preci-sion of the type XXXXX.XXX. However, thefollowing declare statement is wrong. DECLARE BFIXED(5,12) DEC(8,3); The machine would be unable to distinguish between dimension and precisionattributes when written as above. The declara-tions for more than onearray can sometimes be condensed. For example, consider the following: DECLARE (A, B, MATRIX) (10, 1:9, -2:5) FLOAT; DECLARE (X FIXED, Y FLOAT) (17, 20); This is how the array structure is declared. In the above, A, B and MATRIX are3-dimensional arrays with 10\u00d79\u00d78=720 elements in each. All theelements have a Float-ing Point number representation. X and Y are both 2-dimensional arrays, each of 17 \u00d7 20 = 340 elements. But, the elements of X have a Fixed Point repre-sentation, and the elements of Y have a Floating Point re-presentation."}, "question": "task_1"}}, {"data": {"text": "Question:\nExplain the basic functions of a base register, and describe howit affects the location of a program segment in the main memoryof the IBM/360-370 computers.\n\nOptions:\nA. A base register aids in the relocation of a program.\nB. A base register decodes the instructions of a program.\nC.             A base register stores the data of a program.\nD. A base register increases the speed of a program.\n\nAnswer: A\n\nReference Solution:\nThe IBM/360-370 computers have 16 general-purpose registers consisting of 32 bits each. Any one of these general-purpose registers can be used as a base register. When a register is used as a base register , the 24 rightmost bits are used as a base address. Only 24 bits are needed for a base address since the main memory of the computer has approximately 2^24 storage locations, and each of our 24 bits represents a power of two. This base is the location at which the program segment was loaded into main memory. Since the base register stores the address of a program in main memory, the location of an entire program may be changed just by altering the contents of this register. Thus, a base re-gister aids in the relocation of a program. Sometimes it is necessary to use more than one base re-gister in a program . This may happen in the implementation of a subroutine. When different base registers are used to address different program segments, the process is referred to as the use of Multiple Base Registers.", "ref_id": 4676, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Explain the basic functions of a base register, and describe howit affects the location of a program segment in the main memoryof the IBM/360-370 computers.", "options": ["A base register aids in the relocation of a program.", "A base register decodes the instructions of a program.", "A base register stores the data of a program.", "A base register increases the speed of a program."], "answer": "A", "solution": "The IBM/360-370 computers have 16 general-purpose registers consisting of 32 bits each. Any one of these general-purpose registers can be used as a base register. When a register is used as a base register , the 24 rightmost bits are used as a base address. Only 24 bits are needed for a base address since the main memory of the computer has approximately 2^24 storage locations, and each of our 24 bits represents a power of two. This base is the location at which the program segment was loaded into main memory. Since the base register stores the address of a program in main memory, the location of an entire program may be changed just by altering the contents of this register. Thus, a base re-gister aids in the relocation of a program. Sometimes it is necessary to use more than one base re-gister in a program . This may happen in the implementation of a subroutine. When different base registers are used to address different program segments, the process is referred to as the use of Multiple Base Registers."}, "question": "task_1"}}, {"data": {"text": "Question:\nGive examples of the following editing procedures in APL. i ) Perform editing on a single instruction of a function. ii) Change the name of the header of a given function. iii) Open a function, exhibit a specific line, then direct program control to this line. iv) Erase a function that is contained in your active workspace.\n\nOptions:\nA. Change RANGE to R, Change header from VARIANCE to RANGE, Amend Line [4], Erase function RANGE\nB. Change AVG to MEAN, Change header from VARIANCE to MEANSQ, Amend Line [5], Erase function AVG\nC.             Change NS to MSQ, Change header from VARIANCE to SDEV, Amend Line [10], Erase function SDEV\nD. Change X1 to X, Change header from VARIANCE to VAR, Amend Line [7], Erase function X1\n\nAnswer: C\n\nReference Solution:\nAssume the following program is in the active workspace: \\nablaVARIANCE [1]'ENTER SAMPLE ELEMENTS' [2]S \\leftarrow X1 X2 .... XN [3]AVG \\leftarrow (+/S) \\div \\Rhos [4]RANGE \\leftarrow (\\Gamma/S) - L/S [5]NS \\leftarrow AVG \u00d7 (+/S) [6]S [7]S2 \\leftarrow S\\textasteriskcentered2 [8]SSQ \\leftarrow (+/S2) [9]VAR \\leftarrow SS2 - NS [10]'THE VARIANCE IS:';VAR [11]\\nabla This program finds the variance of a set of numbers. The procedure is as follows: 1) Let X1, X2,......, XN be a series of observations: X =^N\\sum_i= 1X_i / N VAR = [\\sum(X_i - x)^2]/ [N] = \\sumX_i^2 - [\\sumX_i]^2 / N. The second expression is more easily evaluated and is also more amenable to treatment by APL than the first. i ) Suppose it is desired to change NS to MSQ (Mean Squares) a more descriptive acronym. Key in \\nabla VARIANCE [5 [] 10]. Here [5] is the line number and 10 is the print position, where editing is to begin. Actually NS may be in any print posi-tion (<10) . Backspace until the type ball is below N and enter two slashes followed by a 3. The two slashes erase NS and the 3 allows 3 characters for MSQ. Now, depress the RETURN key. At this point, the fifth line looks as follows: [5]\\leftarrow AVG \u00d7 (+/S) Key in MSQ and then ask for a display of [5]: [5 [] ], which should be [5]MSQ \\leftarrow AVG \u00d7 (+/S) A similar procedure is followed for [9]. ii) Next, suppose it is required to find the standard deviation of the set of numbers. The header can be changed from \\nabla VARIANCE to \\nablaSDEV as follows: \\nabla VARIANCE [0 [] 10] [0]VARIANCE Backspace until the ball is under V and print 8 slashes, followed by 4. Depress the RETURN key to display a blank [0]-line with 4 vacant spaces for a new name. [0] Type SDEV and display the line [0] for a check. It should look like the following [0]SDEV Type DEL to terminate the procedure. To add a line that finds the standard deviation, key in \\nablaSDEV[9.5] SDEV \\leftarrow VAR\\textasteriskcentered.5\\nabla iii) Line [10] should be amended to 'THE STANDARD DEVIATION IS:';SDEV Key in \\nablaSDEV[10 [] ] to get a display of the tenth line: [10]'THE VARIANCE IS:';VAR Key in [10]'THE SDEV IS:';SDEV [11]\\nabla iv) Suppose SDEV is no longer required. The command ) ERASE SDEV deletes it from the active workspace.", "ref_id": 4677, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Give examples of the following editing procedures in APL. i ) Perform editing on a single instruction of a function. ii) Change the name of the header of a given function. iii) Open a function, exhibit a specific line, then direct program control to this line. iv) Erase a function that is contained in your active workspace.", "options": ["Change RANGE to R, Change header from VARIANCE to RANGE, Amend Line [4], Erase function RANGE", "Change AVG to MEAN, Change header from VARIANCE to MEANSQ, Amend Line [5], Erase function AVG", "Change NS to MSQ, Change header from VARIANCE to SDEV, Amend Line [10], Erase function SDEV", "Change X1 to X, Change header from VARIANCE to VAR, Amend Line [7], Erase function X1"], "answer": "C", "solution": "Assume the following program is in the active workspace: \\nablaVARIANCE [1]'ENTER SAMPLE ELEMENTS' [2]S \\leftarrow X1 X2 .... XN [3]AVG \\leftarrow (+/S) \\div \\Rhos [4]RANGE \\leftarrow (\\Gamma/S) - L/S [5]NS \\leftarrow AVG \u00d7 (+/S) [6]S [7]S2 \\leftarrow S\\textasteriskcentered2 [8]SSQ \\leftarrow (+/S2) [9]VAR \\leftarrow SS2 - NS [10]'THE VARIANCE IS:';VAR [11]\\nabla This program finds the variance of a set of numbers. The procedure is as follows: 1) Let X1, X2,......, XN be a series of observations: X =^N\\sum_i= 1X_i / N VAR = [\\sum(X_i - x)^2]/ [N] = \\sumX_i^2 - [\\sumX_i]^2 / N. The second expression is more easily evaluated and is also more amenable to treatment by APL than the first. i ) Suppose it is desired to change NS to MSQ (Mean Squares) a more descriptive acronym. Key in \\nabla VARIANCE [5 [] 10]. Here [5] is the line number and 10 is the print position, where editing is to begin. Actually NS may be in any print posi-tion (<10) . Backspace until the type ball is below N and enter two slashes followed by a 3. The two slashes erase NS and the 3 allows 3 characters for MSQ. Now, depress the RETURN key. At this point, the fifth line looks as follows: [5]\\leftarrow AVG \u00d7 (+/S) Key in MSQ and then ask for a display of [5]: [5 [] ], which should be [5]MSQ \\leftarrow AVG \u00d7 (+/S) A similar procedure is followed for [9]. ii) Next, suppose it is required to find the standard deviation of the set of numbers. The header can be changed from \\nabla VARIANCE to \\nablaSDEV as follows: \\nabla VARIANCE [0 [] 10] [0]VARIANCE Backspace until the ball is under V and print 8 slashes, followed by 4. Depress the RETURN key to display a blank [0]-line with 4 vacant spaces for a new name. [0] Type SDEV and display the line [0] for a check. It should look like the following [0]SDEV Type DEL to terminate the procedure. To add a line that finds the standard deviation, key in \\nablaSDEV[9.5] SDEV \\leftarrow VAR\\textasteriskcentered.5\\nabla iii) Line [10] should be amended to 'THE STANDARD DEVIATION IS:';SDEV Key in \\nablaSDEV[10 [] ] to get a display of the tenth line: [10]'THE VARIANCE IS:';VAR Key in [10]'THE SDEV IS:';SDEV [11]\\nabla iv) Suppose SDEV is no longer required. The command ) ERASE SDEV deletes it from the active workspace."}, "question": "task_1"}}, {"data": {"text": "Question:\nWhat are the basic flags incorporated into a condition code register?State the purpose of each flag.\n\nOptions:\nA. Add, Subtract, Multiply, Divide, Modulus\nB. Carry, Zero, Overflow, Sign, Parity, Half-Carry, Interrupt Enable\nC.             Shift left, Shift right, Rotate left, Rotate right\nD. Input, Output, Store, Load, Jump\n\nAnswer: B\n\nReference Solution:\nEach flag in the condition code register designatesa certain conditioninside the CPU. The flags are the basis for computer decision- makingin conditional instructions such as \"Jump to location 31 if the Accumu-lator is Zero.\" When the computer reads such an instruc-tion it will checkthe flag in the condition code register which designates a zero accumulator. If the flag is 1 the accumulator is zero and the computer jumpsto loca-tion 31. If the flag is 0 the accumulator is not zero and the computerreads the next instruction. As can be seen, the more flags a computerhas in its condition code register, the stronger the computer will bein its decision-making. The basic flags incorporated into a condition register are: 1.Carry:This flag is set to 1 if the last operation generated a carry fromthe most significant bit. 2.Zero:This flag is set to 1 if the last operation resulted in a zero. This flag is often used in loop control and searching for a certain data value. 3.Overflow:This flag is set to 1 if the last opera-tion produced a 2's complementoverflow. 4.Sign:This flag is set to 1 if the most significant bit of the result of thelast operation was 1, desig-nating a negative two's complement number. 5.Parity:This flag is set to 1 if the result of the last operation contains aneven number of l's (sometimes called Even Parity). 6.Half-Carry:This flag is set to 1 if the last opera-tion generated a carryfrom the lower half word to the upper half word. 7.Interrupt Enable: This flag is set to 1 if an inter-rupt is allowed, 0 if not. A computer may have several interrupt enable flags if it has several interruptinputs or levels.", "ref_id": 4678, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "What are the basic flags incorporated into a condition code register?State the purpose of each flag.", "options": ["Add, Subtract, Multiply, Divide, Modulus", "Carry, Zero, Overflow, Sign, Parity, Half-Carry, Interrupt Enable", "Shift left, Shift right, Rotate left, Rotate right", "Input, Output, Store, Load, Jump"], "answer": "B", "solution": "Each flag in the condition code register designatesa certain conditioninside the CPU. The flags are the basis for computer decision- makingin conditional instructions such as \"Jump to location 31 if the Accumu-lator is Zero.\" When the computer reads such an instruc-tion it will checkthe flag in the condition code register which designates a zero accumulator. If the flag is 1 the accumulator is zero and the computer jumpsto loca-tion 31. If the flag is 0 the accumulator is not zero and the computerreads the next instruction. As can be seen, the more flags a computerhas in its condition code register, the stronger the computer will bein its decision-making. The basic flags incorporated into a condition register are: 1.Carry:This flag is set to 1 if the last operation generated a carry fromthe most significant bit. 2.Zero:This flag is set to 1 if the last operation resulted in a zero. This flag is often used in loop control and searching for a certain data value. 3.Overflow:This flag is set to 1 if the last opera-tion produced a 2's complementoverflow. 4.Sign:This flag is set to 1 if the most significant bit of the result of thelast operation was 1, desig-nating a negative two's complement number. 5.Parity:This flag is set to 1 if the result of the last operation contains aneven number of l's (sometimes called Even Parity). 6.Half-Carry:This flag is set to 1 if the last opera-tion generated a carryfrom the lower half word to the upper half word. 7.Interrupt Enable: This flag is set to 1 if an inter-rupt is allowed, 0 if not. A computer may have several interrupt enable flags if it has several interruptinputs or levels."}, "question": "task_1"}}, {"data": {"text": "Question:\nUsing the pertinent information from the previous problem, find the third and fourth standard moments of ungrouped data in an observed distribution.\n\nOptions:\nA. Mean and standard deviation\nB. Skewness and kurtosis\nC.             Third and fourth standard moments\nD. First and second standard moments\n\nAnswer: C\n\nReference Solution:\nThe third and fourth standard moments are dimensionless. Unlike the first and second moments, these incorporate the fraction (X_i - M) / S, which renders these moments independent of units. The third standard moment, W, is a measure of asymmetry or skewnessof the distribution, and the formula is given as: W= {^N\\sum_i=1 [(X_i - M)/S]^3} / N = (1/ S^3) [{N\\sum_i_=1 (X_i - M)^3} / N ] \\sum = {N\\sum_i=1 (X_i - M)^3} / S^3N The fourth standard moment, K, is a measure of peakedness of the distribution curve, and is given by: K= {^N\\sum_i_=1 [(X_i - M)]^4} / N = (1/ S^4)[ {N\\sum_i_=1 (X_i - M)^4} / N ] \\sum = {N\\sum_i_=1 (X_i - M)^4} / S^4N \\sum These equations will now be translated into BASIC, assuming that the mean M and the standard deviation S are known: 1\\O REM COMPUTE THIRD AND FOURTH STANDARD 2\\O REM MOMENTS 3\\O LET Y = \\O 4\\O LET Z = \\O 6\\O READ X 7\\O IF X < \\O THEN 12\\O 8\\O LET Y = Y + (X - M)\\uparrow3 9\\O LET Z = Z + (X - M)\\uparrow4 11\\O GO TO 6\\O 12\\O LET W = Y / (S\\uparrow3 \\textasteriskcentered N) 13\\O LET K = Z / (S\\uparrow4 \\textasteriskcentered N) 14\\O REM PRINT OUT RESULTS 15\\O PRINT \"N =\"; N 16\\O PRINT \"3RD STANDARD MOMENT =\"; W 17\\O PRINT \"4TH STANDARD MOMENT =\"; K 18\\O DATA 75, 22, 14, 83, 16, 12, 17, -1 19\\O END Note, that the value of N is not specified in the program. One can either substitute N with a specific value, or add a READ N and DATA... statements.", "ref_id": 4679, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Using the pertinent information from the previous problem, find the third and fourth standard moments of ungrouped data in an observed distribution.", "options": ["Mean and standard deviation", "Skewness and kurtosis", "Third and fourth standard moments", "First and second standard moments"], "answer": "C", "solution": "The third and fourth standard moments are dimensionless. Unlike the first and second moments, these incorporate the fraction (X_i - M) / S, which renders these moments independent of units. The third standard moment, W, is a measure of asymmetry or skewnessof the distribution, and the formula is given as: W= {^N\\sum_i=1 [(X_i - M)/S]^3} / N = (1/ S^3) [{N\\sum_i_=1 (X_i - M)^3} / N ] \\sum = {N\\sum_i=1 (X_i - M)^3} / S^3N The fourth standard moment, K, is a measure of peakedness of the distribution curve, and is given by: K= {^N\\sum_i_=1 [(X_i - M)]^4} / N = (1/ S^4)[ {N\\sum_i_=1 (X_i - M)^4} / N ] \\sum = {N\\sum_i_=1 (X_i - M)^4} / S^4N \\sum These equations will now be translated into BASIC, assuming that the mean M and the standard deviation S are known: 1\\O REM COMPUTE THIRD AND FOURTH STANDARD 2\\O REM MOMENTS 3\\O LET Y = \\O 4\\O LET Z = \\O 6\\O READ X 7\\O IF X < \\O THEN 12\\O 8\\O LET Y = Y + (X - M)\\uparrow3 9\\O LET Z = Z + (X - M)\\uparrow4 11\\O GO TO 6\\O 12\\O LET W = Y / (S\\uparrow3 \\textasteriskcentered N) 13\\O LET K = Z / (S\\uparrow4 \\textasteriskcentered N) 14\\O REM PRINT OUT RESULTS 15\\O PRINT \"N =\"; N 16\\O PRINT \"3RD STANDARD MOMENT =\"; W 17\\O PRINT \"4TH STANDARD MOMENT =\"; K 18\\O DATA 75, 22, 14, 83, 16, 12, 17, -1 19\\O END Note, that the value of N is not specified in the program. One can either substitute N with a specific value, or add a READ N and DATA... statements."}, "question": "task_1"}}, {"data": {"text": "Question:\nExamine the following program and explain the usage of Subprograms (i.e., Subroutines) COMPLEX X1, X2 COMM0N/QUADR/X1, X2, A,B,C DATA INPUT /60/ 7STOP END SUBROUTINE ROOTS COMPLEX X1, X2, W COMMON/QUADR/X1, X2, C1, C2, C3 W = C2 {_\\ast}{_\\ast} 2 - 4.0 {_\\ast} C1 {_\\ast} C3 W = W {_\\ast}{_\\ast} 0.5 X1 = (-C2 + W) / (2.0 {_\\ast} C1) X2 = (-C2 - W) / (2.0 {_\\ast} C1) RETURN END\n\nOptions:\nA. A subroutine in the program begins with a statement of the form SUBROUTINE NAME, must contain at least one RETURN statement, and must have END as its last statement. It is entered from another program unit by means of a CALL statement and may assign values to one or more of its arguments to return results to the main part of the program. It can also store results in COMMON AREA for other program units.\nB. Subroutines are only used in the main part of the program\nC.             Subroutines do not return any results\nD. Subroutines are used to perform repetitive tasks in the program\n\nAnswer: A\n\nReference Solution:\nThis is a complete program which consists of a MAIN PART and a SUBPROGRAM. The MAIN part reads in data for the coefficients of a quadratic equation and then calls upon a subprogram to find its roots. The following points are significant in examining the program. common block named QUADR. QUADR - X1, X2, C1, C2, and C3. Getting into a more detailed explana-tion of Subprograms: Every subroutine program begins with a statement of the form SUBROUTINE NAME. There should be at least one blank space between the word SUBROUTINE and its name. The name of the subroutine must not appear anywhere else within the subprogram. Every subprogram has END as its last statement, and must contain at least one RETURN statement in order to continue the execution of the MAIN program from the next statement after the one that called this subroutine. A subroutine is entered from another program unit (main program or a different program) by means of a CALL statement. The general form of the CALL statement is: CALL name of the subroutine A subroutine may assign values to one or more of its arguments in order to \"return\" results to the main part of the program. Furthermore, there is the possibility of storing results in COMMON AREA so that values obtained in a subprogram could be available to other program units.", "ref_id": 4680, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Examine the following program and explain the usage of Subprograms (i.e., Subroutines) COMPLEX X1, X2 COMM0N/QUADR/X1, X2, A,B,C DATA INPUT /60/ 7STOP END SUBROUTINE ROOTS COMPLEX X1, X2, W COMMON/QUADR/X1, X2, C1, C2, C3 W = C2 {_\\ast}{_\\ast} 2 - 4.0 {_\\ast} C1 {_\\ast} C3 W = W {_\\ast}{_\\ast} 0.5 X1 = (-C2 + W) / (2.0 {_\\ast} C1) X2 = (-C2 - W) / (2.0 {_\\ast} C1) RETURN END", "options": ["A subroutine in the program begins with a statement of the form SUBROUTINE NAME, must contain at least one RETURN statement, and must have END as its last statement. It is entered from another program unit by means of a CALL statement and may assign values to one or more of its arguments to return results to the main part of the program. It can also store results in COMMON AREA for other program units.", "Subroutines are only used in the main part of the program", "Subroutines do not return any results", "Subroutines are used to perform repetitive tasks in the program"], "answer": "A", "solution": "This is a complete program which consists of a MAIN PART and a SUBPROGRAM. The MAIN part reads in data for the coefficients of a quadratic equation and then calls upon a subprogram to find its roots. The following points are significant in examining the program. common block named QUADR. QUADR - X1, X2, C1, C2, and C3. Getting into a more detailed explana-tion of Subprograms: Every subroutine program begins with a statement of the form SUBROUTINE NAME. There should be at least one blank space between the word SUBROUTINE and its name. The name of the subroutine must not appear anywhere else within the subprogram. Every subprogram has END as its last statement, and must contain at least one RETURN statement in order to continue the execution of the MAIN program from the next statement after the one that called this subroutine. A subroutine is entered from another program unit (main program or a different program) by means of a CALL statement. The general form of the CALL statement is: CALL name of the subroutine A subroutine may assign values to one or more of its arguments in order to \"return\" results to the main part of the program. Furthermore, there is the possibility of storing results in COMMON AREA so that values obtained in a subprogram could be available to other program units."}, "question": "task_1"}}, {"data": {"text": "Question:\nWhat is the output for the following FORTRAN program? DIMENSION A (8) , PTR (8) DATA A/'A', 'S', 'E', 'Q', 'N', 'U', 'T', '1'/ DATA PTR/4,7,2,6,6,3,0,5/ I = PTR (1) 20IF (I.EQ.0) GO TO 30 WRITE (5,100) A (I) 100FORMAT (1X,A1) I = PTR (I) GO TO 20 30CONTINUE STOP END\n\nOptions:\nA. QUSET\nB. QUEST\nC.             SETQU\nD. USEQT\n\nAnswer: B\n\nReference Solution:\nThis is an elementary problem using pointers. The object is to introduce pointers in a simple way by allowing you to \"walk\" through the program to find the output. The first executable statement puts the first value of the array PTR in the variable I. If you look at the DATA statement for PTR, you will notice that PTR (1) is 4. I is not equal to zero, so control passes to the WRITE statement, which indicates that the element in A(4) should be outputted. This, as indicated by the DATA statement for A, is repre-sented by the letter Q. Next, the value contained in PTR (4) replaces the initial value of I. The number 6 is in the position of PTR (4) now. Control then passes back to statement 20, and the loop continues until PTR (I) reaches a value of zero. Notice that termination will occur when PTR (7) stores 0 in I. The final output requires only five passes until termination. Fol-low the program and you will see that your \"quest\" for the answer will not be difficult at all. I^th element of A(I) PTR(I) A(I) 4th 6th 3rd 2nd 7th 4 6 3 2 7 Q U E S T", "ref_id": 4681, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "What is the output for the following FORTRAN program? DIMENSION A (8) , PTR (8) DATA A/'A', 'S', 'E', 'Q', 'N', 'U', 'T', '1'/ DATA PTR/4,7,2,6,6,3,0,5/ I = PTR (1) 20IF (I.EQ.0) GO TO 30 WRITE (5,100) A (I) 100FORMAT (1X,A1) I = PTR (I) GO TO 20 30CONTINUE STOP END", "options": ["QUSET", "QUEST", "SETQU", "USEQT"], "answer": "B", "solution": "This is an elementary problem using pointers. The object is to introduce pointers in a simple way by allowing you to \"walk\" through the program to find the output. The first executable statement puts the first value of the array PTR in the variable I. If you look at the DATA statement for PTR, you will notice that PTR (1) is 4. I is not equal to zero, so control passes to the WRITE statement, which indicates that the element in A(4) should be outputted. This, as indicated by the DATA statement for A, is repre-sented by the letter Q. Next, the value contained in PTR (4) replaces the initial value of I. The number 6 is in the position of PTR (4) now. Control then passes back to statement 20, and the loop continues until PTR (I) reaches a value of zero. Notice that termination will occur when PTR (7) stores 0 in I. The final output requires only five passes until termination. Fol-low the program and you will see that your \"quest\" for the answer will not be difficult at all. I^th element of A(I) PTR(I) A(I) 4th 6th 3rd 2nd 7th 4 6 3 2 7 Q U E S T"}, "question": "task_1"}}, {"data": {"text": "Question:\nAn item worth $30,000 initially and having a life of 15 years isdepreciated according to the double declining balance method. Calculate the amount of depreciation in each of the firstfive years.\n\nOptions:\nA. The depreciation is calculated using sum of the years' digits method.\nB. The depreciation for each year is the same.\nC.             The depreciation for each of the first five years is calculated using the double declining balance method and stored in an array A.\nD. The depreciation is calculated using the straight-line method.\n\nAnswer: C\n\nReference Solution:\nThe depreciation during the nth year can be expressed as D = (2C/N) [1 - (2/N)] ^n-1 where D is the depreciation for a particular year. C is the original cost. N is the life span of the machine. nis the particular year for which we are calculating the depreciation. Hence wecamwrite a statement function to compute D. values of D for n = 1,2,3,4,5will be stored in an array A. DIMENSION A (5) REAL D, C, N, K DO 100 J = 1,5 A (J) = D (30000.,15., J) 100CONTINUE END FUNCTION D (C, N, K) D = 2{_\\ast}C/N{_\\ast} (1.-2./N){_\\ast}{_\\ast}(K-1.) RETURN END", "ref_id": 4682, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "An item worth $30,000 initially and having a life of 15 years isdepreciated according to the double declining balance method. Calculate the amount of depreciation in each of the firstfive years.", "options": ["The depreciation is calculated using sum of the years' digits method.", "The depreciation for each year is the same.", "The depreciation for each of the first five years is calculated using the double declining balance method and stored in an array A.", "The depreciation is calculated using the straight-line method."], "answer": "C", "solution": "The depreciation during the nth year can be expressed as D = (2C/N) [1 - (2/N)] ^n-1 where D is the depreciation for a particular year. C is the original cost. N is the life span of the machine. nis the particular year for which we are calculating the depreciation. Hence wecamwrite a statement function to compute D. values of D for n = 1,2,3,4,5will be stored in an array A. DIMENSION A (5) REAL D, C, N, K DO 100 J = 1,5 A (J) = D (30000.,15., J) 100CONTINUE END FUNCTION D (C, N, K) D = 2{_\\ast}C/N{_\\ast} (1.-2./N){_\\ast}{_\\ast}(K-1.) RETURN END"}, "question": "task_1"}}, {"data": {"text": "Question:\nWrite a FORTRAN program to set up a direct-access file with one record for each of 1,869 students in a school. Assume that the students have been assigned identification numbers from 1 to 1,869. Allow some extra space for expansion of student population as well as for expansion of items within a student record.\n\nOptions:\nA. DEFINE FILE 12(2000, 150, E, INT)\nB. DEFINE FILE 12(1869, 150, E, INT)\nC.             DEFINE FILE 12(2000, 100, E, INT)\nD. DEFINE FILE 12(1800, 150, E, INT)\n\nAnswer: A\n\nReference Solution:\nThis problem introduces the DEFINE FILE statement along with the associated WRITE statement. This statement takes the form DEFINE FILE N1 (NREC, NRECL, E, INT) where N1 is a unit number (for restrictions on N1 see your computer installation manual), NREC is the number of records, NRECL is the record length in bytes, E stands for format control, and INT is an associated variable which is the index to the next sequential record in the file following a READ or WRITE operation. The form of the WRITE statement is WRITE (UNIT, INDEX, FMT) LIST UNIT is an integer variable, or integer constant four spaces long, which has a value between 1 and 99 and which corresponds to the file to be written. This file must have been previously defined with a DEFINE FILE statement. The INDEX is an integer expression whose value indicates the index of the record to be written. FMT is a statement number which refers to the FORMAT statement to be used. Finally, LIST defines the data to be written, and usually contains one or more FORTRAN variable names separated by commas. INTEGER STUDNO, NAME (5) DEFINE FILE 12(2000, 150, E, INT) DO 22 I = 1, 1869 READ 3, STUDNO, NAME 22WRITE (12 , STUDNO, 4) NAME 3FORMAT (I4, 5A4) 4FORMAT (5A4) STOP END", "ref_id": 4683, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Write a FORTRAN program to set up a direct-access file with one record for each of 1,869 students in a school. Assume that the students have been assigned identification numbers from 1 to 1,869. Allow some extra space for expansion of student population as well as for expansion of items within a student record.", "options": ["DEFINE FILE 12(2000, 150, E, INT)", "DEFINE FILE 12(1869, 150, E, INT)", "DEFINE FILE 12(2000, 100, E, INT)", "DEFINE FILE 12(1800, 150, E, INT)"], "answer": "A", "solution": "This problem introduces the DEFINE FILE statement along with the associated WRITE statement. This statement takes the form DEFINE FILE N1 (NREC, NRECL, E, INT) where N1 is a unit number (for restrictions on N1 see your computer installation manual), NREC is the number of records, NRECL is the record length in bytes, E stands for format control, and INT is an associated variable which is the index to the next sequential record in the file following a READ or WRITE operation. The form of the WRITE statement is WRITE (UNIT, INDEX, FMT) LIST UNIT is an integer variable, or integer constant four spaces long, which has a value between 1 and 99 and which corresponds to the file to be written. This file must have been previously defined with a DEFINE FILE statement. The INDEX is an integer expression whose value indicates the index of the record to be written. FMT is a statement number which refers to the FORMAT statement to be used. Finally, LIST defines the data to be written, and usually contains one or more FORTRAN variable names separated by commas. INTEGER STUDNO, NAME (5) DEFINE FILE 12(2000, 150, E, INT) DO 22 I = 1, 1869 READ 3, STUDNO, NAME 22WRITE (12 , STUDNO, 4) NAME 3FORMAT (I4, 5A4) 4FORMAT (5A4) STOP END"}, "question": "task_1"}}, {"data": {"text": "Question:\nWrite a FORTRAN program that outputs the customer's name and account number, the number of message units used, the arrears, and the total bill. The rate schedule should be 10 cents per message unit up to 75, and 8 cents per message unit beyond 75.\n\nOptions:\nA. READ (2,101)NAME, NUMCUS, MSGS, ARREAR\nB. INTEGER NAME (12), NUMCUS, MSGS, BLANK, 1TOTBIL BLANK = '\\square' 5READ (2,101)NAME, NUMCUS, MSGS, ARREAR 101PORMAT(12A1,I7,2X,I5,7X,I6) CIF FIRST COLUMN IS BLANK, ENDPROGRAM IF (NAME (1).EQ.BLANK)GO TO 25 C10 CENTS PER MESSAGE UNIT PLUS ARREARS TOTBIL = 10{_\\ast}MSGS + ARREAR CDISCOUNT FOR MSGS OVER 75 IF (MSGS.GT.75) TOTBIL = TOTBIL - 8{_\u0007st}(MSGS - 75) WRITE (6,102) NAME, NUMCUS, MSGS, ARREAR, TOTBIL 102FORMAT (1X, 12A1,2X, 17/17,'MSG UNITS',3X, I6, 1'CENTS ARREARS'/'AMOUNT DUE', 17,'CENTS'/) GO TO 5 25CONTINUE STOP END\nC.             TOTBIL = 10{_\u0007st}MSGS + ARREAR\nD. IF (NAME (1).EQ.BLANK)GO TO 25\n\nAnswer: B\n\nReference Solution:\nThis is a telephone billing scheme which excludeslong-distance calls. We read in the cards, each of which contains the following information: Variable description Number of spaces per card NAME NUMCUS MSGS ARREAR customer name customer number message units arrears 12 7 5 6 Program control is managed by a loop through which each card is read. If a blank space appears in the first space of NAME, control passes out of the loop, and the program terminates. The rest of the logic is a straightforward computation of the billing rates described above. Appropriate messages and headings will be contained in the output. Integer arithmetic is used for simplicity's sake. INTEGER NAME (12), NUMCUS, MSGS, BLANK, 1TOTBIL BLANK = '\\square' 5READ (2,101)NAME, NUMCUS, MSGS, ARREAR 101PORMAT(12A1,I7,2X,I5,7X,I6) CIF FIRST COLUMN IS BLANK, ENDPROGRAM IF (NAME (1).EQ.BLANK)GO TO 25 C10 CENTS PER MESSAGE UNIT PLUS ARREARS TOTBIL = 10{_\\ast}MSGS + ARREAR CDISCOUNT FOR MSGS OVER 75 IF (MSGS.GT.75) TOTBIL = TOTBIL - 8{_\\ast}(MSGS - 75) WRITE (6,102) NAME, NUMCUS, MSGS, ARREAR, TOTBIL 102FORMAT (1X, 12A1,2X, 17/17,'MSG UNITS',3X, I6, 1'CENTS ARREARS'/'AMOUNT DUE', 17,'CENTS'/) GO TO 5 25CONTINUE STOP END", "ref_id": 4684, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Write a FORTRAN program that outputs the customer's name and account number, the number of message units used, the arrears, and the total bill. The rate schedule should be 10 cents per message unit up to 75, and 8 cents per message unit beyond 75.", "options": ["READ (2,101)NAME, NUMCUS, MSGS, ARREAR", "INTEGER NAME (12), NUMCUS, MSGS, BLANK, 1TOTBIL BLANK = '\\square' 5READ (2,101)NAME, NUMCUS, MSGS, ARREAR 101PORMAT(12A1,I7,2X,I5,7X,I6) CIF FIRST COLUMN IS BLANK, ENDPROGRAM IF (NAME (1).EQ.BLANK)GO TO 25 C10 CENTS PER MESSAGE UNIT PLUS ARREARS TOTBIL = 10{_\\ast}MSGS + ARREAR CDISCOUNT FOR MSGS OVER 75 IF (MSGS.GT.75) TOTBIL = TOTBIL - 8{_\u0007st}(MSGS - 75) WRITE (6,102) NAME, NUMCUS, MSGS, ARREAR, TOTBIL 102FORMAT (1X, 12A1,2X, 17/17,'MSG UNITS',3X, I6, 1'CENTS ARREARS'/'AMOUNT DUE', 17,'CENTS'/) GO TO 5 25CONTINUE STOP END", "TOTBIL = 10{_\u0007st}MSGS + ARREAR", "IF (NAME (1).EQ.BLANK)GO TO 25"], "answer": "B", "solution": "This is a telephone billing scheme which excludeslong-distance calls. We read in the cards, each of which contains the following information: Variable description Number of spaces per card NAME NUMCUS MSGS ARREAR customer name customer number message units arrears 12 7 5 6 Program control is managed by a loop through which each card is read. If a blank space appears in the first space of NAME, control passes out of the loop, and the program terminates. The rest of the logic is a straightforward computation of the billing rates described above. Appropriate messages and headings will be contained in the output. Integer arithmetic is used for simplicity's sake. INTEGER NAME (12), NUMCUS, MSGS, BLANK, 1TOTBIL BLANK = '\\square' 5READ (2,101)NAME, NUMCUS, MSGS, ARREAR 101PORMAT(12A1,I7,2X,I5,7X,I6) CIF FIRST COLUMN IS BLANK, ENDPROGRAM IF (NAME (1).EQ.BLANK)GO TO 25 C10 CENTS PER MESSAGE UNIT PLUS ARREARS TOTBIL = 10{_\\ast}MSGS + ARREAR CDISCOUNT FOR MSGS OVER 75 IF (MSGS.GT.75) TOTBIL = TOTBIL - 8{_\\ast}(MSGS - 75) WRITE (6,102) NAME, NUMCUS, MSGS, ARREAR, TOTBIL 102FORMAT (1X, 12A1,2X, 17/17,'MSG UNITS',3X, I6, 1'CENTS ARREARS'/'AMOUNT DUE', 17,'CENTS'/) GO TO 5 25CONTINUE STOP END"}, "question": "task_1"}}, {"data": {"text": "Question:\nDIMENSION A(10,10,10) Assuming that elements of the array are stored in lexicographic order of their indices, find displacements of the locations of: (a) A(5,6,7)(b) A(10,9,8)(c) A(1,5,9) relative to the location of A(1,1,1).\n\nOptions:\nA. 345, 987, 48\nB. 456, 987, 48\nC.             456, 879, 48\nD. 456, 987, 84\n\nAnswer: B\n\nReference Solution:\nIn the previous problem, it was shown that if A has dimen-sions n_1 \u00d7 n_2 \u00d7 n_3, the location of any element A(I,J,K) is given by: loc(I,J,K) = loc(1,1,1) + (I\\rule{1em}{1pt}1)n_2n_3 + (J\\rule{1em}{1pt}1)n_3 + (K\\rule{1em}{1pt}1), assuming that elements are stored in lexicographic order of their indices. The displacement of the location of the element A(I,J,K) relative to the location of A(1,1,1), therefore, is given by: disp(I,J,K) = loc(I,J,K) \\rule{1em}{1pt} loc(1,1,1) = (I\\rule{1em}{1pt}1)n_2n_3 + (J\\rule{1em}{1pt}1)n_3 + (K\\rule{1em}{1pt}1)(1) We are given that n_1 = n_2 = n_3 = 10. (a) Here I = 5, J = 6, K = 7. Substitution into equation (1) yields: disp(5,6,7) = (5-1) (10\\bullet10) + (6\\rule{1em}{1pt}1)10 + (7\\rule{1em}{1pt}1) = (4)100 + (5)10 + 6 = 456 (b) Here I = 10, J = 9, K = 8. Substituting into equation (1) gives us: disp(10,9,8) = (10\\rule{1em}{1pt}1) (10 10) + (9\\rule{1em}{1pt}1) 10 + (8\\rule{1em}{1pt}1) = (9)100 + (8)10 + 7 = 987 (c) Here I = 1, J = 5, K = 9. Substituting into equation (1), we have: disp(1,5,9) = (1\\rule{1em}{1pt}1) (10\\bullet10) + (5\\rule{1em}{1pt}1)10 + (9\\rule{1em}{1pt}1) = (0)(100) + (4)(10) + 8 = 48", "ref_id": 4685, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "DIMENSION A(10,10,10) Assuming that elements of the array are stored in lexicographic order of their indices, find displacements of the locations of: (a) A(5,6,7)(b) A(10,9,8)(c) A(1,5,9) relative to the location of A(1,1,1).", "options": ["345, 987, 48", "456, 987, 48", "456, 879, 48", "456, 987, 84"], "answer": "B", "solution": "In the previous problem, it was shown that if A has dimen-sions n_1 \u00d7 n_2 \u00d7 n_3, the location of any element A(I,J,K) is given by: loc(I,J,K) = loc(1,1,1) + (I\\rule{1em}{1pt}1)n_2n_3 + (J\\rule{1em}{1pt}1)n_3 + (K\\rule{1em}{1pt}1), assuming that elements are stored in lexicographic order of their indices. The displacement of the location of the element A(I,J,K) relative to the location of A(1,1,1), therefore, is given by: disp(I,J,K) = loc(I,J,K) \\rule{1em}{1pt} loc(1,1,1) = (I\\rule{1em}{1pt}1)n_2n_3 + (J\\rule{1em}{1pt}1)n_3 + (K\\rule{1em}{1pt}1)(1) We are given that n_1 = n_2 = n_3 = 10. (a) Here I = 5, J = 6, K = 7. Substitution into equation (1) yields: disp(5,6,7) = (5-1) (10\\bullet10) + (6\\rule{1em}{1pt}1)10 + (7\\rule{1em}{1pt}1) = (4)100 + (5)10 + 6 = 456 (b) Here I = 10, J = 9, K = 8. Substituting into equation (1) gives us: disp(10,9,8) = (10\\rule{1em}{1pt}1) (10 10) + (9\\rule{1em}{1pt}1) 10 + (8\\rule{1em}{1pt}1) = (9)100 + (8)10 + 7 = 987 (c) Here I = 1, J = 5, K = 9. Substituting into equation (1), we have: disp(1,5,9) = (1\\rule{1em}{1pt}1) (10\\bullet10) + (5\\rule{1em}{1pt}1)10 + (9\\rule{1em}{1pt}1) = (0)(100) + (4)(10) + 8 = 48"}, "question": "task_1"}}, {"data": {"text": "Question:\nWrite a FORTRAN program to calculate depreciation by the sum of the years digits method.\n\nOptions:\nA. The program calculates the depreciation by the double declining balance method.\nB. The program calculates depreciation by the straight line method.\nC.             The FORTRAN program calculates the depreciation by the sum of the years digits method.\nD. The program calculates the depreciation by the units of production method.\n\nAnswer: C\n\nReference Solution:\nThe Internal Revenue Service allows various methods for calculating the depreciation on a piece of machinery. The simplest is the straight-line method. According to this method, if an article costs $1000, has an estimated life of 10 years and $0 scrap value, the depreciation per year will be $100 for 10 years. The straight-line method assumes that machines wear out at a constant rate. The sum of the years digit method on the other hand, is used to compute the depreciation on articles that have the greatest rate of depreciation during the first few years of use. For example, suppose a drilling machine costing $15,000, has a useful life of five years and can be resold for $5,000. The total depreciation is: 15,000cost -5,000trade-in 10,000depreciation The sum of the years 1 through 5 is 1+2+3+4+5 = 15. Thus, the depreciation for the first year is 5/15, for the second year, 4/15, etc. Year Depreciation Book value at the end of the year 1 2 3 4 5 5/15 of 10,000 = 3333.33 4/15 of 10,000 = 2666.67 3/15 of 10,000 = 2000 2/15 of 10,000 = 1333.33 1/15 of 10,000 = 666.67 15,000 - 3333.33= 11666.67 11666.67 - 2666.67 = 9000.00 9000 - 2000= 7000.00 7000 -1333.33= 5666.67 5666.67 -666.67= 5000 The program follows: DIM V(100) READ IYR, COST, SAL TDEP = COST - SAL KSUM = 0 JTIME = IYR 20KSUM = KSUM + JTIME IF (JTIME.EQ.O) GOTO 50 JTIME = JTIME - 1 GOTO 20 50DO 60 I = 1,IYR J = IYR - I + 1 FRA = J/KSUM V(I) = COST - FRA {_\\ast} TDEP 60CONTINUE STOP END Program Comments : The READ statement reads in the number of years, the cost of the item, and the salvage value, respectively. TDEP stores the total value to be depreciated. The loop starting at statement 20 calculates the sum of the years. If the number of years IYR, equals 5, then JTIME = 5,4,3,2,1,0 and KSUM = 5+4+3+2+1 = 15. When JTIME = 0, signifying that the sum of years has been calculated, the program jumps to statement 50. This loop first calculates the FRA, the fractional amount of depreciation for each year, and V(I), the book value for each year.", "ref_id": 4686, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Write a FORTRAN program to calculate depreciation by the sum of the years digits method.", "options": ["The program calculates the depreciation by the double declining balance method.", "The program calculates depreciation by the straight line method.", "The FORTRAN program calculates the depreciation by the sum of the years digits method.", "The program calculates the depreciation by the units of production method."], "answer": "C", "solution": "The Internal Revenue Service allows various methods for calculating the depreciation on a piece of machinery. The simplest is the straight-line method. According to this method, if an article costs $1000, has an estimated life of 10 years and $0 scrap value, the depreciation per year will be $100 for 10 years. The straight-line method assumes that machines wear out at a constant rate. The sum of the years digit method on the other hand, is used to compute the depreciation on articles that have the greatest rate of depreciation during the first few years of use. For example, suppose a drilling machine costing $15,000, has a useful life of five years and can be resold for $5,000. The total depreciation is: 15,000cost -5,000trade-in 10,000depreciation The sum of the years 1 through 5 is 1+2+3+4+5 = 15. Thus, the depreciation for the first year is 5/15, for the second year, 4/15, etc. Year Depreciation Book value at the end of the year 1 2 3 4 5 5/15 of 10,000 = 3333.33 4/15 of 10,000 = 2666.67 3/15 of 10,000 = 2000 2/15 of 10,000 = 1333.33 1/15 of 10,000 = 666.67 15,000 - 3333.33= 11666.67 11666.67 - 2666.67 = 9000.00 9000 - 2000= 7000.00 7000 -1333.33= 5666.67 5666.67 -666.67= 5000 The program follows: DIM V(100) READ IYR, COST, SAL TDEP = COST - SAL KSUM = 0 JTIME = IYR 20KSUM = KSUM + JTIME IF (JTIME.EQ.O) GOTO 50 JTIME = JTIME - 1 GOTO 20 50DO 60 I = 1,IYR J = IYR - I + 1 FRA = J/KSUM V(I) = COST - FRA {_\\ast} TDEP 60CONTINUE STOP END Program Comments : The READ statement reads in the number of years, the cost of the item, and the salvage value, respectively. TDEP stores the total value to be depreciated. The loop starting at statement 20 calculates the sum of the years. If the number of years IYR, equals 5, then JTIME = 5,4,3,2,1,0 and KSUM = 5+4+3+2+1 = 15. When JTIME = 0, signifying that the sum of years has been calculated, the program jumps to statement 50. This loop first calculates the FRA, the fractional amount of depreciation for each year, and V(I), the book value for each year."}, "question": "task_1"}}, {"data": {"text": "Question:\nDetermine the output of the following program READ (2, 3) I, J 3FORMAT (2I11) IF (I - J) 5,6,6 6WRITE (3,10) I 10FORMAT (1X, I11) GO TO 7 5WRITE (3,10) J 7STOP\n\nOptions:\nA. Prints out the smallest of two numbers\nB. Calculates the difference of two numbers\nC.             Prints out the largest of two numbers\nD. Calculates the sum of two numbers\n\nAnswer: C\n\nReference Solution:\nTo analyze the program, start from the top. The READ state-ment tells the computer to use the \"card reader\" for reading in the values I and J which are specified by the following FORMAT statement, identified by the number 3. The FORMAT statement states that there are eleven columns used on the card for recording each number input (i.e., 2I11). Every blank space among eleven reserved is equivalent to zero. Naturally, zeros before the first digit of the number have no effect on the number, while each blank space at the end increases the number ten times. \"IF\", is a CONTROL statement. In this problem it has the form IF(e)a, b, c, where e is an expression to be evaluated (in this case: I-J), and a, b, c are three statement numbers. The meaning of such statement is as follows: executed is the onelabelleda. executed is the onelabelledb. executed is the onelabelledc. Therefore, in the program, if the value of I-J is negative, the next statement to be executed is the one numbered 5, which causes the output of J. Following this the STOP statement is executed. If the value of I - J is zero or positive, the next statement to be executed is the one numbered 6,which causes the output of the value of I. The statement following this is another control statement \"GO TO\". This statement causes a jump in program execution and program pointer goes directly to the statement which is specified by a number following GO TO statement. Therefore it is clear that the program finds and prints out the largest of two numbers.", "ref_id": 4687, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Determine the output of the following program READ (2, 3) I, J 3FORMAT (2I11) IF (I - J) 5,6,6 6WRITE (3,10) I 10FORMAT (1X, I11) GO TO 7 5WRITE (3,10) J 7STOP", "options": ["Prints out the smallest of two numbers", "Calculates the difference of two numbers", "Prints out the largest of two numbers", "Calculates the sum of two numbers"], "answer": "C", "solution": "To analyze the program, start from the top. The READ state-ment tells the computer to use the \"card reader\" for reading in the values I and J which are specified by the following FORMAT statement, identified by the number 3. The FORMAT statement states that there are eleven columns used on the card for recording each number input (i.e., 2I11). Every blank space among eleven reserved is equivalent to zero. Naturally, zeros before the first digit of the number have no effect on the number, while each blank space at the end increases the number ten times. \"IF\", is a CONTROL statement. In this problem it has the form IF(e)a, b, c, where e is an expression to be evaluated (in this case: I-J), and a, b, c are three statement numbers. The meaning of such statement is as follows: executed is the onelabelleda. executed is the onelabelledb. executed is the onelabelledc. Therefore, in the program, if the value of I-J is negative, the next statement to be executed is the one numbered 5, which causes the output of J. Following this the STOP statement is executed. If the value of I - J is zero or positive, the next statement to be executed is the one numbered 6,which causes the output of the value of I. The statement following this is another control statement \"GO TO\". This statement causes a jump in program execution and program pointer goes directly to the statement which is specified by a number following GO TO statement. Therefore it is clear that the program finds and prints out the largest of two numbers."}, "question": "task_1"}}, {"data": {"text": "Question:\nA chemist has two reactants, P and Q, dissolved in one liter ofwater. The amounts of P and Q present are p grams and qgrams, respectively, and they are combining to form 2 apq gramsof the product R each second. It is also known that thereaction is reversible: in each second, 2br grams of R arebreaking up into br grams of each P and Q. In summary, thechange in one second is: - -amountof P increases by br - apq -amountof Q increases by br - apq -amountof R increases by 2apq - 2br . Design a program to simulate this reaction.\n\nOptions:\nA. dp/dt= br + apq, dq/ dt = br + apq, dr/ dt = 2br + 2apq\nB. dp/dt= br - apq, dq/ dt = br - apq, dr/ dt = - 2br + 2apq\nC.             dp/dt= br - apq, dq/ dt = br + apq, dr/ dt = - 2br - 2apq\nD. dp/dt= br - apq, dq/ dt = br - apq, dr/ dt = - 2br - 2apq\n\nAnswer: B\n\nReference Solution:\nThis reaction is actually continuous. One second divisions are used forconvenience. In general, at any time interval h, the amounts of P,Q, andR are as follows: p(t + h) = p(t) + hbr(t) - hap(t)q(t) q(t + h) = q(t) + hbr(t) - hap(t)q(t) r(t + h) = r(t) - 2hbr(t) + 2hap(t)q(t) As h becomes smaller, the numerical solutions converge to the continuous functions, yielding as close an approximation as desired. In fact , they converge to the solution of the following differential equations: dp/dt= br - apq dq/ dt = br - apq dr/ dt =- 2br + 2apq . Let us now declare all variables to avoid confusion: P,Q- number of grams of reactants. R - number of grams of product. A,B-stoichiometriccoefficients for P and Q, respectively in theequation AP +BQ \\rightleftarrows R . H - reciprocal of the desired time interval, (in sec-1.) .) T - total time of simulated reaction (in sec.) C - control number.This variable allows the user to change desiredparts of the data. D - rate of change in 1/H seconds. The program looks as follows: 0PRINT \"INPUT THE DESIRED CONTROL NUMBER\" 11PRINT \"0: STOP\" 12PRINT \"1: INITIAL GRAMS\", \"2: NEW COEFFICIENTS' 13PRINT \"3: NEW TIME STEPS\", \"4: SIMULATE\" 20INPUT C 30IF C = 0 THEN 280 40IF C = 1 THEN 120 50IF C = 2 THEN 140 60IF C = 3 THEN 160 70IF C = 4 THEN 180 110GO TO 10 120PRINT \"INPUT INITIAL AMOUNTS OF P,Q, AND R\" 125INPUT P,Q,R 130GO TO 10 140PRINT \"INPUT MOLAR COEFFICIENTS FOR P AND Q\" 145INPUT A,B 150GO TO 10 160PRINT \"INPUT DESIRED AND TOTAL TIME INTERVALS\" 165INPUT H,T 170GO TO 10 180PRINT \"TIME\", \"P\", \"Q\", \"R\" 190REM SIMULATION OF REVERSIBLE REACTION 200FOR I = 1 TO T 210FOR J = 1 TO H 220LET D = (B\\textasteriskcenteredR - A\\textasteriskcenteredP\\textasteriskcenteredQ) / H 230LET P = P + D 240LET Q = Q + D 250LET R = R - (2.0\\textasteriskcenteredD) 260NEXT J 270PRINT I,P,Q,R 275NEXT I 280END", "ref_id": 4688, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "A chemist has two reactants, P and Q, dissolved in one liter ofwater. The amounts of P and Q present are p grams and qgrams, respectively, and they are combining to form 2 apq gramsof the product R each second. It is also known that thereaction is reversible: in each second, 2br grams of R arebreaking up into br grams of each P and Q. In summary, thechange in one second is: - -amountof P increases by br - apq -amountof Q increases by br - apq -amountof R increases by 2apq - 2br . Design a program to simulate this reaction.", "options": ["dp/dt= br + apq, dq/ dt = br + apq, dr/ dt = 2br + 2apq", "dp/dt= br - apq, dq/ dt = br - apq, dr/ dt = - 2br + 2apq", "dp/dt= br - apq, dq/ dt = br + apq, dr/ dt = - 2br - 2apq", "dp/dt= br - apq, dq/ dt = br - apq, dr/ dt = - 2br - 2apq"], "answer": "B", "solution": "This reaction is actually continuous. One second divisions are used forconvenience. In general, at any time interval h, the amounts of P,Q, andR are as follows: p(t + h) = p(t) + hbr(t) - hap(t)q(t) q(t + h) = q(t) + hbr(t) - hap(t)q(t) r(t + h) = r(t) - 2hbr(t) + 2hap(t)q(t) As h becomes smaller, the numerical solutions converge to the continuous functions, yielding as close an approximation as desired. In fact , they converge to the solution of the following differential equations: dp/dt= br - apq dq/ dt = br - apq dr/ dt =- 2br + 2apq . Let us now declare all variables to avoid confusion: P,Q- number of grams of reactants. R - number of grams of product. A,B-stoichiometriccoefficients for P and Q, respectively in theequation AP +BQ \\rightleftarrows R . H - reciprocal of the desired time interval, (in sec-1.) .) T - total time of simulated reaction (in sec.) C - control number.This variable allows the user to change desiredparts of the data. D - rate of change in 1/H seconds. The program looks as follows: 0PRINT \"INPUT THE DESIRED CONTROL NUMBER\" 11PRINT \"0: STOP\" 12PRINT \"1: INITIAL GRAMS\", \"2: NEW COEFFICIENTS' 13PRINT \"3: NEW TIME STEPS\", \"4: SIMULATE\" 20INPUT C 30IF C = 0 THEN 280 40IF C = 1 THEN 120 50IF C = 2 THEN 140 60IF C = 3 THEN 160 70IF C = 4 THEN 180 110GO TO 10 120PRINT \"INPUT INITIAL AMOUNTS OF P,Q, AND R\" 125INPUT P,Q,R 130GO TO 10 140PRINT \"INPUT MOLAR COEFFICIENTS FOR P AND Q\" 145INPUT A,B 150GO TO 10 160PRINT \"INPUT DESIRED AND TOTAL TIME INTERVALS\" 165INPUT H,T 170GO TO 10 180PRINT \"TIME\", \"P\", \"Q\", \"R\" 190REM SIMULATION OF REVERSIBLE REACTION 200FOR I = 1 TO T 210FOR J = 1 TO H 220LET D = (B\\textasteriskcenteredR - A\\textasteriskcenteredP\\textasteriskcenteredQ) / H 230LET P = P + D 240LET Q = Q + D 250LET R = R - (2.0\\textasteriskcenteredD) 260NEXT J 270PRINT I,P,Q,R 275NEXT I 280END"}, "question": "task_1"}}, {"data": {"text": "Question:\nHow are the concepts of local and global variables useful in debugging an APL program?\n\nOptions:\nA. Understand local and global variables can help in quick debugging\nB. Global variables are retained in the workspace before, during and after the execution of a program\nC.             Local variables save space in the program\nD. Local variables are only active during function execution\n\nAnswer: A\n\nReference Solution:\nSince APL is an interactive system, the negative feedback on an incorrect program is immediate. An under-standing of local and global variables can help in the quick debugging of APL programs. Variables that retain their values only during function execution are classified as local. By contrast, global var-iables are retained in the workspace before, during and af-ter the execution of a program. To clarify the distinction, consider the following two programs: R \\leftarrow 5 \\nablaCIRCLE [1]D \\leftarrow 2 \u00d7 R [2]C \\leftarrow 3.14159 \u00d7 D [3]A \\leftarrow 3.14159 \u00d7 R \u00d7 R [4]R,D,C,A [5]\\nabla Here R is a global variable because it is active before the execution of a function. That is, R has already been store before \\nablaCIRCLE \\nablaCIRCLE 1 R [1]D \\leftarrow 2 \u00d7 R [2]C \\leftarrow 3.14159 \u00d7 D [3]A \\leftarrow 3.14159 \u00d7 R \u00d7 R [4]R,D,C,A [5]\\nabla Now, R, the radius, is a local variable. Suppose R = 5. Then CIRCLE 1 5 cause the values 5, 10, 31.42, 78.54 to be printed. Keying in an R, after execution is completed produces an error message: R VALUE ERROR R \\wedge \\wedge Once the function has been executed, R is lost. D,C, and A, however, are global variables because they were not defined in the header. Since local variables save space, it is often desirable to use them in a program. Additional local variables can be defined by adding them to the header, with a semicolon be-tween each pair of variables. For example, \\nablaCIRCLE R; D; C; A will make all variables local.", "ref_id": 4689, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "How are the concepts of local and global variables useful in debugging an APL program?", "options": ["Understand local and global variables can help in quick debugging", "Global variables are retained in the workspace before, during and after the execution of a program", "Local variables save space in the program", "Local variables are only active during function execution"], "answer": "A", "solution": "Since APL is an interactive system, the negative feedback on an incorrect program is immediate. An under-standing of local and global variables can help in the quick debugging of APL programs. Variables that retain their values only during function execution are classified as local. By contrast, global var-iables are retained in the workspace before, during and af-ter the execution of a program. To clarify the distinction, consider the following two programs: R \\leftarrow 5 \\nablaCIRCLE [1]D \\leftarrow 2 \u00d7 R [2]C \\leftarrow 3.14159 \u00d7 D [3]A \\leftarrow 3.14159 \u00d7 R \u00d7 R [4]R,D,C,A [5]\\nabla Here R is a global variable because it is active before the execution of a function. That is, R has already been store before \\nablaCIRCLE \\nablaCIRCLE 1 R [1]D \\leftarrow 2 \u00d7 R [2]C \\leftarrow 3.14159 \u00d7 D [3]A \\leftarrow 3.14159 \u00d7 R \u00d7 R [4]R,D,C,A [5]\\nabla Now, R, the radius, is a local variable. Suppose R = 5. Then CIRCLE 1 5 cause the values 5, 10, 31.42, 78.54 to be printed. Keying in an R, after execution is completed produces an error message: R VALUE ERROR R \\wedge \\wedge Once the function has been executed, R is lost. D,C, and A, however, are global variables because they were not defined in the header. Since local variables save space, it is often desirable to use them in a program. Additional local variables can be defined by adding them to the header, with a semicolon be-tween each pair of variables. For example, \\nablaCIRCLE R; D; C; A will make all variables local."}, "question": "task_1"}}, {"data": {"text": "Question:\nFind the transpose of \\mid12\\mid M =\\mid35\\mid \\mid711\\mid Then find M^TM and MM^T using the APL inner product.\n\nOptions:\nA. M^TM and MM^T are both non-conformable for multiplication\nB. M^TM is 51329 133476 2976170 and MM^T is 5994 94150\nC.             M^TM is 94150 5994 and MM^T is 2976170 133476 51329\nD. M^TM is 5994 94150 and MM^T is 51329 133476 2976170\n\nAnswer: D\n\nReference Solution:\nMatrix transposition is accomplished in APL by means of the monadic operator \\textphi. If M is a matrix, \\textphi M is its transpose. Assuming that the values of M have already been entered, its transpose is found by: N \\leftarrow\\textphiM N \\mid137\\mid \\mid2511\\mid When a matrix is transposed, the order of its rows and col-umns is reversed. To check this, apply the shape operator (\\rho) to M and N: \\rhoM 32 \\rhoN 23 The inner product function is used in APL to find the pro-duct of two matrices. Its general form is A+. \u00d7 B. A and B are matrices and + and \u00d7 are primitive arithmetic func-tions, while is the period character. Two matrices A,B are conformable for multiplication if and only if the number of columns of A equals the number of rows of B. In the given problem, \\rhoM= 3 \u00d7 2 and\\rhoM^T= 2 \u00d7 3. Now MM^T means multiplying a (3 \u00d7 2) matrix by a (2 \u00d7 3) matrix. Since the inner numbers are equal, MM^T is conformable for multiplication. Similarly, M^TM gives (2 \u00d7 3) (3 \u00d7 2) and is also conformable for multipli-cation. The command N+. \u00d7 m gives M^TM as 5994 94150 The command M+. \u00d7 n gives MM^T 51329 133476 2976170.", "ref_id": 4690, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Find the transpose of \\mid12\\mid M =\\mid35\\mid \\mid711\\mid Then find M^TM and MM^T using the APL inner product.", "options": ["M^TM and MM^T are both non-conformable for multiplication", "M^TM is 51329 133476 2976170 and MM^T is 5994 94150", "M^TM is 94150 5994 and MM^T is 2976170 133476 51329", "M^TM is 5994 94150 and MM^T is 51329 133476 2976170"], "answer": "D", "solution": "Matrix transposition is accomplished in APL by means of the monadic operator \\textphi. If M is a matrix, \\textphi M is its transpose. Assuming that the values of M have already been entered, its transpose is found by: N \\leftarrow\\textphiM N \\mid137\\mid \\mid2511\\mid When a matrix is transposed, the order of its rows and col-umns is reversed. To check this, apply the shape operator (\\rho) to M and N: \\rhoM 32 \\rhoN 23 The inner product function is used in APL to find the pro-duct of two matrices. Its general form is A+. \u00d7 B. A and B are matrices and + and \u00d7 are primitive arithmetic func-tions, while is the period character. Two matrices A,B are conformable for multiplication if and only if the number of columns of A equals the number of rows of B. In the given problem, \\rhoM= 3 \u00d7 2 and\\rhoM^T= 2 \u00d7 3. Now MM^T means multiplying a (3 \u00d7 2) matrix by a (2 \u00d7 3) matrix. Since the inner numbers are equal, MM^T is conformable for multiplication. Similarly, M^TM gives (2 \u00d7 3) (3 \u00d7 2) and is also conformable for multipli-cation. The command N+. \u00d7 m gives M^TM as 5994 94150 The command M+. \u00d7 n gives MM^T 51329 133476 2976170."}, "question": "task_1"}}, {"data": {"text": "Question:\nObtain the 9's and 10's complements of the following decimalnumbers: (a) 13579(b) 90090(c) 09900(d) 10000(e) 0000\n\nOptions:\nA. The nine's and ten's complements of 13579 are 86421 and 86422, of 90090 are 09910 and 09911, of 09900 are 90100 and 90101, of 10000 are 90000 and 90001, of 0000 are 10000 and 10001 respectively.\nB. The nine's and ten's complements of 13579 are 86420 and 86421, of 90090 are 09909 and 09910, of 09900 are 90099 and 90100, of 10000 are 90000 and 89999, of 0000 are 9999 and 10000 respectively.\nC.             The nine's and ten's complements of 13579 are 86419 and 86420, of 90090 are 09908 and 09909, of 09900 are 90098 and 90099, of 10000 are 89998 and 89999, of 0000 are 9998 and 9999 respectively.\nD. The nine's and ten's complements of 13579 are 99999 and 100000, of 90090 are 09900 and 09901, of 09900 are 90090 and 90091, of 10000 are 99999 and 100000, of 0000 are 9999 and 10000 respectively.\n\nAnswer: B\n\nReference Solution:\nThe nine's and ten's complements of a given decimal number X are foundby subtracting it from a sequence of nine's and from the power of tengreater than X respectively. (a) The nine's complement of 13579 is: 99999 - 13579 86420 The ten's complement is: 100000 - 13579 86421 (b) The nine's complement of 90090 is: 99999 - 90090 09909 Ten's complement is: 100000 - 90090 09910 From (a) and (b) note that Ten's complement (X) = Nine's complement (X) + 1 (c) The nine's complement of 09900 is: 99999 - 09900 90099 The ten's complement is 90099 + 1 =90100 . (d) When numbers are represented in decimal form, the number ten is calledthe base or radix of the decimal system. Then, forming the radix complementof a decimal number means finding its ten's complement representationand the radix minus one complement is equal to the nine's complement. The radix complement of 10000 is: 100000 - 10000 90000 The radix minus one complement is 89999. (e) The radix minus one complement of 0000 is: 9999 - 0000 9999 Hence, the radix complement is 10000. Radix complement representationsof numbers are useful for subtracting two numbers. For example, sup-pose (c) is to be subtracted from (b). 90090 - 09900 80190 In performing this subtraction, we had to borrow twice from the next column. To eliminate the need for borrowing, the subtraction may be performedas follows: i) Form the nines complement of (c) (09900): 90099 ii) Add 1 to obtain the ten's complement: 90099 + 1 = 90100 iii) Add (b) (90090) to the result: 90100 + 90090 = 180190 iv) Subtract100000 from iii) to obtain the final answer 180190 - 100000 = 80190.", "ref_id": 4691, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Obtain the 9's and 10's complements of the following decimalnumbers: (a) 13579(b) 90090(c) 09900(d) 10000(e) 0000", "options": ["The nine's and ten's complements of 13579 are 86421 and 86422, of 90090 are 09910 and 09911, of 09900 are 90100 and 90101, of 10000 are 90000 and 90001, of 0000 are 10000 and 10001 respectively.", "The nine's and ten's complements of 13579 are 86420 and 86421, of 90090 are 09909 and 09910, of 09900 are 90099 and 90100, of 10000 are 90000 and 89999, of 0000 are 9999 and 10000 respectively.", "The nine's and ten's complements of 13579 are 86419 and 86420, of 90090 are 09908 and 09909, of 09900 are 90098 and 90099, of 10000 are 89998 and 89999, of 0000 are 9998 and 9999 respectively.", "The nine's and ten's complements of 13579 are 99999 and 100000, of 90090 are 09900 and 09901, of 09900 are 90090 and 90091, of 10000 are 99999 and 100000, of 0000 are 9999 and 10000 respectively."], "answer": "B", "solution": "The nine's and ten's complements of a given decimal number X are foundby subtracting it from a sequence of nine's and from the power of tengreater than X respectively. (a) The nine's complement of 13579 is: 99999 - 13579 86420 The ten's complement is: 100000 - 13579 86421 (b) The nine's complement of 90090 is: 99999 - 90090 09909 Ten's complement is: 100000 - 90090 09910 From (a) and (b) note that Ten's complement (X) = Nine's complement (X) + 1 (c) The nine's complement of 09900 is: 99999 - 09900 90099 The ten's complement is 90099 + 1 =90100 . (d) When numbers are represented in decimal form, the number ten is calledthe base or radix of the decimal system. Then, forming the radix complementof a decimal number means finding its ten's complement representationand the radix minus one complement is equal to the nine's complement. The radix complement of 10000 is: 100000 - 10000 90000 The radix minus one complement is 89999. (e) The radix minus one complement of 0000 is: 9999 - 0000 9999 Hence, the radix complement is 10000. Radix complement representationsof numbers are useful for subtracting two numbers. For example, sup-pose (c) is to be subtracted from (b). 90090 - 09900 80190 In performing this subtraction, we had to borrow twice from the next column. To eliminate the need for borrowing, the subtraction may be performedas follows: i) Form the nines complement of (c) (09900): 90099 ii) Add 1 to obtain the ten's complement: 90099 + 1 = 90100 iii) Add (b) (90090) to the result: 90100 + 90090 = 180190 iv) Subtract100000 from iii) to obtain the final answer 180190 - 100000 = 80190."}, "question": "task_1"}}, {"data": {"text": "Question:\nExplain what the computer takes as the attributes of the fol-lowingvariables by Default Rules of PL/I, if full explicit declarationsare not provided by the programmer. a) A variable named:PERCENT (1:8), b) A variable named:AMOUNT FIXED, c) A variable named:NUMBER COMPLEX, d) A variable named:TOTAL BINARY, e) A variable named:INCANT\n\nOptions:\nA. a) PERCENT(1:8)DEC, REAL, FLOAT(6); b) AMOUNT FIXED (5) DEC, REAL; c) NUMBERFIXED(5) DEC COMPLEX; d) TOTAL FLOAT (21) BINARY REAL; e) INCANTFIXED(15) BIN, REAL;\nB. a) PERCENT(1:5)DEC, REAL, FLOAT(6); b) AMOUNT FIXED (7) DEC, REAL; c) NUMBERFIXED(3) DEC COMPLEX; d) TOTAL FLOAT (18) BINARY REAL; e) INCANTFIXED(10) BIN, REAL;\nC.             a) PERCENT(1:9)DEC, REAL, FLOAT(5); b) AMOUNT FIXED (4) DEC, REAL; c) NUMBERFIXED(6) DEC COMPLEX; d) TOTAL FLOAT (20) BINARY REAL; e) INCANTFIXED(14) BIN, REAL;\nD. a) PERCENT(1:10)DEC, REAL, FLOAT(8); b) AMOUNT FIXED (6) DEC, REAL; c) NUMBERFIXED(4) DEC COMPLEX; d) TOTAL FLOAT (22) BINARY REAL; e) INCANTFIXED(16) BIN, REAL;\n\nAnswer: A\n\nReference Solution:\na) First of all note that the name of the vari-able; PERCENT starts witha P. The letter P does notliebe-tween the letters I and N (inclusive). Hence, PERCENT is as-signed the following: PERCENT(1:8)DEC, REAL, FLOAT(6); b) The variable AMOUNT has the scale declared as FIXED. Hence, thecomputer completes the attributes as follows: AMOUNT FIXED (5) DEC, REAL. In the above, the precision is made equal to 5, i.e., (5,0). The Base and Mode are supplied as DEC and REAL. c) The variable NUMBER has the mode specified as COMPLEX. Hence, the following remaining attributes are supplied by the computer: Scale :FIXED Base :DEC Precision: (5), i.e., (5,0) Hence, the variable looks like that given below. NUMBERFIXED(5) DEC COMPLEX. d) The missing attributes are supplied for TOTAL BINARY as follows, according to the Default rules: TOTAL FLOAT (21) BINARY REAL; e) The missing attributes are supplied for INCANT as follows: INCANTFIXED(15) BIN, REAL; It should be noted in which order the attributes following a variable name aredeclared, especially the Scale and Preci-sion. The Precision attribute shouldalways follow the Scale attribute, and never vice versa.", "ref_id": 4692, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Explain what the computer takes as the attributes of the fol-lowingvariables by Default Rules of PL/I, if full explicit declarationsare not provided by the programmer. a) A variable named:PERCENT (1:8), b) A variable named:AMOUNT FIXED, c) A variable named:NUMBER COMPLEX, d) A variable named:TOTAL BINARY, e) A variable named:INCANT", "options": ["a) PERCENT(1:8)DEC, REAL, FLOAT(6); b) AMOUNT FIXED (5) DEC, REAL; c) NUMBERFIXED(5) DEC COMPLEX; d) TOTAL FLOAT (21) BINARY REAL; e) INCANTFIXED(15) BIN, REAL;", "a) PERCENT(1:5)DEC, REAL, FLOAT(6); b) AMOUNT FIXED (7) DEC, REAL; c) NUMBERFIXED(3) DEC COMPLEX; d) TOTAL FLOAT (18) BINARY REAL; e) INCANTFIXED(10) BIN, REAL;", "a) PERCENT(1:9)DEC, REAL, FLOAT(5); b) AMOUNT FIXED (4) DEC, REAL; c) NUMBERFIXED(6) DEC COMPLEX; d) TOTAL FLOAT (20) BINARY REAL; e) INCANTFIXED(14) BIN, REAL;", "a) PERCENT(1:10)DEC, REAL, FLOAT(8); b) AMOUNT FIXED (6) DEC, REAL; c) NUMBERFIXED(4) DEC COMPLEX; d) TOTAL FLOAT (22) BINARY REAL; e) INCANTFIXED(16) BIN, REAL;"], "answer": "A", "solution": "a) First of all note that the name of the vari-able; PERCENT starts witha P. The letter P does notliebe-tween the letters I and N (inclusive). Hence, PERCENT is as-signed the following: PERCENT(1:8)DEC, REAL, FLOAT(6); b) The variable AMOUNT has the scale declared as FIXED. Hence, thecomputer completes the attributes as follows: AMOUNT FIXED (5) DEC, REAL. In the above, the precision is made equal to 5, i.e., (5,0). The Base and Mode are supplied as DEC and REAL. c) The variable NUMBER has the mode specified as COMPLEX. Hence, the following remaining attributes are supplied by the computer: Scale :FIXED Base :DEC Precision: (5), i.e., (5,0) Hence, the variable looks like that given below. NUMBERFIXED(5) DEC COMPLEX. d) The missing attributes are supplied for TOTAL BINARY as follows, according to the Default rules: TOTAL FLOAT (21) BINARY REAL; e) The missing attributes are supplied for INCANT as follows: INCANTFIXED(15) BIN, REAL; It should be noted in which order the attributes following a variable name aredeclared, especially the Scale and Preci-sion. The Precision attribute shouldalways follow the Scale attribute, and never vice versa."}, "question": "task_1"}}, {"data": {"text": "Question:\nExplain the need for STOP JOB CARDS, and list the differentmethods used in computers to bring about a proper endof the program.\n\nOptions:\nA. 1) Header Card method, 2) End-File condition method, 3) Trailer Card method, 4) Compare and count method\nB. 1) Count and compare method, 2) Trailer Card method, 3) Header Card method, 4) End-File condition method\nC.             1) End-File condition method, 2) Count and compare method, 3) Trailer Card method, 4) Header Card method\nD. 1) Header Card method, 2) Trailer Card method, 3) End-File condition method, 4) Count and compare method\n\nAnswer: D\n\nReference Solution:\nThe computer is just a machine without any intel-ligence of its own. It only does exactly what is has been programmed to do, i.e., told, to do. When an instruction is given to the computer to get some kind of data, say, from a punched card, the computer keeps on getting the data till itis explicitly told again to stop getting any more data. When a computer is taking in data as part of a program, there must besome means of telling the computer how many data items to expect, especiallywhen the appropriation of data is part of an iterative loop. If the computertries tocontinouslyread in data it will eventually not find any moredata. The computer now assumes there is an error, and either terminatesthe program, or gives out an error message. To eliminate this problemwe must have some ways of telling the computer just how much datato expect or what to do (other than bombing the program!) when the dataruns out. There are normally four ways to do this: 1) Header Card method,2) Trailer Card method, 3) End-File condition method,4) Count and compare method", "ref_id": 4693, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Explain the need for STOP JOB CARDS, and list the differentmethods used in computers to bring about a proper endof the program.", "options": ["1) Header Card method, 2) End-File condition method, 3) Trailer Card method, 4) Compare and count method", "1) Count and compare method, 2) Trailer Card method, 3) Header Card method, 4) End-File condition method", "1) End-File condition method, 2) Count and compare method, 3) Trailer Card method, 4) Header Card method", "1) Header Card method, 2) Trailer Card method, 3) End-File condition method, 4) Count and compare method"], "answer": "D", "solution": "The computer is just a machine without any intel-ligence of its own. It only does exactly what is has been programmed to do, i.e., told, to do. When an instruction is given to the computer to get some kind of data, say, from a punched card, the computer keeps on getting the data till itis explicitly told again to stop getting any more data. When a computer is taking in data as part of a program, there must besome means of telling the computer how many data items to expect, especiallywhen the appropriation of data is part of an iterative loop. If the computertries tocontinouslyread in data it will eventually not find any moredata. The computer now assumes there is an error, and either terminatesthe program, or gives out an error message. To eliminate this problemwe must have some ways of telling the computer just how much datato expect or what to do (other than bombing the program!) when the dataruns out. There are normally four ways to do this: 1) Header Card method,2) Trailer Card method, 3) End-File condition method,4) Count and compare method"}, "question": "task_1"}}, {"data": {"text": "Question:\nExplain the TRAILER CARD method of stopping a computer job, i.e., a program.\n\nOptions:\nA. The Trailer Card method uses a unique number on the last card in the data section of a program card deck to signal the end of a job.\nB. The Trailer Card method uses a serial number on the first card to stop a program.\nC.             The Trailer Card method uses a special code to pause a program.\nD. The Trailer Card method requires a specific card to be inserted physically into the computer.\n\nAnswer: A\n\nReference Solution:\nIn this method, we use a certain unique number on the last card in thedata section of a program card deck. This last card is called the Trailer Card. The unique number selected is such that it is different in value, or numberof digits, etc., from all the other authen-tic data on the other precedingdata cards of the program deck. For example, if we know that allour data consists of positive numbers, we could use a negative number onthe Trail-er Card. Or, if we know that all the data is non-zero, we could usea value of zero on the Trailer Card. Then, in the body of the program weinsert a statement which tells the computer to end the job when the valuewhich we have put on the Trailer Card is encountered. The Trailer Card method is most useful in cases where different re- runsof a given program will have different amounts of data, which cannot beknown in advance. Hence, instead of modifying the program each time thedata changes, we use the same program, but take advantage of the Trailer Card to tell the computer when to end the program. We give below a program to illustrate the use of the Trailer Card method. SUM: PROCOPTIONS(MAIN); DCL(X,SUM)FIXED(4)INIT(0); LOOP:GET LIST (X) ;/\\textasteriskcentered WE READ ONE DATA VALUE \\textasteriskcentered/ SUM = SUM + X; IF X = 0000 THEN GO TO FINISH; /\\textasteriskcentered WE READ A VALUE OF 0000 FOR X, WHICH IS ON THE TRAILER CARD, AND, AS THE TRAILER CARD IS THE LAST DATA CARD, WE GO OUT OF THE LOOP TO LABEL FINISH. HERE WE ASSUME NONE OF THE DATA NORMALLY HAS A VALUE '0000' \\textasteriskcentered/ GOTO LOOP; /\\textasteriskcentered IF THE TRAILER CARD IS NOT REACHED, WE REPEAT THE LOOP \\textasteriskcentered/ FINISH: PUTLIST(SUM); END SUM;", "ref_id": 4694, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Explain the TRAILER CARD method of stopping a computer job, i.e., a program.", "options": ["The Trailer Card method uses a unique number on the last card in the data section of a program card deck to signal the end of a job.", "The Trailer Card method uses a serial number on the first card to stop a program.", "The Trailer Card method uses a special code to pause a program.", "The Trailer Card method requires a specific card to be inserted physically into the computer."], "answer": "A", "solution": "In this method, we use a certain unique number on the last card in thedata section of a program card deck. This last card is called the Trailer Card. The unique number selected is such that it is different in value, or numberof digits, etc., from all the other authen-tic data on the other precedingdata cards of the program deck. For example, if we know that allour data consists of positive numbers, we could use a negative number onthe Trail-er Card. Or, if we know that all the data is non-zero, we could usea value of zero on the Trailer Card. Then, in the body of the program weinsert a statement which tells the computer to end the job when the valuewhich we have put on the Trailer Card is encountered. The Trailer Card method is most useful in cases where different re- runsof a given program will have different amounts of data, which cannot beknown in advance. Hence, instead of modifying the program each time thedata changes, we use the same program, but take advantage of the Trailer Card to tell the computer when to end the program. We give below a program to illustrate the use of the Trailer Card method. SUM: PROCOPTIONS(MAIN); DCL(X,SUM)FIXED(4)INIT(0); LOOP:GET LIST (X) ;/\\textasteriskcentered WE READ ONE DATA VALUE \\textasteriskcentered/ SUM = SUM + X; IF X = 0000 THEN GO TO FINISH; /\\textasteriskcentered WE READ A VALUE OF 0000 FOR X, WHICH IS ON THE TRAILER CARD, AND, AS THE TRAILER CARD IS THE LAST DATA CARD, WE GO OUT OF THE LOOP TO LABEL FINISH. HERE WE ASSUME NONE OF THE DATA NORMALLY HAS A VALUE '0000' \\textasteriskcentered/ GOTO LOOP; /\\textasteriskcentered IF THE TRAILER CARD IS NOT REACHED, WE REPEAT THE LOOP \\textasteriskcentered/ FINISH: PUTLIST(SUM); END SUM;"}, "question": "task_1"}}, {"data": {"text": "Question:\nObtain the 15's and 16's complement of the following hexadecimalnumbers: a) FFOb) 1234c) ABCDd) 0000\n\nOptions:\nA. a) FFO, b) 1234, c) ABCD, d) 0000\nB. a) 010, b) EDCC, c) 5433, d) 10000\nC.             a) FFF, b) 1234, c) ABCD, d) 0000\nD. a) 00F, b) EDCB, c) 5432, d) FFFF\n\nAnswer: B\n\nReference Solution:\nHexadecimal numbers arise frequently in computer applications because16 is the fourth power of 2. This means that each hexadecimal digitcan be represented uniquely by four bits. a) The 15's complement of FFO is found by subtracting it from FFF. FFF - FFO 00F Since radix complement = radix complement minus one + 1, the 16's complementhere is: 00F + 1 =010 . b) The 15's complement of 1234 is: FFFF - 1234 EDCB The16 'scomplement is then EDCB + 1, or EDCC. To make this more comprehensible, convert into the decimal system: 10000_16, = 16^4 + 0 \u00d7 16^3 + 0 \u00d7 16^2 + 0 \u00d7 16^1 + 0 \u00d7 16^0 = 65,536_10 1234_16 = 1 \u00d7 16^3 + 2 \u00d7 16^2 + 3 \u00d7 16^1 + 4 \u00d7 16^0 = 4660_10 Then the 16's complement (decimal equivalent) is: 65,536 - 4,660 60,876 Now, EDCC_16 = 14 \u00d7 16^3 + 13 \u00d7 16^2 + 12 \u00d7 16^1 + 12 \u00d7 16^0 = 60,876_10as above. Thus EDCC_16 is the 16's complement of 1234_16. c) The radix minus one complement of ABCD is: FFFF - ABCD 5432 The radix complement of ABCD is 5433, d) The radix complement of 0000 is 10000 while the radix complement minus one is FFFF.", "ref_id": 4695, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Obtain the 15's and 16's complement of the following hexadecimalnumbers: a) FFOb) 1234c) ABCDd) 0000", "options": ["a) FFO, b) 1234, c) ABCD, d) 0000", "a) 010, b) EDCC, c) 5433, d) 10000", "a) FFF, b) 1234, c) ABCD, d) 0000", "a) 00F, b) EDCB, c) 5432, d) FFFF"], "answer": "B", "solution": "Hexadecimal numbers arise frequently in computer applications because16 is the fourth power of 2. This means that each hexadecimal digitcan be represented uniquely by four bits. a) The 15's complement of FFO is found by subtracting it from FFF. FFF - FFO 00F Since radix complement = radix complement minus one + 1, the 16's complementhere is: 00F + 1 =010 . b) The 15's complement of 1234 is: FFFF - 1234 EDCB The16 'scomplement is then EDCB + 1, or EDCC. To make this more comprehensible, convert into the decimal system: 10000_16, = 16^4 + 0 \u00d7 16^3 + 0 \u00d7 16^2 + 0 \u00d7 16^1 + 0 \u00d7 16^0 = 65,536_10 1234_16 = 1 \u00d7 16^3 + 2 \u00d7 16^2 + 3 \u00d7 16^1 + 4 \u00d7 16^0 = 4660_10 Then the 16's complement (decimal equivalent) is: 65,536 - 4,660 60,876 Now, EDCC_16 = 14 \u00d7 16^3 + 13 \u00d7 16^2 + 12 \u00d7 16^1 + 12 \u00d7 16^0 = 60,876_10as above. Thus EDCC_16 is the 16's complement of 1234_16. c) The radix minus one complement of ABCD is: FFFF - ABCD 5432 The radix complement of ABCD is 5433, d) The radix complement of 0000 is 10000 while the radix complement minus one is FFFF."}, "question": "task_1"}}, {"data": {"text": "Question:\nDevelop a sorting subroutine that compares elements that are separated by a distance K. In your algorithm, try to make exchanges between elements such that each exchange moves an element close to its final position.\n\nOptions:\nA. Shell sort\nB. Bubble sort\nC.             Quick sort\nD. Insertion sort\n\nAnswer: A\n\nReference Solution:\nThis method is known as a Shell sort. Compari-sons are made between an element X_i. and element xi + k. For the bubble and insertion sorts, K is always 1. With the shell sort, you set K at the largest power of two that is less than N, N being the total number of elements. There-fore 2^k < N \\leq 2k+1 Once K is chosen, a pass is made through the array. Each successive pass results in the division of K by 2. Finally, for the last pass, K = 1 and the procedure becomes an ordinary bubble sort. This variety of exchange sort functions best when the size of the array is relatively small, viz., less than 25 elements. However, if you are nottoconcerned about speed and efficiency, this sort is conceptually simple and short. SUBROUTINE SHELL (X, N) DIMENSION X (N) MIDPT = N 1\\OMIDPT = MDPT / 2 IF (MIDPT.LE.O) RETURN LIMIT = N - MIDPT DO 20 J = l, LIMIT IJ = J 3\\OIM = IJ+MIDPT IF (X (IM).GE.X (IJ)) GO TO 20 TEMP = X (IJ) X (IJ) = X (IM) X (IM) = TEMP IJ = IJ - MIDPT IF (IJ.GE.1) GO TO 30 20CONTINUE GO TO 1\\O END", "ref_id": 4696, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Develop a sorting subroutine that compares elements that are separated by a distance K. In your algorithm, try to make exchanges between elements such that each exchange moves an element close to its final position.", "options": ["Shell sort", "Bubble sort", "Quick sort", "Insertion sort"], "answer": "A", "solution": "This method is known as a Shell sort. Compari-sons are made between an element X_i. and element xi + k. For the bubble and insertion sorts, K is always 1. With the shell sort, you set K at the largest power of two that is less than N, N being the total number of elements. There-fore 2^k < N \\leq 2k+1 Once K is chosen, a pass is made through the array. Each successive pass results in the division of K by 2. Finally, for the last pass, K = 1 and the procedure becomes an ordinary bubble sort. This variety of exchange sort functions best when the size of the array is relatively small, viz., less than 25 elements. However, if you are nottoconcerned about speed and efficiency, this sort is conceptually simple and short. SUBROUTINE SHELL (X, N) DIMENSION X (N) MIDPT = N 1\\OMIDPT = MDPT / 2 IF (MIDPT.LE.O) RETURN LIMIT = N - MIDPT DO 20 J = l, LIMIT IJ = J 3\\OIM = IJ+MIDPT IF (X (IM).GE.X (IJ)) GO TO 20 TEMP = X (IJ) X (IJ) = X (IM) X (IM) = TEMP IJ = IJ - MIDPT IF (IJ.GE.1) GO TO 30 20CONTINUE GO TO 1\\O END"}, "question": "task_1"}}, {"data": {"text": "Question:\nWrite a FORTRAN program to compute the standard deviation of N real numbers. Again, you may assume that these numbers have already been read into an array X having members X(1), X(2),...,X(N).\n\nOptions:\nA. DIMENSION X(N), Y(N) READ, N SUMSQ = 0.0 DO 5 I = 1,N Y(I) = X(I) + AVG SUMSQ = SUMSQ + Y(I) ** 2 5 CONTINUE A = FLOAT (N) SIGMA = SQRT (SUMSQ / (A-1.0)) STOP END\nB. DIMENSION X(N), Y(N) READ, N SUMSQ = 0.0 DO 5 I = 1,N Y(I) = X(I) - AVG SUMSQ = SUMSQ + Y(I) ** 3 5 CONTINUE A = FLOAT (N) SIGMA = SQRT (SUMSQ / (A-1.0)) STOP END\nC.             DIMENSION X(N), Y(N) READ, N SUMSQ = 0.0 DO 5 I = 1,N Y(I) = X(I) - AVG SUMSQ = SUMSQ + Y(I) ** 2 5 CONTINUE A = FLOAT (N) SIGMA = SQRT (SUMSQ / (A-1.0)) STOP END\nD. DIMENSION X(N), Y(N) READ, N SUMSQ = 0.0 DO 5 I = 1,N Y(I) = X(I) - AVG SUMSQ = SUMSQ + Y(I) 5 CONTINUE A = FLOAT (N) SIGMA = SQRT (SUMSQ / (A-1.0)) STOP END\n\nAnswer: C\n\nReference Solution:\nWe apply the formula \\varphi= \\surd[^N\\sum_N=1 (X_i -X)^2 / (N - 1)] \\varphi \\varphi = \\surd[{(X_1 -X)^2 + (X_2 -X)^2 +...+ (X_N -X)^2} / (N - 1)]. To further simplify the calculation we will assume thatX, the mean, has already been calculated as the variable AVG from the preceding problem (#12). Let SIGMA, stand for\\varphi. The program would then be: \\varphi DIMENSION X(N), Y(N) READ, N SUMSQ = \\O.\\O DO 5\\O I = 1,N Y(I) = X(I) - AVG SUMSQ = SUMSQ + Y(I) \\textasteriskcentered\\textasteriskcentered 2 5\\OCONTINUE A = FLOAT (N) SIGMA = SQRT (SUMSQ / (A-1.0)) STOP END", "ref_id": 4697, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Write a FORTRAN program to compute the standard deviation of N real numbers. Again, you may assume that these numbers have already been read into an array X having members X(1), X(2),...,X(N).", "options": ["DIMENSION X(N), Y(N) READ, N SUMSQ = 0.0 DO 5 I = 1,N Y(I) = X(I) + AVG SUMSQ = SUMSQ + Y(I) ** 2 5 CONTINUE A = FLOAT (N) SIGMA = SQRT (SUMSQ / (A-1.0)) STOP END", "DIMENSION X(N), Y(N) READ, N SUMSQ = 0.0 DO 5 I = 1,N Y(I) = X(I) - AVG SUMSQ = SUMSQ + Y(I) ** 3 5 CONTINUE A = FLOAT (N) SIGMA = SQRT (SUMSQ / (A-1.0)) STOP END", "DIMENSION X(N), Y(N) READ, N SUMSQ = 0.0 DO 5 I = 1,N Y(I) = X(I) - AVG SUMSQ = SUMSQ + Y(I) ** 2 5 CONTINUE A = FLOAT (N) SIGMA = SQRT (SUMSQ / (A-1.0)) STOP END", "DIMENSION X(N), Y(N) READ, N SUMSQ = 0.0 DO 5 I = 1,N Y(I) = X(I) - AVG SUMSQ = SUMSQ + Y(I) 5 CONTINUE A = FLOAT (N) SIGMA = SQRT (SUMSQ / (A-1.0)) STOP END"], "answer": "C", "solution": "We apply the formula \\varphi= \\surd[^N\\sum_N=1 (X_i -X)^2 / (N - 1)] \\varphi \\varphi = \\surd[{(X_1 -X)^2 + (X_2 -X)^2 +...+ (X_N -X)^2} / (N - 1)]. To further simplify the calculation we will assume thatX, the mean, has already been calculated as the variable AVG from the preceding problem (#12). Let SIGMA, stand for\\varphi. The program would then be: \\varphi DIMENSION X(N), Y(N) READ, N SUMSQ = \\O.\\O DO 5\\O I = 1,N Y(I) = X(I) - AVG SUMSQ = SUMSQ + Y(I) \\textasteriskcentered\\textasteriskcentered 2 5\\OCONTINUE A = FLOAT (N) SIGMA = SQRT (SUMSQ / (A-1.0)) STOP END"}, "question": "task_1"}}, {"data": {"text": "Question:\nAssume that the Gross National Product (GNP) is now 1 \u00d71012dollars, and is increasing by 4% each year. Also assumethat the gross output of the computing industry (GOC) is now 6 \u00d7 10^9 dollars, and is increas-ing by 17% each year. If these growth rates are continuous, starting from this year, in how many years will GOC exceed GNP?\n\nOptions:\nA. GOC will exceed GNP in 10 years\nB. GOC will exceed GNP in 5 years\nC.             GOC will never exceed GNP\nD. GOC will exceed GNP in 20 years\n\nAnswer: C\n\nReference Solution:\nThe answer to this problem is a fictional one, since GOC will never exceedGNP in reality. Projections such as these are interesting brain-teasers. The logic is straightforward, and the program is presented below : 10 REMGNP VS.GOC 20 READ GNP, GOC 25 YEAR = 0 30 NUP = 0.0 40 NUC = 0.0 50 NUP = GNP\\textasteriskcentered .04 60 GNP = GNP + NUP 70 NUC = GOC\\textasteriskcentered .17 80 GOC = GOC + NUC 90 YEAR = YEAR + 1 100 IF GOC \\leq CNP THEN 5\\varnothing 110 PRINT YEAR 120 DATA 1000, 6 130 END", "ref_id": 4698, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Assume that the Gross National Product (GNP) is now 1 \u00d71012dollars, and is increasing by 4% each year. Also assumethat the gross output of the computing industry (GOC) is now 6 \u00d7 10^9 dollars, and is increas-ing by 17% each year. If these growth rates are continuous, starting from this year, in how many years will GOC exceed GNP?", "options": ["GOC will exceed GNP in 10 years", "GOC will exceed GNP in 5 years", "GOC will never exceed GNP", "GOC will exceed GNP in 20 years"], "answer": "C", "solution": "The answer to this problem is a fictional one, since GOC will never exceedGNP in reality. Projections such as these are interesting brain-teasers. The logic is straightforward, and the program is presented below : 10 REMGNP VS.GOC 20 READ GNP, GOC 25 YEAR = 0 30 NUP = 0.0 40 NUC = 0.0 50 NUP = GNP\\textasteriskcentered .04 60 GNP = GNP + NUP 70 NUC = GOC\\textasteriskcentered .17 80 GOC = GOC + NUC 90 YEAR = YEAR + 1 100 IF GOC \\leq CNP THEN 5\\varnothing 110 PRINT YEAR 120 DATA 1000, 6 130 END"}, "question": "task_1"}}, {"data": {"text": "Question:\nWrite a FORTRAN program to read in an initial cost, salvage value , expected lifetime, number of years to be depreciated, and a code. The code indicates the function to be performed namely 1 -straight-linedepreciation 2 -decliningbalance depreciation 3 - sum-of-the-years-digits depreciation The program will calculate the depreciation in accordance with the code number you choose.\n\nOptions:\nA. FORTRAN program\nB. C++ program\nC.             JavaScript function\nD. Python Script\n\nAnswer: A\n\nReference Solution:\nTo do this problem, we assume the cost is not equal to $999.99. (We use the value of $999.99 to indicate that there are no more DATA cards to be read, and the program should be terminated.) We can set up a DO-WHILE construct here: processing will continue until all the cards are read in. Input values as well as the output, statements have been omitted so that you may come up with your own ideas on that. DIMENSION VALUE (100) 15READ (3,100) COST, SALV, EXLIFE, IYRS, ICODE IF (COST. EQ. 999.99) GO TO 99 IF (ICODE. EQ. 1)GOTO 50 IF (ICODE. EQ. 2)GOTO 70 CBY DEFAULT, THIS SECTION TAKES CARE OF ICODE = 3 DEP = COST - SALV JSUM = 0 KT = EXLIFE 20JSUM = JSUM + KT IF (KT.EQ.0) GO TO 30 KT = KT - 1 GO TO 20 30DO 40 M = 1, IYRS J = IYRS - 1 FRA = J/IYRS VALUE (M) = FRA{_\\ast}DEP 40CONTINUE GO TO 15 CTHIS SECTION TAKES CARE OF ICODE = 1 50ANNDEP = DEP/ELIFE DO 60 K = 1, IYRS COST = COST - ANNDEP 60VALUE(K) = COST GO TO 15 CTHIS SECTION TAKES CARE OF ICODE = 2 DO 80 I = 1, IYRS DEP = VALU\\textasteriskcentered.1667 VALU = VALU - DEP VALUE(I) = VALU 80CONTINUE GO TO 15 99STOP END", "ref_id": 4699, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Write a FORTRAN program to read in an initial cost, salvage value , expected lifetime, number of years to be depreciated, and a code. The code indicates the function to be performed namely 1 -straight-linedepreciation 2 -decliningbalance depreciation 3 - sum-of-the-years-digits depreciation The program will calculate the depreciation in accordance with the code number you choose.", "options": ["FORTRAN program", "C++ program", "JavaScript function", "Python Script"], "answer": "A", "solution": "To do this problem, we assume the cost is not equal to $999.99. (We use the value of $999.99 to indicate that there are no more DATA cards to be read, and the program should be terminated.) We can set up a DO-WHILE construct here: processing will continue until all the cards are read in. Input values as well as the output, statements have been omitted so that you may come up with your own ideas on that. DIMENSION VALUE (100) 15READ (3,100) COST, SALV, EXLIFE, IYRS, ICODE IF (COST. EQ. 999.99) GO TO 99 IF (ICODE. EQ. 1)GOTO 50 IF (ICODE. EQ. 2)GOTO 70 CBY DEFAULT, THIS SECTION TAKES CARE OF ICODE = 3 DEP = COST - SALV JSUM = 0 KT = EXLIFE 20JSUM = JSUM + KT IF (KT.EQ.0) GO TO 30 KT = KT - 1 GO TO 20 30DO 40 M = 1, IYRS J = IYRS - 1 FRA = J/IYRS VALUE (M) = FRA{_\\ast}DEP 40CONTINUE GO TO 15 CTHIS SECTION TAKES CARE OF ICODE = 1 50ANNDEP = DEP/ELIFE DO 60 K = 1, IYRS COST = COST - ANNDEP 60VALUE(K) = COST GO TO 15 CTHIS SECTION TAKES CARE OF ICODE = 2 DO 80 I = 1, IYRS DEP = VALU\\textasteriskcentered.1667 VALU = VALU - DEP VALUE(I) = VALU 80CONTINUE GO TO 15 99STOP END"}, "question": "task_1"}}, {"data": {"text": "Question:\nWrite the necessary statement function(s) to compute the area of a triangle, given 3 sides. Use Hero's formula.\n\nOptions:\nA. S(A,B,C) = 0.5 * (A + B + C), AREA(A,B,C,X) = SQRT(X*(X-A)*(X-B)*(X-C))\nB. S(A,B,C) = (A + B + C) / 2, AREA(A,B,C,X) = X / ((X-A)*(X-B)*(X-C))\nC.             S(A,B,C) = A + B + C, AREA(A,B,C,X) = X*(X-A)*(X-B)*(X-C)\nD. AREA(A,B,C) = A*B*C\n\nAnswer: A\n\nReference Solution:\nThe area of a triangle of sides a, b, and c is given by Area = \\surd[s(s - a)(s - b)(s - c)] where s = 1/2(a + b + c) Hence, using one statement function to define s and a second to define Area, we get: S(A,B,C) = 0.5 {_\\ast} (A + B + C) X = S(A,B,C) AREA(A,B,C,X) = SQRT(X{_\\ast}(X-A){_\\ast}(X-B){_\\ast}(X-C))", "ref_id": 4700, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Write the necessary statement function(s) to compute the area of a triangle, given 3 sides. Use Hero's formula.", "options": ["S(A,B,C) = 0.5 * (A + B + C), AREA(A,B,C,X) = SQRT(X*(X-A)*(X-B)*(X-C))", "S(A,B,C) = (A + B + C) / 2, AREA(A,B,C,X) = X / ((X-A)*(X-B)*(X-C))", "S(A,B,C) = A + B + C, AREA(A,B,C,X) = X*(X-A)*(X-B)*(X-C)", "AREA(A,B,C) = A*B*C"], "answer": "A", "solution": "The area of a triangle of sides a, b, and c is given by Area = \\surd[s(s - a)(s - b)(s - c)] where s = 1/2(a + b + c) Hence, using one statement function to define s and a second to define Area, we get: S(A,B,C) = 0.5 {_\\ast} (A + B + C) X = S(A,B,C) AREA(A,B,C,X) = SQRT(X{_\\ast}(X-A){_\\ast}(X-B){_\\ast}(X-C))"}, "question": "task_1"}}, {"data": {"text": "Question:\nWrite a BASIC program to calculate the hypotenuse of a right triangle. Your program should read in values of the two sides A and B, and calculate the hypotenuse C according to the Pythagorean theorem. Illustrate the results when A = 3, B = 4; A = 6, B = 8; A = B = 1.\n\nOptions:\nA. C = SQR (A _\\uparrow 2 - B _\\uparrow 2)\nB. C = A + B\nC.             C = A * B\nD. C = SQR (A _\\uparrow 2 + B _\\uparrow 2)\n\nAnswer: D\n\nReference Solution:\nThis program illustrates the use of Library Functions in BASIC. It executes function SQR (Square Root) for determining the hypotenuse. The hypotenuse C is calculated from the formula C = \\surd(A^2 + B^2). The program follows: 1\\O REM CALCULATES THE HYPOTENUSE 2\\O REM OF A RIGHT TRIANGLE 3\\O PRINT \"SIDE A\", \"SIDE B\", \"HYPOTENUSE C\" 4\\O READ A, B 5\\O LET C = SQR (A _\\uparrow 2 + B _\\uparrow 2) 6\\O PRINT A,B,C 7\\O GO TO 4\\O 8\\O DATA 3, 4, 6, 8, 1, 1 9\\O END OUTPUT: SIDE A SIDE B HYPOTENUSE C 3 4 5 6 8 1\\O 1 1 1.41...", "ref_id": 4701, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Write a BASIC program to calculate the hypotenuse of a right triangle. Your program should read in values of the two sides A and B, and calculate the hypotenuse C according to the Pythagorean theorem. Illustrate the results when A = 3, B = 4; A = 6, B = 8; A = B = 1.", "options": ["C = SQR (A _\\uparrow 2 - B _\\uparrow 2)", "C = A + B", "C = A * B", "C = SQR (A _\\uparrow 2 + B _\\uparrow 2)"], "answer": "D", "solution": "This program illustrates the use of Library Functions in BASIC. It executes function SQR (Square Root) for determining the hypotenuse. The hypotenuse C is calculated from the formula C = \\surd(A^2 + B^2). The program follows: 1\\O REM CALCULATES THE HYPOTENUSE 2\\O REM OF A RIGHT TRIANGLE 3\\O PRINT \"SIDE A\", \"SIDE B\", \"HYPOTENUSE C\" 4\\O READ A, B 5\\O LET C = SQR (A _\\uparrow 2 + B _\\uparrow 2) 6\\O PRINT A,B,C 7\\O GO TO 4\\O 8\\O DATA 3, 4, 6, 8, 1, 1 9\\O END OUTPUT: SIDE A SIDE B HYPOTENUSE C 3 4 5 6 8 1\\O 1 1 1.41..."}, "question": "task_1"}}, {"data": {"text": "Question:\nWrite a BASIC program to calculate the principal after N years on a balance (original principal) of B at time 0. Assume that interest is compounded yearly at 5% effective yield. Print the results for N = 1, 3, 5.\n\nOptions:\nA. P = P_O - iN\nB. P = P_O (1+i)^N\nC.             P = P_O + iN\nD. P = P_O / (1+i)^N\n\nAnswer: B\n\nReference Solution:\nThe formula we need is P = P_O (Hi)^Nwhere P_O = B,i= 0.05, and N takes on values 1, 3, and 5. This program introduces the STEP option in a FOR-NEXT loop. Data of P_O = B = 200 is used. 1\\OREM CALCULATES PRINCIPAL ON 2\\OREM A BALANCE AT 5% INTEREST 3\\OREM B = ORIGINAL BALANCE, P = PRINCIPAL 4\\OREAD B 5\\OPRINT \"PRINCIPAL\", \"BALANCE\", \"YEARS\" 6\\OFOR N = 1 TO 5 STEP 2 7\\OLET P = B\\textasteriskcentered1.05 \\uparrow N 8\\OPRINT P, B, N 9\\ONEXT N 1\\O\\ODATA 2\\O\\O 11\\OEND", "ref_id": 4702, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Write a BASIC program to calculate the principal after N years on a balance (original principal) of B at time 0. Assume that interest is compounded yearly at 5% effective yield. Print the results for N = 1, 3, 5.", "options": ["P = P_O - iN", "P = P_O (1+i)^N", "P = P_O + iN", "P = P_O / (1+i)^N"], "answer": "B", "solution": "The formula we need is P = P_O (Hi)^Nwhere P_O = B,i= 0.05, and N takes on values 1, 3, and 5. This program introduces the STEP option in a FOR-NEXT loop. Data of P_O = B = 200 is used. 1\\OREM CALCULATES PRINCIPAL ON 2\\OREM A BALANCE AT 5% INTEREST 3\\OREM B = ORIGINAL BALANCE, P = PRINCIPAL 4\\OREAD B 5\\OPRINT \"PRINCIPAL\", \"BALANCE\", \"YEARS\" 6\\OFOR N = 1 TO 5 STEP 2 7\\OLET P = B\\textasteriskcentered1.05 \\uparrow N 8\\OPRINT P, B, N 9\\ONEXT N 1\\O\\ODATA 2\\O\\O 11\\OEND"}, "question": "task_1"}}, {"data": {"text": "Question:\nWrite a BASIC program to round numbers of the form XX.X to the nearest integer. Your program should read in the numbers from a DATA statement and print out the original number and the rounded number.\n\nOptions:\nA. ROUND(X)\nB. FLOOR(X + 0.5)\nC.             INT(X + 0.5)\nD. CEIL(X - 0.5)\n\nAnswer: C\n\nReference Solution:\nThis program introduces the library function INT(X), which returns the integer part of the input number X. We need one elementary result from numerical analysis, namely that the rounded value of X is given by INT(X + 0.5) to the nearest integer. 1\\O REM ROUNDS NUMBERS 2\\O PRINT \"NUMBER\", \"ROUNDED 3\\O FOR A = 1 TO 8 4\\O READ X 5\\O LET Y = INT(X + \\O.5) 6\\O PRINT X,Y 7\\O NEXT A 8\\O DATA 16.6, 14.8, 25.6, 4.8, 87.8, 67.2, 35.1, 93.2 9\\O END It is not needed to add \\O.5 to X (statement 5\\O) for those systems where command INT(X) rounds off, instead of just cutting the fractional part of X.", "ref_id": 4703, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Write a BASIC program to round numbers of the form XX.X to the nearest integer. Your program should read in the numbers from a DATA statement and print out the original number and the rounded number.", "options": ["ROUND(X)", "FLOOR(X + 0.5)", "INT(X + 0.5)", "CEIL(X - 0.5)"], "answer": "C", "solution": "This program introduces the library function INT(X), which returns the integer part of the input number X. We need one elementary result from numerical analysis, namely that the rounded value of X is given by INT(X + 0.5) to the nearest integer. 1\\O REM ROUNDS NUMBERS 2\\O PRINT \"NUMBER\", \"ROUNDED 3\\O FOR A = 1 TO 8 4\\O READ X 5\\O LET Y = INT(X + \\O.5) 6\\O PRINT X,Y 7\\O NEXT A 8\\O DATA 16.6, 14.8, 25.6, 4.8, 87.8, 67.2, 35.1, 93.2 9\\O END It is not needed to add \\O.5 to X (statement 5\\O) for those systems where command INT(X) rounds off, instead of just cutting the fractional part of X."}, "question": "task_1"}}, {"data": {"text": "Question:\nDIMENSION A(10,15,7) Assuming that elements of arrays are stored in lexicographic order of their indices, find the displacement of the location of the element A(5,7,4) relative to the location of A(1,1,1). (b)If A is a three-dimensional FORTRAN array of dimension n_1 \u00d7 n_2 \u00d7 n_3, find the location of the element A(I,J,K) in terms of the location of A(1,1,1) and I, J and K, where I,J and K are simple integer variables. Assume that elements are stored in lexicographic order of their indices.\n\nOptions:\nA. 480\nB. 500\nC.             450\nD. 465\n\nAnswer: D\n\nReference Solution:\n(a) All conventional computers require a multidimensional array to be stored as a linear sequence of elements. The compiler must, therefore, contain a procedure that computes the actual location of an element in an array from its specification in terms of indices. The map-ping from the multidimensional array to the linear array is not unique. However, if we assume that the elements of the multidimensional array are stored in the lexicographic order of their indices, wecaysay that A(5,7,4) comes in the fourth column of the seventh row of the fifth plane of the array; i.e., it is preceded by four planes, six rows and three elements. But the FORTRAN statement DIMENSION A(10,15,7) allocates a storage area equivalent to 10 planes of 15 rows with 7 elements in each row. Each of the 10 planes, therefore; contains 15 \u00d7 7 elements. If loc(X) is the location of element A(X), then loc(5,7,4) = loc(1,1,1) + 4(15\\bullet7) + 6(7) + 3 = loc(1,1,1)+ 420 + 42 + 3 = loc(1,1,1) + 465. Hence, the displacement of the location of the element A(5,7,4) relative to the location of A(1,1,1) is 465. (b) Generalizing the reasoning of part (a), we can say that A(I,J,K) comes in the K-thcolumn of the J-throw of the I-thplane of the array, i.e., it is preceded by (I-1) planes, (J-1) rows, and (K-1) elements. But A's dimensions are n1\u00d7 n_2 \u00d7 n_3, which means that each plane contains n_2 rows and n_3 columns, or n_2n_3 elements. Therefore, loc(I,J,K) = loc(1,1,1) + (I-1)n_2n_3 + (J-1)n_3 + (K-1) The part played by array dimensions n_1, n_2, n_3 in storage mapping is one reason why FORTRAN (and most other programming languages) require the actual dimensions of arrays to be declared. Some compilers, e.g., the WATFIV FORTRAN compiler, generate a code that determines during execution of the program whether a reference to a subscripted variable lies out-side the declared array bounds. If it does, and were to remain undetected, the information might get recorded in locations that house other data, or even in the program itself, altering the program and, hence, its behavior Since such compilers as WATFIV are used for program testing, the increase in execution time due to these tests is well worth it.", "ref_id": 4704, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "DIMENSION A(10,15,7) Assuming that elements of arrays are stored in lexicographic order of their indices, find the displacement of the location of the element A(5,7,4) relative to the location of A(1,1,1). (b)If A is a three-dimensional FORTRAN array of dimension n_1 \u00d7 n_2 \u00d7 n_3, find the location of the element A(I,J,K) in terms of the location of A(1,1,1) and I, J and K, where I,J and K are simple integer variables. Assume that elements are stored in lexicographic order of their indices.", "options": ["480", "500", "450", "465"], "answer": "D", "solution": "(a) All conventional computers require a multidimensional array to be stored as a linear sequence of elements. The compiler must, therefore, contain a procedure that computes the actual location of an element in an array from its specification in terms of indices. The map-ping from the multidimensional array to the linear array is not unique. However, if we assume that the elements of the multidimensional array are stored in the lexicographic order of their indices, wecaysay that A(5,7,4) comes in the fourth column of the seventh row of the fifth plane of the array; i.e., it is preceded by four planes, six rows and three elements. But the FORTRAN statement DIMENSION A(10,15,7) allocates a storage area equivalent to 10 planes of 15 rows with 7 elements in each row. Each of the 10 planes, therefore; contains 15 \u00d7 7 elements. If loc(X) is the location of element A(X), then loc(5,7,4) = loc(1,1,1) + 4(15\\bullet7) + 6(7) + 3 = loc(1,1,1)+ 420 + 42 + 3 = loc(1,1,1) + 465. Hence, the displacement of the location of the element A(5,7,4) relative to the location of A(1,1,1) is 465. (b) Generalizing the reasoning of part (a), we can say that A(I,J,K) comes in the K-thcolumn of the J-throw of the I-thplane of the array, i.e., it is preceded by (I-1) planes, (J-1) rows, and (K-1) elements. But A's dimensions are n1\u00d7 n_2 \u00d7 n_3, which means that each plane contains n_2 rows and n_3 columns, or n_2n_3 elements. Therefore, loc(I,J,K) = loc(1,1,1) + (I-1)n_2n_3 + (J-1)n_3 + (K-1) The part played by array dimensions n_1, n_2, n_3 in storage mapping is one reason why FORTRAN (and most other programming languages) require the actual dimensions of arrays to be declared. Some compilers, e.g., the WATFIV FORTRAN compiler, generate a code that determines during execution of the program whether a reference to a subscripted variable lies out-side the declared array bounds. If it does, and were to remain undetected, the information might get recorded in locations that house other data, or even in the program itself, altering the program and, hence, its behavior Since such compilers as WATFIV are used for program testing, the increase in execution time due to these tests is well worth it."}, "question": "task_1"}}, {"data": {"text": "Question:\nWrite a FORTRAN program to simulate the daily activity at a gasstation. Assuming that one customer is served every six minutes, what is the average waiting time per customer?\n\nOptions:\nA. MAX (SERV - 1,0)\nB. FLOAT (CARTOT)/FLOAT (WAIT)\nC.             FLOAT (WAIT)/FLOAT (CARTOT)\nD. SERV + 6\n\nAnswer: C\n\nReference Solution:\nThis is a problem in discrete simulation. A random number generatoris used in the program to model the arrival of customers. Since thegas station attendant cannot know if the stream of customers will be continuous, randomness of arrivals is assumed. To calculate the average waiting time, the program should compute the waitingtime of each individual car, add the times, and divide that sum by thetotal number of cars. The first arrival incurs no waiting time, but all subsequentarrivals must wait six minutes for each car in front of them. To obtainan average the service time remaining for each car, the total waitingtime for all the cars, and the number of cars that are lined up must befound. For each simulated minute, the program must reduce the service time SERV by one and check to see if another car has arrived.If so, the waiting timefor that last car is given by SERV. WAIT - the total waiting time, is increasedby adding SERV to it, while the number of cars, CARTOT, is Increased by one, and SERV is increased by six minutes. The parameter N is the number of minutes to be simulated (N cannot contain more than 6 digits). Another assumption made is that customers arrive each minute with a probabilityof 0.1. To simplify the problem, it is assumed that there is only onegas pump at this station. Note, that several values of N can be entered in the DATA section. The programprocedure will be done for each of those time intervals. In order toend the program, enter N \\leq 0 as the last value. CGASOLINE LINE SIMULATION GASOLINE LINE SIMULATION INTEGER WAIT, SERV, CARTOT, TIME 5READ (5,1)N 1 FORMATE (I6) CDO WHILE N GREATER THAN ZERO IF (N. LE. 0) GO TO 99 SERV = 0 WAIT = 0 CARTOT = 0 DO 10 TIME = 1,N SERV = MAX (SERV - 1,0) 222 CALL RAND (X) IF (X.GT.0.1) GO TO 22 CARTOT = CARTOT + 1 WAIT = WAIT + SERV SERV = SERV + 6 10CONTINUE AVWAIT = FLOAT (WAIT)/FLOAT (CARTOT) WRITE (6,101) CARTOT,AVWAIT 101FORMAT (IX,'AVERAGE WAIT FOR EACH OF THE', 16,'CUSTOMERS IS', F6.2,'MINUTES.') GO TO 5 CEND DO-WHILE 99STOP END", "ref_id": 4705, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Write a FORTRAN program to simulate the daily activity at a gasstation. Assuming that one customer is served every six minutes, what is the average waiting time per customer?", "options": ["MAX (SERV - 1,0)", "FLOAT (CARTOT)/FLOAT (WAIT)", "FLOAT (WAIT)/FLOAT (CARTOT)", "SERV + 6"], "answer": "C", "solution": "This is a problem in discrete simulation. A random number generatoris used in the program to model the arrival of customers. Since thegas station attendant cannot know if the stream of customers will be continuous, randomness of arrivals is assumed. To calculate the average waiting time, the program should compute the waitingtime of each individual car, add the times, and divide that sum by thetotal number of cars. The first arrival incurs no waiting time, but all subsequentarrivals must wait six minutes for each car in front of them. To obtainan average the service time remaining for each car, the total waitingtime for all the cars, and the number of cars that are lined up must befound. For each simulated minute, the program must reduce the service time SERV by one and check to see if another car has arrived.If so, the waiting timefor that last car is given by SERV. WAIT - the total waiting time, is increasedby adding SERV to it, while the number of cars, CARTOT, is Increased by one, and SERV is increased by six minutes. The parameter N is the number of minutes to be simulated (N cannot contain more than 6 digits). Another assumption made is that customers arrive each minute with a probabilityof 0.1. To simplify the problem, it is assumed that there is only onegas pump at this station. Note, that several values of N can be entered in the DATA section. The programprocedure will be done for each of those time intervals. In order toend the program, enter N \\leq 0 as the last value. CGASOLINE LINE SIMULATION GASOLINE LINE SIMULATION INTEGER WAIT, SERV, CARTOT, TIME 5READ (5,1)N 1 FORMATE (I6) CDO WHILE N GREATER THAN ZERO IF (N. LE. 0) GO TO 99 SERV = 0 WAIT = 0 CARTOT = 0 DO 10 TIME = 1,N SERV = MAX (SERV - 1,0) 222 CALL RAND (X) IF (X.GT.0.1) GO TO 22 CARTOT = CARTOT + 1 WAIT = WAIT + SERV SERV = SERV + 6 10CONTINUE AVWAIT = FLOAT (WAIT)/FLOAT (CARTOT) WRITE (6,101) CARTOT,AVWAIT 101FORMAT (IX,'AVERAGE WAIT FOR EACH OF THE', 16,'CUSTOMERS IS', F6.2,'MINUTES.') GO TO 5 CEND DO-WHILE 99STOP END"}, "question": "task_1"}}, {"data": {"text": "Question:\nWrite a FORTRAN program to compute the arithmetic mean of N real numbers. You may assume that the numbers have been read into an array X having members X(1), X(2),..., X(N).\n\nOptions:\nA. DIMENSION X(N) SUM = 1.0 READ (5,20) N 2\\OFORMAT (2X,I5) DO 50 I = 1,N 5\\OSUM = SUM + X(I) AVG = SUM/FLOAT (N) STOP END\nB. DIMENSION X(N) SUM = 0.0 WRITE (5,20) N 2\\OFORMAT (2X,I5) DO 50 I = 1,N 5\\OSUM = SUM + X(I) AVG = SUM/FLOAT (N) STOP END\nC.             DIMENSION X(N) SUM = 0.0 READ (5,20) N 2\\OFORMAT (2X,I5) DO 50 I = 1,N 5\\OSUM = SUM + X(I) AVG = SUM/INT (N) STOP END\nD. DIMENSION X(N) SUM = 0.0 READ (5,20) N 2\\OFORMAT (2X,I5) DO 50 I = 1,N 5\\OSUM = SUM + X(I) AVG = SUM/FLOAT (N) STOP END\n\nAnswer: D\n\nReference Solution:\nWe apply the formula X= (^N\\sum_i_=1 X(i)) / N = (X(1) + X(2)+...+X(N)) / N . The variable SUM is used to accumulate the value of the sum of the X(i)'s. The variable AVG (the mean value) is set equal to SUM/N. DIMENSION X(N) SUM = 0.0 READ (5,20) N 2\\OFORMAT (2X,I5) DO 50 I = 1,N 5\\OSUM = SUM + X(I) AVG = SUM/FLOAT (N) STOP END", "ref_id": 4706, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Write a FORTRAN program to compute the arithmetic mean of N real numbers. You may assume that the numbers have been read into an array X having members X(1), X(2),..., X(N).", "options": ["DIMENSION X(N) SUM = 1.0 READ (5,20) N 2\\OFORMAT (2X,I5) DO 50 I = 1,N 5\\OSUM = SUM + X(I) AVG = SUM/FLOAT (N) STOP END", "DIMENSION X(N) SUM = 0.0 WRITE (5,20) N 2\\OFORMAT (2X,I5) DO 50 I = 1,N 5\\OSUM = SUM + X(I) AVG = SUM/FLOAT (N) STOP END", "DIMENSION X(N) SUM = 0.0 READ (5,20) N 2\\OFORMAT (2X,I5) DO 50 I = 1,N 5\\OSUM = SUM + X(I) AVG = SUM/INT (N) STOP END", "DIMENSION X(N) SUM = 0.0 READ (5,20) N 2\\OFORMAT (2X,I5) DO 50 I = 1,N 5\\OSUM = SUM + X(I) AVG = SUM/FLOAT (N) STOP END"], "answer": "D", "solution": "We apply the formula X= (^N\\sum_i_=1 X(i)) / N = (X(1) + X(2)+...+X(N)) / N . The variable SUM is used to accumulate the value of the sum of the X(i)'s. The variable AVG (the mean value) is set equal to SUM/N. DIMENSION X(N) SUM = 0.0 READ (5,20) N 2\\OFORMAT (2X,I5) DO 50 I = 1,N 5\\OSUM = SUM + X(I) AVG = SUM/FLOAT (N) STOP END"}, "question": "task_1"}}, {"data": {"text": "Question:\nExplain how the following procedures are useful in debugging a program: a) tracing a function b) Stop control.\n\nOptions:\nA. Tracing a function and stop control mode are not useful in debugging a program\nB. Tracing a function helps in writing the code\nC.             Stop control mode helps in speeding up the program's execution\nD. Tracing a function allows the programmer to investigate what is happening in each instruction of his program. Stop control mode halts program execution at a specific instruction so the programmer can examine it.\n\nAnswer: D\n\nReference Solution:\nWhen a function returns improper or unexpected results, the programmer can investigate what is happening in each instruction of his program by tracing its execution, using the trace function. Consider the following program: \\nablaDOOMED [1]S \\leftarrow X1, X2, ..... , XN [2]\\DeltaS \\Delta \\Delta [3]S[\\Delta] \\Delta [4]INVS \\leftarrow \\divS [5]PS1S2 \\leftarrow ((S(I) - S(I - 1)) \\div (INVS(I) - INVS(I - 1)) [6]\\rightarrow [8] \u00d7 \u0285(PS1S2 < 0) [7]'THE NEGATIVE PRODUCTS ARE:'; PS1S2 [8]\\rightarrow [10] \u00d7 \u0285(PS1S2 < 100) [9]'THE POSITIVE PRODUCTS LESS THAN 100:'; PS1S2 [10]'THE POSITIVE PRODUCTS GREATER THAN 100:'; PS1S2 [11]\\nabla If we run this program through, only negative products are printed. To see what is wrong we can put the function in trace mode, i.e. T\\DeltaDOOMED \\leftarrow 1 2 3 4 5 6 7 8 9 10 Where 1,2...,10 are the statement numbers. But the program is quite long. The mistake probably lies in statement [5]. Hence, instead of trying to trace the action of the system through the whole function we can concentrate on [5]. Key in TADOOMED \\leftarrow [5]. The output is DOOMED DOOMED[5]-XIX2 DOOMED[5]-X3X2 DOOMED[5]-X4X3 \\bullet\\bullet \\bullet\\bullet \\bullet\\bullet DOOMED[5]-XNXN-1 Since all the products are negative, there is something wrong with instruction [5]. Converting into algebraic form: PS1S2 = [X_1 -X_2] / [(1/X_1) - (1/X_2)] = [X_1 - X_2] / [(X2- X_1) / (X_1X_2)] = [(X1- X_2) / (X_2 - X_1)] (X_1X_2) = [(X1- X_2) / -(X_1 - X_2)] (X_1X_2) = -(X1X_2). Statement [5] always results in a negative product. To en-sure correct calculations we can change [5] to [5]PS1S2 \\leftarrow ((S(I) - S(I - 1)) \\div (INVS(I - 1) - INVS(I)). b) The stop control mode halts program execution at a specific instruction so the programmer can examine it. For example, suppose we wish to inspect [6] of DOOMED. To activate the stop control mode, key in S\\DeltaDOOMED \\leftarrow 6 DOOMED The system responds with [6] \\rightarrow [8] \u00d7 \u0285(PS1S2 < 0). To end the stop control mode, key in S\\DeltaDOOMED \\leftarrow 10.", "ref_id": 4707, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Explain how the following procedures are useful in debugging a program: a) tracing a function b) Stop control.", "options": ["Tracing a function and stop control mode are not useful in debugging a program", "Tracing a function helps in writing the code", "Stop control mode helps in speeding up the program's execution", "Tracing a function allows the programmer to investigate what is happening in each instruction of his program. Stop control mode halts program execution at a specific instruction so the programmer can examine it."], "answer": "D", "solution": "When a function returns improper or unexpected results, the programmer can investigate what is happening in each instruction of his program by tracing its execution, using the trace function. Consider the following program: \\nablaDOOMED [1]S \\leftarrow X1, X2, ..... , XN [2]\\DeltaS \\Delta \\Delta [3]S[\\Delta] \\Delta [4]INVS \\leftarrow \\divS [5]PS1S2 \\leftarrow ((S(I) - S(I - 1)) \\div (INVS(I) - INVS(I - 1)) [6]\\rightarrow [8] \u00d7 \u0285(PS1S2 < 0) [7]'THE NEGATIVE PRODUCTS ARE:'; PS1S2 [8]\\rightarrow [10] \u00d7 \u0285(PS1S2 < 100) [9]'THE POSITIVE PRODUCTS LESS THAN 100:'; PS1S2 [10]'THE POSITIVE PRODUCTS GREATER THAN 100:'; PS1S2 [11]\\nabla If we run this program through, only negative products are printed. To see what is wrong we can put the function in trace mode, i.e. T\\DeltaDOOMED \\leftarrow 1 2 3 4 5 6 7 8 9 10 Where 1,2...,10 are the statement numbers. But the program is quite long. The mistake probably lies in statement [5]. Hence, instead of trying to trace the action of the system through the whole function we can concentrate on [5]. Key in TADOOMED \\leftarrow [5]. The output is DOOMED DOOMED[5]-XIX2 DOOMED[5]-X3X2 DOOMED[5]-X4X3 \\bullet\\bullet \\bullet\\bullet \\bullet\\bullet DOOMED[5]-XNXN-1 Since all the products are negative, there is something wrong with instruction [5]. Converting into algebraic form: PS1S2 = [X_1 -X_2] / [(1/X_1) - (1/X_2)] = [X_1 - X_2] / [(X2- X_1) / (X_1X_2)] = [(X1- X_2) / (X_2 - X_1)] (X_1X_2) = [(X1- X_2) / -(X_1 - X_2)] (X_1X_2) = -(X1X_2). Statement [5] always results in a negative product. To en-sure correct calculations we can change [5] to [5]PS1S2 \\leftarrow ((S(I) - S(I - 1)) \\div (INVS(I - 1) - INVS(I)). b) The stop control mode halts program execution at a specific instruction so the programmer can examine it. For example, suppose we wish to inspect [6] of DOOMED. To activate the stop control mode, key in S\\DeltaDOOMED \\leftarrow 6 DOOMED The system responds with [6] \\rightarrow [8] \u00d7 \u0285(PS1S2 < 0). To end the stop control mode, key in S\\DeltaDOOMED \\leftarrow 10."}, "question": "task_1"}}, {"data": {"text": "Question:\nRender the following \"nonsense\"pseudocodeinto FORTRAN, including appropriate comments.Name the law ofpropositional logic you need to render the DO-WHILE and IF-THEN-ELSE constructs: inputL, J, KOUNT, N I \\leftarrow 1 dowhile L < J\\textasteriskcentered\\textasteriskcentered3 and I < KOUNT KOUNT \\leftarrow KOUNT + 2 ifJ < 0 or L < 0 thenJ\\leftarrow J + 1 elseL \\leftarrow L + 1 endif I \\leftarrow I + 1 enddo-while outputKOUNT, J, L endprogram\n\nOptions:\nA. DeMorgan's Law\nB. Ohm's Law\nC.             Pascal's Law\nD. Newton's Law\n\nAnswer: A\n\nReference Solution:\nThe name of the law requiredIsoften referred to asDeMorgan's Law, which is stated thus: not(P and Q) \\equiv not P or not Q Actually,DeMorgan'slawIncludesthe Boolean equation P or Q \\equiv not [not P and not Q] Here, the two constructs use the former equivalence. INTEGER L, J, KOUNT,N READ (5,100) L,J,KOUNT,N 100FORMAT (4 I 5) I =1 . CDO WHILE L LESS THAN J\\textasteriskcentered\\textasteriskcentered3 AND CI IS GREATER THAN KOUNT 10IF (L. GE.J\\textasteriskcentered\\textasteriskcentered3.OR.I. GE. KOUNT) GO TO 20 KOUNT = KOUNT + 2 CIF J LESS THAN 0 OR L GREATER CTHAN ZERO THEN DO IF (.NOT. (J.GE.0.AND.L.LE.0)) GO TO 30 CELSE DO L = L + 1 GO TO 40 30J = J + 1 40CONTINUE CENDIF I = I + 1 GO TO 10 CEND DO-WHILE 20CONTINUE STOP END", "ref_id": 4708, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Render the following \"nonsense\"pseudocodeinto FORTRAN, including appropriate comments.Name the law ofpropositional logic you need to render the DO-WHILE and IF-THEN-ELSE constructs: inputL, J, KOUNT, N I \\leftarrow 1 dowhile L < J\\textasteriskcentered\\textasteriskcentered3 and I < KOUNT KOUNT \\leftarrow KOUNT + 2 ifJ < 0 or L < 0 thenJ\\leftarrow J + 1 elseL \\leftarrow L + 1 endif I \\leftarrow I + 1 enddo-while outputKOUNT, J, L endprogram", "options": ["DeMorgan's Law", "Ohm's Law", "Pascal's Law", "Newton's Law"], "answer": "A", "solution": "The name of the law requiredIsoften referred to asDeMorgan's Law, which is stated thus: not(P and Q) \\equiv not P or not Q Actually,DeMorgan'slawIncludesthe Boolean equation P or Q \\equiv not [not P and not Q] Here, the two constructs use the former equivalence. INTEGER L, J, KOUNT,N READ (5,100) L,J,KOUNT,N 100FORMAT (4 I 5) I =1 . CDO WHILE L LESS THAN J\\textasteriskcentered\\textasteriskcentered3 AND CI IS GREATER THAN KOUNT 10IF (L. GE.J\\textasteriskcentered\\textasteriskcentered3.OR.I. GE. KOUNT) GO TO 20 KOUNT = KOUNT + 2 CIF J LESS THAN 0 OR L GREATER CTHAN ZERO THEN DO IF (.NOT. (J.GE.0.AND.L.LE.0)) GO TO 30 CELSE DO L = L + 1 GO TO 40 30J = J + 1 40CONTINUE CENDIF I = I + 1 GO TO 10 CEND DO-WHILE 20CONTINUE STOP END"}, "question": "task_1"}}, {"data": {"text": "Question:\nObtain the 1's and 2's complements of the following binary numbers: a)1010101 b)0111000 c)0000001 d)10000 e)0000\n\nOptions:\nA. a) 1's complement: 0101010, 2's complement: 1010101; b) 1's complement: 1000111, 2's complement: 0111000; c) 1's complement: 1111110, 2's complement: 0000001; d) 1's complement: 01111, 2's complement: 10000; e) 1's complement: 1111, 2's complement: 0000\nB. a) 1's complement: 0101010, 2's complement: 0101011; b) 1's complement: 1000111, 2's complement: 1001000; c) 1's complement: 1111110, 2's complement: 1111111; d) 1's complement: 01111, 2's complement: 10000; e) 1's complement: 1111, 2's complement: 10000\nC.             a) 1's complement: 1010101, 2's complement: 1010100; b) 1's complement: 0111000, 2's complement: 0110111; c) 1's complement: 0000000, 2's complement: 0000001; d) 1's complement: 10000, 2's complement: 01111; e) 1's complement: 0000, 2's complement: 1111\nD. a) 1's complement: 1111111, 2's complement: 0000000; b) 1's complement: 1000111, 2's complement: 0111000; c) 1's complement: 1111111, 2's complement: 0000000; d) 1's complement: 11111, 2's complement: 00000; e) 1's complement: 1111, 2's complement: 0000\n\nAnswer: B\n\nReference Solution:\nForming complements is useful when one wants to perform subtractionwithout borrowing from another column. This is because subtractionis the same as adding the two's complement. a) The 1's complement of 1010101_2 is found by subtracting it from 1111111 .Thus 1111111 -1010101 0101010 The two's complement is formed by subtracting1010101_2 .from 10000000. Thus, 10000000 - 1010101 00101011 Forming the two's complement by binary subtraction is difficult. b) Since the base, or radix, of the binary systemis2, the one's complementis referred to as the radix minus one complement. Similarly, thetwo's complement is called the radix complement. The radix minus one complementof 0111000_2 is 1111111 - 0111000 1000111 The radix complement of 0111000_2 is 10000000 - 0111000 1001000 While examining a) and b), note that finding the radix minus one complementsof the two given numbers is equivalent to changing 0's to 1's and1's to 0's in the given numbers. c) The radix minus one complement of 0000001 is 1111110. The radix complementis 10000000 - 0000001 1111111 Examining the radix complements of a), b) and c) observe that Radix complement(X)_2 = Radix complement minus one(X)_2 + 1(1) whereX is a binary number. d) The one's complement of 10000 is 01111 or 1111. The two's complement, using (1) is 1111 +1 10000 or, the number itself. e) The radix minus one complement of 0000 is 1111 and the radix complementis 1111 +1 10000 To illustrate the advantage of representing numbers by their radix complements, suppose we wish to store the negative of d), i.e., -10000, in a12 - bit word. The left-most bit has value 1 to represent the minus sign: 1000 0001 0000 Now suppose word size is increased to 16 bits. This is most easily done byadding 4 bits with zero value on the left. But the left-most bit must be changedto 1 and the 1 in the third quartet of bits (third from the left) must bechanged to zero: 1000 0000 0001 0000 Suppose ,instead, that the radix complement of -10000 is in a 12-bit storage. The radix complement of -10000 in a 12-bit storage is 111111111111 -10000 111111101111 +1 111111110000 Now, if word length is to be extended to 16 bits, simply add a quartet of 1's. No special provisions need be made for the sign bit. In other words, whenword size is increased, simply copy the sign bit into all the bits to its left. Finally, the two's complement representation is preferred to the one'scomplement because + 0 \\not = - 0 in the one's complement, but + 0 = - 0 in the 2's complement.", "ref_id": 4709, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Obtain the 1's and 2's complements of the following binary numbers: a)1010101 b)0111000 c)0000001 d)10000 e)0000", "options": ["a) 1's complement: 0101010, 2's complement: 1010101; b) 1's complement: 1000111, 2's complement: 0111000; c) 1's complement: 1111110, 2's complement: 0000001; d) 1's complement: 01111, 2's complement: 10000; e) 1's complement: 1111, 2's complement: 0000", "a) 1's complement: 0101010, 2's complement: 0101011; b) 1's complement: 1000111, 2's complement: 1001000; c) 1's complement: 1111110, 2's complement: 1111111; d) 1's complement: 01111, 2's complement: 10000; e) 1's complement: 1111, 2's complement: 10000", "a) 1's complement: 1010101, 2's complement: 1010100; b) 1's complement: 0111000, 2's complement: 0110111; c) 1's complement: 0000000, 2's complement: 0000001; d) 1's complement: 10000, 2's complement: 01111; e) 1's complement: 0000, 2's complement: 1111", "a) 1's complement: 1111111, 2's complement: 0000000; b) 1's complement: 1000111, 2's complement: 0111000; c) 1's complement: 1111111, 2's complement: 0000000; d) 1's complement: 11111, 2's complement: 00000; e) 1's complement: 1111, 2's complement: 0000"], "answer": "B", "solution": "Forming complements is useful when one wants to perform subtractionwithout borrowing from another column. This is because subtractionis the same as adding the two's complement. a) The 1's complement of 1010101_2 is found by subtracting it from 1111111 .Thus 1111111 -1010101 0101010 The two's complement is formed by subtracting1010101_2 .from 10000000. Thus, 10000000 - 1010101 00101011 Forming the two's complement by binary subtraction is difficult. b) Since the base, or radix, of the binary systemis2, the one's complementis referred to as the radix minus one complement. Similarly, thetwo's complement is called the radix complement. The radix minus one complementof 0111000_2 is 1111111 - 0111000 1000111 The radix complement of 0111000_2 is 10000000 - 0111000 1001000 While examining a) and b), note that finding the radix minus one complementsof the two given numbers is equivalent to changing 0's to 1's and1's to 0's in the given numbers. c) The radix minus one complement of 0000001 is 1111110. The radix complementis 10000000 - 0000001 1111111 Examining the radix complements of a), b) and c) observe that Radix complement(X)_2 = Radix complement minus one(X)_2 + 1(1) whereX is a binary number. d) The one's complement of 10000 is 01111 or 1111. The two's complement, using (1) is 1111 +1 10000 or, the number itself. e) The radix minus one complement of 0000 is 1111 and the radix complementis 1111 +1 10000 To illustrate the advantage of representing numbers by their radix complements, suppose we wish to store the negative of d), i.e., -10000, in a12 - bit word. The left-most bit has value 1 to represent the minus sign: 1000 0001 0000 Now suppose word size is increased to 16 bits. This is most easily done byadding 4 bits with zero value on the left. But the left-most bit must be changedto 1 and the 1 in the third quartet of bits (third from the left) must bechanged to zero: 1000 0000 0001 0000 Suppose ,instead, that the radix complement of -10000 is in a 12-bit storage. The radix complement of -10000 in a 12-bit storage is 111111111111 -10000 111111101111 +1 111111110000 Now, if word length is to be extended to 16 bits, simply add a quartet of 1's. No special provisions need be made for the sign bit. In other words, whenword size is increased, simply copy the sign bit into all the bits to its left. Finally, the two's complement representation is preferred to the one'scomplement because + 0 \\not = - 0 in the one's complement, but + 0 = - 0 in the 2's complement."}, "question": "task_1"}}, {"data": {"text": "Question:\na) 3652_8 \u00d7 24_8 b b ) 11.01_2 \u00d7 1.01_2 ) 11.01_2 \u00d7 1.01_2 c) 5AB_16 \u00d7 F5A_16\n\nOptions:\nA. 123456_8, 111.1111_2, ABCDEF_16\nB. 654321_8, 000.0000_2, 12345F_16\nC.             114510_8, 100.0001_2, 57031D_16\nD. 987654_8, 101.1010_2, FEDCBA_16\n\nAnswer: C\n\nReference Solution:\na) When doing multiplication in a base other than base 10, there aretwo common approaches. The first is to multiply the numbers together withbase 10 multiplication, get an answer in base 10, and then encode theanswer into the desired base. The other method is a direct one; you needto know the multiplication tables for the particular base. In this example, we have each line as a partial product. After the products are obtained, we add them together as base 8 numbers. Thus, 3652 \u00d724_8 10 24 30 14 124 14 ___6____ 114510_8 b) Binary numbers can also be multiplied via partial products. 11. 01_2 \u00d71. 01_2 1101 0000 1101 100.0001_2 As in base 10, the total number of digits in the multiplier and multi-plicand tothe right of the binary point must equal to the number of digits to the rightof the binary point in the product. c) Hexadecimal multiplication is often confusing because letters are used tosignify numbers. Although it is possible to use the partial product method, it is far simpler to convert the hexadecimal numbers to decimal numbersand then perform the multiplication. 5AB_16 = (5 \u00d7 16^2) + (A \u00d7 16^1) + (B \u00d7 16^0) Remembering that A_16 = 10_10 and B_16 = 11_10, you can write = (5 \u00d7 16^2) + (10 \u00d7 16^1) + (11 \u00d7 16^0) = 1280 + 160 + 11 5AB_16 = 1451_10 5AB_16 = 1451_10 F5A_16 = (F \u00d7 16^2) + (5 \u00d7 16^1) + (A x 16^0) Also recall thatF_16 = 15_10, so that F5A_16 = (15 \u00d7 16^2) + (5 \u00d7 16^1) + (10 \u00d7 16^0) = 3840 + 80 + 10 F5A_16 = 3930_10 Now the multiplication is simple: 1451_10 \u00d7 3930_10 43530 13059 4353 5702430_10 To convert back to hexadecimal, you can subtract powers of 16. The value of16^5 is 1,048,576. Multiply this by5,and you will get 5,242,880, which is lessthan 5,702,430. Subtract and look at the answer. Check the value of 16^4 and do the same as above. Continue the process until all digits have beenaccounted for. The example will show the correct procedure. 16^516^416^316^216^116^0 1048576655364096256161 5702430Digits of Hex - 5242880(= 5 \u00d7 16^5)Number 4595505 - 458752(= 7 \u00d7 16^4)7 798 -000(16^3 is too big)0 798 -768(= 3 \u00d7 16^2)3 30 -16(= 1 \u00d7 16^1)1 14 -14(= 14 \u00d7 16^0)D The answer is 57031D_16.", "ref_id": 4710, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "a) 3652_8 \u00d7 24_8 b b ) 11.01_2 \u00d7 1.01_2 ) 11.01_2 \u00d7 1.01_2 c) 5AB_16 \u00d7 F5A_16", "options": ["123456_8, 111.1111_2, ABCDEF_16", "654321_8, 000.0000_2, 12345F_16", "114510_8, 100.0001_2, 57031D_16", "987654_8, 101.1010_2, FEDCBA_16"], "answer": "C", "solution": "a) When doing multiplication in a base other than base 10, there aretwo common approaches. The first is to multiply the numbers together withbase 10 multiplication, get an answer in base 10, and then encode theanswer into the desired base. The other method is a direct one; you needto know the multiplication tables for the particular base. In this example, we have each line as a partial product. After the products are obtained, we add them together as base 8 numbers. Thus, 3652 \u00d724_8 10 24 30 14 124 14 ___6____ 114510_8 b) Binary numbers can also be multiplied via partial products. 11. 01_2 \u00d71. 01_2 1101 0000 1101 100.0001_2 As in base 10, the total number of digits in the multiplier and multi-plicand tothe right of the binary point must equal to the number of digits to the rightof the binary point in the product. c) Hexadecimal multiplication is often confusing because letters are used tosignify numbers. Although it is possible to use the partial product method, it is far simpler to convert the hexadecimal numbers to decimal numbersand then perform the multiplication. 5AB_16 = (5 \u00d7 16^2) + (A \u00d7 16^1) + (B \u00d7 16^0) Remembering that A_16 = 10_10 and B_16 = 11_10, you can write = (5 \u00d7 16^2) + (10 \u00d7 16^1) + (11 \u00d7 16^0) = 1280 + 160 + 11 5AB_16 = 1451_10 5AB_16 = 1451_10 F5A_16 = (F \u00d7 16^2) + (5 \u00d7 16^1) + (A x 16^0) Also recall thatF_16 = 15_10, so that F5A_16 = (15 \u00d7 16^2) + (5 \u00d7 16^1) + (10 \u00d7 16^0) = 3840 + 80 + 10 F5A_16 = 3930_10 Now the multiplication is simple: 1451_10 \u00d7 3930_10 43530 13059 4353 5702430_10 To convert back to hexadecimal, you can subtract powers of 16. The value of16^5 is 1,048,576. Multiply this by5,and you will get 5,242,880, which is lessthan 5,702,430. Subtract and look at the answer. Check the value of 16^4 and do the same as above. Continue the process until all digits have beenaccounted for. The example will show the correct procedure. 16^516^416^316^216^116^0 1048576655364096256161 5702430Digits of Hex - 5242880(= 5 \u00d7 16^5)Number 4595505 - 458752(= 7 \u00d7 16^4)7 798 -000(16^3 is too big)0 798 -768(= 3 \u00d7 16^2)3 30 -16(= 1 \u00d7 16^1)1 14 -14(= 14 \u00d7 16^0)D The answer is 57031D_16."}, "question": "task_1"}}, {"data": {"text": "Question:\nBriefly explain thesignificance of the ASSEMBLER language.\n\nOptions:\nA. ASSEMBLER language eliminates the need for binary code.\nB. ASSEMBLER language is an intermediate language that translates high-level programming languages into binary code, saving execution time.\nC.             ASSEMBLER language is a high-level programming language.\nD. ASSEMBLER language translates binary code into high-level programming languages.\n\nAnswer: B\n\nReference Solution:\nAny high level-language, such as BASIC, FORTRAN, COBOL, and others, is a very convenient and relatively simple set of instructions that a programmeruses to record a program needed to be executed. However, theselanguages are not readable by a computer, and have to be translatedinto an intermediate language, which, in turn, is changed into binarycode before the actual execution pro-cess starts. This intermediate language is called the ASSEMBLER language. It is not a mandatory rule to use a high level-language for writing a program. A program can be written in assemb-ler language. This saves a computersome execution time by eliminating the process of translation of thehigh-level in-structions into assembly instructions. It adds, however, the procedureof checking the input assembly program for syntax errors. But theloss of time from this check is minimal compared to the gain of time fromeliminating the translation step. Being the next step from high-level language coding to the actual executionprocess, the assembler language is called a low-level programminglanguage.", "ref_id": 4711, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Briefly explain thesignificance of the ASSEMBLER language.", "options": ["ASSEMBLER language eliminates the need for binary code.", "ASSEMBLER language is an intermediate language that translates high-level programming languages into binary code, saving execution time.", "ASSEMBLER language is a high-level programming language.", "ASSEMBLER language translates binary code into high-level programming languages."], "answer": "B", "solution": "Any high level-language, such as BASIC, FORTRAN, COBOL, and others, is a very convenient and relatively simple set of instructions that a programmeruses to record a program needed to be executed. However, theselanguages are not readable by a computer, and have to be translatedinto an intermediate language, which, in turn, is changed into binarycode before the actual execution pro-cess starts. This intermediate language is called the ASSEMBLER language. It is not a mandatory rule to use a high level-language for writing a program. A program can be written in assemb-ler language. This saves a computersome execution time by eliminating the process of translation of thehigh-level in-structions into assembly instructions. It adds, however, the procedureof checking the input assembly program for syntax errors. But theloss of time from this check is minimal compared to the gain of time fromeliminating the translation step. Being the next step from high-level language coding to the actual executionprocess, the assembler language is called a low-level programminglanguage."}, "question": "task_1"}}, {"data": {"text": "Question:\nExplain with illustrations how data are read in (acquired) , writtenout (disposed of) and referred to in array structures.\n\nOptions:\nA. Data are read in array structures by declaring the array, then using a GET statement or DO loop to read the values. Data are written out by using the PUT statement. Referring to an element of an array is done by using a subscripted reference.\nB. Referring to an element of an array is done by using a multidimensional array\nC.             Data are read in array structures by using a PUT statement\nD. Data are written out by using a GET statement\n\nAnswer: A\n\nReference Solution:\nA matrix (i.e. a two dimensional array) is de-clared by the statement DCL X [9, 9] FIXEDDECIMAL(4); Now if a problem requires that the values of the main diagon-al of the matrixbe read in, there are two techniques for doing it.i) Use of a single getstatement of the form given below: GET LIST(X(1,1), X(2,2), X(3,3), X(4,4), X(5,5), X(6,6), X(7,7) , X(8,8) , X(9,9)) , or, ii) the iterative DO group illustrated below: DO I = 1 TO 9 BY 1; GET LIST X [I, I] ; END; The first method has the disadvantage that a long data specification is required. The second method is short and flexible. One of the ways to acquire data for one dimensionalarraysis as follows: GETLIST(N); DO I = 1 TO N BY 1; GETLIST(A(I)); END; If it is a two dimensional array then the following program segment can be used: GETLIST(M,N); DO I = 1 TO M; DO J = 1 TO N; GET LIST(X(I,J)); END; END; This method can be generalized to a multidimensional array: Take the upperbounds of all the dimensions. Then set DO loops with the most frequentlyvarying dimension at the in-nermost position and the least frequentlyvarying dimension at the outermost position. There is another technique provided by the PL/I machine, called repetitivedata specification, which reads in an en-tire array in just one GET statement. This is shown below: GETLIST(N, {X(I) DO I = 1 TO N}) ; Because of the left to right order, the variable N will be acquired beforeexecution of the DO-loop, where it is used as the upper limiting value. If it is a two dimensional array, for exampleX(10, 4) the statement willbe as follows: GETLIST((X (I, J) DO J = 1 TO 4) DO 1 = 1 TO 10); The repetitive specification consists of the following: a)thedata item to be used during execution of the DO portion (e.g., X(I) , Y(I,J)); b)thecontrol information which determines the number of times the dataitem is to be used for reading/writing values of the elements. (e.g. DO 1 = 1 TO N BY 1); c)apair of parentheses that enclose the repetitive specification. Similarly, to write out (dispose of) array elements, the repetitive dataspecification can also be used e.g., DECLARE (A,B)(10) FLOAT DECIMAL(5); PUTLIST[{B(I), A(I) DO I=1 TO 10}] SKIP; The value ofB(1) is printed out first, followed by A(1) , and then a line is skipped. After testing the limiting con-dition, iteration continues and outputs B(2), A(2) and so on. e.g.,DCL (A(100,4), B (100)) FIXED BIT(8); PUT DATA( (B(J) , (A(J,K) DO K = 1 TO 4) DO J=1 TO 100)); The put statement produces an output stream as follows: B(1) =XXXA(1,1) =XXXA(1,2) =XXXA(1,3) =XXXA(1,4) =XXX B(2) =XXXA(2,1) =XXXA(2,2) =XXXA(2,3) =XXXA(2,4) =XXX \\textbullet\\textbullet\\textbullet\\textbullet\\textbullet \\textbullet\\textbullet\\textbullet\\textbullet\\textbullet \\textbullet\\textbullet\\textbullet\\textbullet\\textbullet To refer to an element of array the following is done: a) A subscripted reference, also termed a subscripted name, is used. b) The subscript list must contain as many subscripts as there are dimensionsdeclared for the array. c) A subscripted reference consists of the name of the array followedby a list of one or more subscripts enclosed in parentheses. d) The integer value resulting from a subscript evalu-ation must fall withinthe bounds declared by the correspond-ing boundary specification. To understand clearly the above rules of referring to an element of anarray, consider the example given below: DECLARE A(10,10) FIXED DECIMAL(10,2), B(-1:5,-5:0,10:98) The subscript references A(3,5) A(1,2\u00d75 - 2) B(2,- 3,40) B[- (- 6 + 3),0,90] areall well formed and valid. Elements of the array A are referred by the arrayname A. Since A is a two dimensional array, the subscript reference hastwo subscripts and the in-teger value of the subscript is within the boundsdeclared for the array. So is the case for a reference made to arrayB. Now observe the following: The subscript references A(1,2,3) A(5) A(12,- 3) arenot valid. In the first case,A(1,2,3), there are three subscripts, alluding toa three dimensional array. But ar-ray A is declared as 2 dimensional. The same goes for the second case, but here, the subscript reference has onlyone dimension instead of the 2 which are required. In the third case, thereare two subscripts and array A is also of two di-mensions. However, boththe dimensions of array A have a lower bound of 1 and a higher boundof 10. Hence, 12, the first subscript element is greater than the higherbound, and - 3, the second subscript element is less than the lower bound1. This is not permissible.", "ref_id": 4712, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Explain with illustrations how data are read in (acquired) , writtenout (disposed of) and referred to in array structures.", "options": ["Data are read in array structures by declaring the array, then using a GET statement or DO loop to read the values. Data are written out by using the PUT statement. Referring to an element of an array is done by using a subscripted reference.", "Referring to an element of an array is done by using a multidimensional array", "Data are read in array structures by using a PUT statement", "Data are written out by using a GET statement"], "answer": "A", "solution": "A matrix (i.e. a two dimensional array) is de-clared by the statement DCL X [9, 9] FIXEDDECIMAL(4); Now if a problem requires that the values of the main diagon-al of the matrixbe read in, there are two techniques for doing it.i) Use of a single getstatement of the form given below: GET LIST(X(1,1), X(2,2), X(3,3), X(4,4), X(5,5), X(6,6), X(7,7) , X(8,8) , X(9,9)) , or, ii) the iterative DO group illustrated below: DO I = 1 TO 9 BY 1; GET LIST X [I, I] ; END; The first method has the disadvantage that a long data specification is required. The second method is short and flexible. One of the ways to acquire data for one dimensionalarraysis as follows: GETLIST(N); DO I = 1 TO N BY 1; GETLIST(A(I)); END; If it is a two dimensional array then the following program segment can be used: GETLIST(M,N); DO I = 1 TO M; DO J = 1 TO N; GET LIST(X(I,J)); END; END; This method can be generalized to a multidimensional array: Take the upperbounds of all the dimensions. Then set DO loops with the most frequentlyvarying dimension at the in-nermost position and the least frequentlyvarying dimension at the outermost position. There is another technique provided by the PL/I machine, called repetitivedata specification, which reads in an en-tire array in just one GET statement. This is shown below: GETLIST(N, {X(I) DO I = 1 TO N}) ; Because of the left to right order, the variable N will be acquired beforeexecution of the DO-loop, where it is used as the upper limiting value. If it is a two dimensional array, for exampleX(10, 4) the statement willbe as follows: GETLIST((X (I, J) DO J = 1 TO 4) DO 1 = 1 TO 10); The repetitive specification consists of the following: a)thedata item to be used during execution of the DO portion (e.g., X(I) , Y(I,J)); b)thecontrol information which determines the number of times the dataitem is to be used for reading/writing values of the elements. (e.g. DO 1 = 1 TO N BY 1); c)apair of parentheses that enclose the repetitive specification. Similarly, to write out (dispose of) array elements, the repetitive dataspecification can also be used e.g., DECLARE (A,B)(10) FLOAT DECIMAL(5); PUTLIST[{B(I), A(I) DO I=1 TO 10}] SKIP; The value ofB(1) is printed out first, followed by A(1) , and then a line is skipped. After testing the limiting con-dition, iteration continues and outputs B(2), A(2) and so on. e.g.,DCL (A(100,4), B (100)) FIXED BIT(8); PUT DATA( (B(J) , (A(J,K) DO K = 1 TO 4) DO J=1 TO 100)); The put statement produces an output stream as follows: B(1) =XXXA(1,1) =XXXA(1,2) =XXXA(1,3) =XXXA(1,4) =XXX B(2) =XXXA(2,1) =XXXA(2,2) =XXXA(2,3) =XXXA(2,4) =XXX \\textbullet\\textbullet\\textbullet\\textbullet\\textbullet \\textbullet\\textbullet\\textbullet\\textbullet\\textbullet \\textbullet\\textbullet\\textbullet\\textbullet\\textbullet To refer to an element of array the following is done: a) A subscripted reference, also termed a subscripted name, is used. b) The subscript list must contain as many subscripts as there are dimensionsdeclared for the array. c) A subscripted reference consists of the name of the array followedby a list of one or more subscripts enclosed in parentheses. d) The integer value resulting from a subscript evalu-ation must fall withinthe bounds declared by the correspond-ing boundary specification. To understand clearly the above rules of referring to an element of anarray, consider the example given below: DECLARE A(10,10) FIXED DECIMAL(10,2), B(-1:5,-5:0,10:98) The subscript references A(3,5) A(1,2\u00d75 - 2) B(2,- 3,40) B[- (- 6 + 3),0,90] areall well formed and valid. Elements of the array A are referred by the arrayname A. Since A is a two dimensional array, the subscript reference hastwo subscripts and the in-teger value of the subscript is within the boundsdeclared for the array. So is the case for a reference made to arrayB. Now observe the following: The subscript references A(1,2,3) A(5) A(12,- 3) arenot valid. In the first case,A(1,2,3), there are three subscripts, alluding toa three dimensional array. But ar-ray A is declared as 2 dimensional. The same goes for the second case, but here, the subscript reference has onlyone dimension instead of the 2 which are required. In the third case, thereare two subscripts and array A is also of two di-mensions. However, boththe dimensions of array A have a lower bound of 1 and a higher boundof 10. Hence, 12, the first subscript element is greater than the higherbound, and - 3, the second subscript element is less than the lower bound1. This is not permissible."}, "question": "task_1"}}, {"data": {"text": "Question:\nGiven the function f(x,y,z) below, write f(x,y,z) as a sum of minterms. f (x,y,z) =xz+yz+ xyz\n\nOptions:\nA. m_1 + m_2 + m_3 + m_4\nB. m_6 + m_4 + m_2 + m_7\nC.             m_2 + m_4 + m_6 + m_8\nD. m_1 + m_3 + m_5 + m_7\n\nAnswer: B\n\nReference Solution:\nIf a switching function is given in Sum of Products form, it may be expanded to the canonical Sum of Products through repeated use of the Theorem below. THEOREM 1:ab+ab= a Therefore given the function f(x,y,z) =xz+yz+ xyz , f(x,y,z) = xyz+ xyz+ yz + xyz can be obtained, by using theorem 1, and sayingxz= xyz+ xyz. Using Theorem 1 a second time and making the equalityyz= xyz+xyz, the function f(x,y,z) becomes: f(x,y,z) = xyz+ xyz+ xyz+xyz+ xyz At this point a second theorem may be used to reduce the number of terms present; THEOREM 2: a + a = a In the final form of the function it can easily be seen that the first and the third terms are in the same form, xyz. Using Theorem 2 these terms can be reduced as follows; xyz+ xyz= xyz then the final form of the function is; f(x,y,z) = xyz+ xyz+xyz+ xyz. After the desired reduced form is obtained where each term has the same number of variables, a specialmintermcode is used to CODE the function.Mintermcode is basically giving a value of 1 for each true variable, and a value of 0 for each false variable. Taking this definition and applying it to the function gives; xyz+ xyz+xyz+ xyz 110100010111(mintermcode) In decimal arithmetic these terms represent the numbers 6,4,2, and 7. Therefore the desired Sum ofMintermsform is written as; f(x,y,z) = m_6 + m_4 + m_2 + m_7 or f(x,y,z) = \\summ (2,4,6,7)", "ref_id": 4713, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Given the function f(x,y,z) below, write f(x,y,z) as a sum of minterms. f (x,y,z) =xz+yz+ xyz", "options": ["m_1 + m_2 + m_3 + m_4", "m_6 + m_4 + m_2 + m_7", "m_2 + m_4 + m_6 + m_8", "m_1 + m_3 + m_5 + m_7"], "answer": "B", "solution": "If a switching function is given in Sum of Products form, it may be expanded to the canonical Sum of Products through repeated use of the Theorem below. THEOREM 1:ab+ab= a Therefore given the function f(x,y,z) =xz+yz+ xyz , f(x,y,z) = xyz+ xyz+ yz + xyz can be obtained, by using theorem 1, and sayingxz= xyz+ xyz. Using Theorem 1 a second time and making the equalityyz= xyz+xyz, the function f(x,y,z) becomes: f(x,y,z) = xyz+ xyz+ xyz+xyz+ xyz At this point a second theorem may be used to reduce the number of terms present; THEOREM 2: a + a = a In the final form of the function it can easily be seen that the first and the third terms are in the same form, xyz. Using Theorem 2 these terms can be reduced as follows; xyz+ xyz= xyz then the final form of the function is; f(x,y,z) = xyz+ xyz+xyz+ xyz. After the desired reduced form is obtained where each term has the same number of variables, a specialmintermcode is used to CODE the function.Mintermcode is basically giving a value of 1 for each true variable, and a value of 0 for each false variable. Taking this definition and applying it to the function gives; xyz+ xyz+xyz+ xyz 110100010111(mintermcode) In decimal arithmetic these terms represent the numbers 6,4,2, and 7. Therefore the desired Sum ofMintermsform is written as; f(x,y,z) = m_6 + m_4 + m_2 + m_7 or f(x,y,z) = \\summ (2,4,6,7)"}, "question": "task_1"}}, {"data": {"text": "Question:\nExplain the action of the following procedure which in-cludes asubroutine procedure within itself. VERIFY_TEST_VALUES: PROCEDURE; DCL LENGTH FIXEDDEC(3); CALL GET_AND_TEST_INPUT; \\textbullet \\textbullet \\textbullet \\textbullet \\textbullet CALL GET_AND_TEST_INPUT' \\textbullet \\textbullet \\textbullet \\textbullet \\textbullet GET_AND_TEST_INPUT:PROCEDURE; AGAIN:GETLIST(LENGTH); IF LENGTH = 0 THEN GOTO L; IF LENGTH<0 \\vert LENGTH>90 THEN DO; PUTLIST('ERROR', LENGTH);GOTOAGAIN; END; /\\textasteriskcentered END OF DO GROUP \\textasteriskcentered/ END GET_AND_TEST_INPUT; \\textbullet \\textbullet \\textbullet \\textbullet \\textbullet CALL GET_AND_TEST_INPUT; L:ENDVERIFY_TEST_VALUES;\n\nOptions:\nA. The subroutine procedure is called only once in the program\nB. The subroutine procedure is called from three different points in the program, checks if each length value is between 0 and 90, and returns control to the main program.\nC.             The subroutine procedure checks if each length value is between 0 and 100\nD. The subroutine procedure returns the length value to the main program\n\nAnswer: B\n\nReference Solution:\nFrom three different points in the program, the subroutine procedureis called. This is called a subroutine procedure because no re-sult value is produced. This is what differentiates a sub-routine procedure from a functionprocedure, which initiates an evaluation of a result to be later usedby the main pro-gram. Each time the subroutine is invoked in the above ex-ample, it acquiresa new value length from the data card. Then, the subroutine checksif each length value is between 0 and 90. If the value is <0 or >90 then the PUT LIST statement is executed, andthe control goes to the statementlabelled'AGAIN'. Thus, a new value forlength is obtained. If a value of zero is obtained for length, it is an indicationthat data is over and the program returns to the statement labelledFINISH in the calling program. But, if the value of length lies between0 and 90, then the program does not go to the statementlabelled FINISH, nor does it enter the DO group. Instead, the program control goes tothe next statement after the DO group, which happens to be the last statementof the subroutine procedure. From here, control is transferred backto the calling procedure, which con-tinues with the other steps of the program.", "ref_id": 4714, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Explain the action of the following procedure which in-cludes asubroutine procedure within itself. VERIFY_TEST_VALUES: PROCEDURE; DCL LENGTH FIXEDDEC(3); CALL GET_AND_TEST_INPUT; \\textbullet \\textbullet \\textbullet \\textbullet \\textbullet CALL GET_AND_TEST_INPUT' \\textbullet \\textbullet \\textbullet \\textbullet \\textbullet GET_AND_TEST_INPUT:PROCEDURE; AGAIN:GETLIST(LENGTH); IF LENGTH = 0 THEN GOTO L; IF LENGTH<0 \\vert LENGTH>90 THEN DO; PUTLIST('ERROR', LENGTH);GOTOAGAIN; END; /\\textasteriskcentered END OF DO GROUP \\textasteriskcentered/ END GET_AND_TEST_INPUT; \\textbullet \\textbullet \\textbullet \\textbullet \\textbullet CALL GET_AND_TEST_INPUT; L:ENDVERIFY_TEST_VALUES;", "options": ["The subroutine procedure is called only once in the program", "The subroutine procedure is called from three different points in the program, checks if each length value is between 0 and 90, and returns control to the main program.", "The subroutine procedure checks if each length value is between 0 and 100", "The subroutine procedure returns the length value to the main program"], "answer": "B", "solution": "From three different points in the program, the subroutine procedureis called. This is called a subroutine procedure because no re-sult value is produced. This is what differentiates a sub-routine procedure from a functionprocedure, which initiates an evaluation of a result to be later usedby the main pro-gram. Each time the subroutine is invoked in the above ex-ample, it acquiresa new value length from the data card. Then, the subroutine checksif each length value is between 0 and 90. If the value is <0 or >90 then the PUT LIST statement is executed, andthe control goes to the statementlabelled'AGAIN'. Thus, a new value forlength is obtained. If a value of zero is obtained for length, it is an indicationthat data is over and the program returns to the statement labelledFINISH in the calling program. But, if the value of length lies between0 and 90, then the program does not go to the statementlabelled FINISH, nor does it enter the DO group. Instead, the program control goes tothe next statement after the DO group, which happens to be the last statementof the subroutine procedure. From here, control is transferred backto the calling procedure, which con-tinues with the other steps of the program."}, "question": "task_1"}}, {"data": {"text": "Question:\nGive a brief history of the six generations of computers. What do you think the next generation has in store for us?\n\nOptions:\nA. The seventh generation will be symbolic computing systems.\nB. The seventh generation will be quantum computing systems.\nC.             The seventh generation will be molecular computing systems.\nD. The seventh generation will be integrated circuit systems.\n\nAnswer: C\n\nReference Solution:\nThe first generation, starting with the ENIAC machine that filled an entire room, is based on \"valve technology,\" where vacuum tubes were used as the basic electronic units to regulate the flow of electricity in much the same way as the flow of water in pipes. The memory was based on a primitive mercury delay line. ENIAC and UNIVAC I (Universal Automatic Computer) were the forerunners of this generation. The second generation was based on \"transistor\" technology. With transistors replacing the vacuum tubes, these computers were less expensive , more reliable, more compact, and more pow-erful. With this generation , we also begin to see the \"symbolic\" processing of letters, that is to say text, as well as numbers. The third generation was based on \"integrated circuits,\" also loosely referred to as \"chips\" that were theby productof space technology . This technology was introduced by the Depart-ment of Defense and the fledgling aerospace program. The fore-runners of this generation were IBM 360 and 370 mainframe com-puters, Honeywell 200 series mainframes, and Digital Equipment Corporation (DEC) PDP-8 and PDP-11 series. This generation of computers normally used ferrous magnetic core memories. The fourth generation was based on LSI (Large Scale Inte-gration) and VLSI (Very Large Scale Integration) technology. This technology used very small area to pack hundreds of tran-sistors and circuitry. This technology for processor (e.g. CPU: Central Processing Unit) design was coupled with solid-state semiconductor memories (generally using CMOS manufacturing tech-nology) to yield low cost, compact systems with impressive ex-ecution speeds and primary memory capacities. The fifth generation, a term coined by the Japanese, is not as well defined , except that it heavily depends upon \"symbolic computing\" where a computer is a symbol-processing engine rather than just a number- cruncher . It is characterized by heavy use of parallelism and knowledge- based system software technologies. The sixth generation, with the advent of \"neural networks\" and neurocomputing , will be computers that are capable of func-tioning very much like biological brains: Very good in practical tasks that require approximations such as scene analysis and cognition, speech synthesis, etc., but not toogoodat number crunching operations such as multiplying two 18-digit numbers in nanoseconds. We can venture to state the seventh generation as \"molecu-lar computing \" where the architecture of the computer will uti-lize a large number of molecules that are capable of self-organization and intelligent behavior . In other words, these comput-ers will be \"chemical\" in nature rather than \"electronic.\" It is too early to give any details regarding this generation ! So, a plausible answer to the second part of the question is that the sixth generation will be neural computing machines and the seventh molecular computing systems.", "ref_id": 4715, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Give a brief history of the six generations of computers. What do you think the next generation has in store for us?", "options": ["The seventh generation will be symbolic computing systems.", "The seventh generation will be quantum computing systems.", "The seventh generation will be molecular computing systems.", "The seventh generation will be integrated circuit systems."], "answer": "C", "solution": "The first generation, starting with the ENIAC machine that filled an entire room, is based on \"valve technology,\" where vacuum tubes were used as the basic electronic units to regulate the flow of electricity in much the same way as the flow of water in pipes. The memory was based on a primitive mercury delay line. ENIAC and UNIVAC I (Universal Automatic Computer) were the forerunners of this generation. The second generation was based on \"transistor\" technology. With transistors replacing the vacuum tubes, these computers were less expensive , more reliable, more compact, and more pow-erful. With this generation , we also begin to see the \"symbolic\" processing of letters, that is to say text, as well as numbers. The third generation was based on \"integrated circuits,\" also loosely referred to as \"chips\" that were theby productof space technology . This technology was introduced by the Depart-ment of Defense and the fledgling aerospace program. The fore-runners of this generation were IBM 360 and 370 mainframe com-puters, Honeywell 200 series mainframes, and Digital Equipment Corporation (DEC) PDP-8 and PDP-11 series. This generation of computers normally used ferrous magnetic core memories. The fourth generation was based on LSI (Large Scale Inte-gration) and VLSI (Very Large Scale Integration) technology. This technology used very small area to pack hundreds of tran-sistors and circuitry. This technology for processor (e.g. CPU: Central Processing Unit) design was coupled with solid-state semiconductor memories (generally using CMOS manufacturing tech-nology) to yield low cost, compact systems with impressive ex-ecution speeds and primary memory capacities. The fifth generation, a term coined by the Japanese, is not as well defined , except that it heavily depends upon \"symbolic computing\" where a computer is a symbol-processing engine rather than just a number- cruncher . It is characterized by heavy use of parallelism and knowledge- based system software technologies. The sixth generation, with the advent of \"neural networks\" and neurocomputing , will be computers that are capable of func-tioning very much like biological brains: Very good in practical tasks that require approximations such as scene analysis and cognition, speech synthesis, etc., but not toogoodat number crunching operations such as multiplying two 18-digit numbers in nanoseconds. We can venture to state the seventh generation as \"molecu-lar computing \" where the architecture of the computer will uti-lize a large number of molecules that are capable of self-organization and intelligent behavior . In other words, these comput-ers will be \"chemical\" in nature rather than \"electronic.\" It is too early to give any details regarding this generation ! So, a plausible answer to the second part of the question is that the sixth generation will be neural computing machines and the seventh molecular computing systems."}, "question": "task_1"}}, {"data": {"text": "Question:\nWrite a BASIC program which multiplies a polynomial of degree 2 by a polynomial of degree 1.\n\nOptions:\nA. A C++ program that calculates the product\nB. A Python program that multiplies the polynomials\nC.             An algorithm explaining the multiplication process\nD. The BASIC program provided in the solution\n\nAnswer: D\n\nReference Solution:\nIt is instructive to study a concrete example. Consider 3X^2 + 11X - 5 2X + 7 21X^2 + 77X - 35 6X^3 + 22X^2 - 10X 6X^3 + 43x^2 + 67X - 35 or simply 3 + 11 - 5 2 + 7 21 + 77 - 35 6 + 22 - 10 6 + 43 + 67 - 35 The program can be set up by putting 3, 11, and -5 in one computer list, and 2 and 7 in a second list, while leaving room for the product coefficients 6, 43, 67, and -35 in a third list. The columns are labeled as below 3210Col. no if zero subscript allowed 4321Col. no. with no zero subscript 311-5 2+7 21+ 77-35 6 + 22- 10 6 + 22+ 67-35 In general, multiplying a number in column I by a number in column J results in a productin column I + J - 1 (unless zero subscript or a zero column is allowed, in which case the product column is I + J). Thus, product totals can be accumulated with a statement of the form XXX LET P (I+J-1) = P(I+J-1) + F(I)\\textasteriskcenteredS(J) where the P list is initialized to 0. 8REM LINES 10 THRU 40 READ AND 9REM PRINT THE FIRST POLYNOMIAL 10FOR X = 3 TO 1 STEP - 1 20READ F[X] 30PRINT F[X]; 40NEXT X 50PRINT \"TIMES\"; 51REM LINES 60 THRU 90 READ AND 59REM PRINT THE SECOND POLYNOMIAL 60FOR Y = 2 TO 1 STEP - 1 70READ S[Y] 80PRINT S[Y]; 90NEXT Y 98REM 100 THRU 120 SET THE RESULT LIST 99REM TO ALL ZEROS 100FOR W = 1 TO 4 110LET P (W) = 0 120NEXT W 128REM LINES 130 THRU 170 DO THE 129REM ACTUAL MULTIPLYING 130FOR I = 1 TO 3 140FOR J = 1 TO 2 150LET P(I+J-1) = P(I+J-1) + F(I)\\textasteriskcenteredS(J) 160NEXT J 170NEXT I 180PRINT \"YIELDS\"; 188REM AND NOW THE 189REM 'ANSWER LIST' IS PAINTED 190FORZ = 4TO1STEP - 1 200PRINT P (Z); 210NEXTZ 218REM THE FIRST 3 NOS. REP. 3X\\uparrow2 + 11X - 5 219REM THE NEXT 2 NOS . REP. 2X + 7 220DATA 3,11, -5, 2, 7 230END", "ref_id": 4716, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Write a BASIC program which multiplies a polynomial of degree 2 by a polynomial of degree 1.", "options": ["A C++ program that calculates the product", "A Python program that multiplies the polynomials", "An algorithm explaining the multiplication process", "The BASIC program provided in the solution"], "answer": "D", "solution": "It is instructive to study a concrete example. Consider 3X^2 + 11X - 5 2X + 7 21X^2 + 77X - 35 6X^3 + 22X^2 - 10X 6X^3 + 43x^2 + 67X - 35 or simply 3 + 11 - 5 2 + 7 21 + 77 - 35 6 + 22 - 10 6 + 43 + 67 - 35 The program can be set up by putting 3, 11, and -5 in one computer list, and 2 and 7 in a second list, while leaving room for the product coefficients 6, 43, 67, and -35 in a third list. The columns are labeled as below 3210Col. no if zero subscript allowed 4321Col. no. with no zero subscript 311-5 2+7 21+ 77-35 6 + 22- 10 6 + 22+ 67-35 In general, multiplying a number in column I by a number in column J results in a productin column I + J - 1 (unless zero subscript or a zero column is allowed, in which case the product column is I + J). Thus, product totals can be accumulated with a statement of the form XXX LET P (I+J-1) = P(I+J-1) + F(I)\\textasteriskcenteredS(J) where the P list is initialized to 0. 8REM LINES 10 THRU 40 READ AND 9REM PRINT THE FIRST POLYNOMIAL 10FOR X = 3 TO 1 STEP - 1 20READ F[X] 30PRINT F[X]; 40NEXT X 50PRINT \"TIMES\"; 51REM LINES 60 THRU 90 READ AND 59REM PRINT THE SECOND POLYNOMIAL 60FOR Y = 2 TO 1 STEP - 1 70READ S[Y] 80PRINT S[Y]; 90NEXT Y 98REM 100 THRU 120 SET THE RESULT LIST 99REM TO ALL ZEROS 100FOR W = 1 TO 4 110LET P (W) = 0 120NEXT W 128REM LINES 130 THRU 170 DO THE 129REM ACTUAL MULTIPLYING 130FOR I = 1 TO 3 140FOR J = 1 TO 2 150LET P(I+J-1) = P(I+J-1) + F(I)\\textasteriskcenteredS(J) 160NEXT J 170NEXT I 180PRINT \"YIELDS\"; 188REM AND NOW THE 189REM 'ANSWER LIST' IS PAINTED 190FORZ = 4TO1STEP - 1 200PRINT P (Z); 210NEXTZ 218REM THE FIRST 3 NOS. REP. 3X\\uparrow2 + 11X - 5 219REM THE NEXT 2 NOS . REP. 2X + 7 220DATA 3,11, -5, 2, 7 230END"}, "question": "task_1"}}, {"data": {"text": "Question:\nWrite a routine that implements shell sorting. Assume there is an array of integers and size of array is known in the main program. The input parameters to the routine are a) array. b) size of array.\n\nOptions:\nA. Bubble sort algorithm\nB. Insertion sort algorithm\nC.             Selection sort algorithm\nD. Shell sorting algorithm\n\nAnswer: D\n\nReference Solution:\nThe shell sorting algorithm 1) Compares elements that are far apart and then compares adjacent elements. 2) It uses another: routine, values _ swaped ( ) where the values sent are interchanged. 3) The logic used is that number of elements in an array is divided by 2, then element {0] and element [no. of ele-ments/2] are compared. The difference between [no. of elements/2 - 0] is a constant for the first pass and is referred in the program as difference. shell _ sort (array, number _ of _ elements) int array [ ]; int number _ of _ elements; { int i; int difference = number _ of _ elements/2; int swap _ occurred; /\\textasteriskcenteredTRUE if a swap occurred \\textasteriskcentered/ do do { swap _ occurred =0; for (i = 0; i < number _ of _ elements - difference; i++) if (array [i] > array [i + difference]). { values _ swaped (&(array[i]), &(array [i + difference])); swap _ occurred = 1; } } while (swap _ occurred); while ((difference/=2) > 0); /\\textasteriskcenteredmeaning (difference = difference/2) >0 \\textasteriskcentered/ } values _ swaped (value1, value2) int \\textasteriskcenteredvalue1 = \\textasteriskcenteredvalue2; { int temp; /\\textasteriskcenteredstore temporary values \\textasteriskcentered/ temp = \\textasteriskcenteredvalue1; \\textasteriskcenteredvalue1 = \\textasteriskcenteredvalue2; \\textasteriskcenteredvalue2 = temp; } } C REFERENCE GUIDE C REFERENCE GUIDE Arithmetic Operators + addition. - subtraction. \\textasteriskcentered multiplication. / division. % modulus. Operators unique to C ++ increment. -- decrement. Assignment operators operator = eg. a\\textasteriskcentered = 5; a = a \\textasteriskcentered 5; a% = 5; a = a % 5; Bitwise Operators &bitwise AND. !bitwise OR. ^bitwise exclusive - or. <<shift left. >>shift right. \\simone's complement. Break Statement: The break statement is used within loops and the switch statement. Within A loop the break statement causes the execu-tion of the loop to cease and execution of the program to con-tinue at the statement that follows the loop. Format is break ; Global Variables: In C the use of global variables is done usingexternstatement. It is done as follows type variable _ name; /\\textasteriskcenteredoutside of main \\textasteriskcentered/ main ( ) { extern type variable _ name; /\\textasteriskcenteredextern tells the compiler that the \\textasteriskcentered/ /\\textasteriskcenteredvariable is a global one\\textasteriskcentered/ Relational Operators: <less than >greater than <=less than or equal to >=greater than or equal to Relational operators unique to C ==equal to !=not equal to Ternary Operator : ?:conditional operator. It is a conditional operator eg. conditional - expression: expression 1? expression 2: expression 3 Conditional expressions group right to left. They operate as follows a) If expression 1 (i.e. expression to be evaluated) is TRUE, expression 2 will be performed. If it is FALSE expression 3 will be performed. Logical AND Operator: logical - AND - expression expression 1 && expression 2 Logical OR Operator: logical-OR-expression expression 1 \\vert\\vert expression 2. Type Specifiers: type - Specifiers are char short int long unsigned float double stifuct -or-union specifier typedef name.", "ref_id": 4717, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Write a routine that implements shell sorting. Assume there is an array of integers and size of array is known in the main program. The input parameters to the routine are a) array. b) size of array.", "options": ["Bubble sort algorithm", "Insertion sort algorithm", "Selection sort algorithm", "Shell sorting algorithm"], "answer": "D", "solution": "The shell sorting algorithm 1) Compares elements that are far apart and then compares adjacent elements. 2) It uses another: routine, values _ swaped ( ) where the values sent are interchanged. 3) The logic used is that number of elements in an array is divided by 2, then element {0] and element [no. of ele-ments/2] are compared. The difference between [no. of elements/2 - 0] is a constant for the first pass and is referred in the program as difference. shell _ sort (array, number _ of _ elements) int array [ ]; int number _ of _ elements; { int i; int difference = number _ of _ elements/2; int swap _ occurred; /\\textasteriskcenteredTRUE if a swap occurred \\textasteriskcentered/ do do { swap _ occurred =0; for (i = 0; i < number _ of _ elements - difference; i++) if (array [i] > array [i + difference]). { values _ swaped (&(array[i]), &(array [i + difference])); swap _ occurred = 1; } } while (swap _ occurred); while ((difference/=2) > 0); /\\textasteriskcenteredmeaning (difference = difference/2) >0 \\textasteriskcentered/ } values _ swaped (value1, value2) int \\textasteriskcenteredvalue1 = \\textasteriskcenteredvalue2; { int temp; /\\textasteriskcenteredstore temporary values \\textasteriskcentered/ temp = \\textasteriskcenteredvalue1; \\textasteriskcenteredvalue1 = \\textasteriskcenteredvalue2; \\textasteriskcenteredvalue2 = temp; } } C REFERENCE GUIDE C REFERENCE GUIDE Arithmetic Operators + addition. - subtraction. \\textasteriskcentered multiplication. / division. % modulus. Operators unique to C ++ increment. -- decrement. Assignment operators operator = eg. a\\textasteriskcentered = 5; a = a \\textasteriskcentered 5; a% = 5; a = a % 5; Bitwise Operators &bitwise AND. !bitwise OR. ^bitwise exclusive - or. <<shift left. >>shift right. \\simone's complement. Break Statement: The break statement is used within loops and the switch statement. Within A loop the break statement causes the execu-tion of the loop to cease and execution of the program to con-tinue at the statement that follows the loop. Format is break ; Global Variables: In C the use of global variables is done usingexternstatement. It is done as follows type variable _ name; /\\textasteriskcenteredoutside of main \\textasteriskcentered/ main ( ) { extern type variable _ name; /\\textasteriskcenteredextern tells the compiler that the \\textasteriskcentered/ /\\textasteriskcenteredvariable is a global one\\textasteriskcentered/ Relational Operators: <less than >greater than <=less than or equal to >=greater than or equal to Relational operators unique to C ==equal to !=not equal to Ternary Operator : ?:conditional operator. It is a conditional operator eg. conditional - expression: expression 1? expression 2: expression 3 Conditional expressions group right to left. They operate as follows a) If expression 1 (i.e. expression to be evaluated) is TRUE, expression 2 will be performed. If it is FALSE expression 3 will be performed. Logical AND Operator: logical - AND - expression expression 1 && expression 2 Logical OR Operator: logical-OR-expression expression 1 \\vert\\vert expression 2. Type Specifiers: type - Specifiers are char short int long unsigned float double stifuct -or-union specifier typedef name."}, "question": "task_1"}}, {"data": {"text": "Question:\nWrite a program to find the prime numbers between 1 and 50.\n\nOptions:\nA. 1 3 5 7 9 11 13 15 17\nB. 2 3 5 7 11 13 17 19 23 29 31 37\nC.             2 3 5 7 11 15 17 19 23\nD. 2 4 6 8 10 12 14 16 18\n\nAnswer: B\n\nReference Solution:\nThe classical algorithm for enumerating prime numbers is the sieve of Eratosthenes. Suppose that the prime numbers less than 10 are to be found . The prime numbers less than 10 can be found by writing down the numbers from 2 to 10: 2345678910 Then the lowest number is to be removed claiming that it is prime. The multiples of 2 are also to be removed. After the first step, 2 is a prime, and the sieve contains odd numbers only. 3579. After the second step, 3 is a prime, and only 5 and 7 remain in the sieve. The process terminates when the sieve is empty. Declare CONST maximum = 100000 VAR Sieve: PACKED ARRAY [2. .maximum] ofboolean; Initially, each component of sieve is to be set to 'true\\textasteriskcentered indicating that alltbe numbers are present. As the numbers are removed, the corresponding components are set to 'false'. The program consists of two nested loops, one to find the lowest number still in the sieve, and the other to remove its multiples . The termination condition for the outer loop is that there are no numbers left in the sieve, and it can be expedited by maintaining a count of the numbers currently in the sieve. The program is given below. PROGRAM prime numbers (input, output); CONST first prime = 2; maximum = 100000; VAR sieve : PACKED ARRAY[first prime. .maximum] ofboolean; Left in, range, factor, multiple: 0..maximum; BEGIN read (range); FOR factor: = first primeTorange DO sieve [factor]:=true; Left in:=range - first prime +1; factor :=first prime - 1; REPEAT factor : =factor + 1; IF sieve [factor] THEN {factor isprime} BEGIN write1n (factor); multiple: = 1; WHILE factor \\textasteriskcentered multiple \\leq range DO BEGIN IF sieve [factor \\textasteriskcentered multiple] THEN {remove multiple} BEGIN sieve[factor \\textasteriskcentered multiple]:= false; leftin:= left in - 1 END; Multiple: = multiple + 1 END {while} END UNTIL left in = 0 END. {primenumbers} Input: 50 Output: 241 3 543 7 1147 13 17 19 23 29 31 37", "ref_id": 4718, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Write a program to find the prime numbers between 1 and 50.", "options": ["1 3 5 7 9 11 13 15 17", "2 3 5 7 11 13 17 19 23 29 31 37", "2 3 5 7 11 15 17 19 23", "2 4 6 8 10 12 14 16 18"], "answer": "B", "solution": "The classical algorithm for enumerating prime numbers is the sieve of Eratosthenes. Suppose that the prime numbers less than 10 are to be found . The prime numbers less than 10 can be found by writing down the numbers from 2 to 10: 2345678910 Then the lowest number is to be removed claiming that it is prime. The multiples of 2 are also to be removed. After the first step, 2 is a prime, and the sieve contains odd numbers only. 3579. After the second step, 3 is a prime, and only 5 and 7 remain in the sieve. The process terminates when the sieve is empty. Declare CONST maximum = 100000 VAR Sieve: PACKED ARRAY [2. .maximum] ofboolean; Initially, each component of sieve is to be set to 'true\\textasteriskcentered indicating that alltbe numbers are present. As the numbers are removed, the corresponding components are set to 'false'. The program consists of two nested loops, one to find the lowest number still in the sieve, and the other to remove its multiples . The termination condition for the outer loop is that there are no numbers left in the sieve, and it can be expedited by maintaining a count of the numbers currently in the sieve. The program is given below. PROGRAM prime numbers (input, output); CONST first prime = 2; maximum = 100000; VAR sieve : PACKED ARRAY[first prime. .maximum] ofboolean; Left in, range, factor, multiple: 0..maximum; BEGIN read (range); FOR factor: = first primeTorange DO sieve [factor]:=true; Left in:=range - first prime +1; factor :=first prime - 1; REPEAT factor : =factor + 1; IF sieve [factor] THEN {factor isprime} BEGIN write1n (factor); multiple: = 1; WHILE factor \\textasteriskcentered multiple \\leq range DO BEGIN IF sieve [factor \\textasteriskcentered multiple] THEN {remove multiple} BEGIN sieve[factor \\textasteriskcentered multiple]:= false; leftin:= left in - 1 END; Multiple: = multiple + 1 END {while} END UNTIL left in = 0 END. {primenumbers} Input: 50 Output: 241 3 543 7 1147 13 17 19 23 29 31 37"}, "question": "task_1"}}, {"data": {"text": "Question:\nWhat arePackedarrays? How do they differfrom conventional arrays?\n\nOptions:\nA. Packed arrays store values in memory in the most compact way possible, taking up less space but increasing processing time.\nB. Packed arrays take up more memory space but reduce processing time.\nC.             Packed arrays don't affect memory space or processing time.\nD. Packed arrays are the same as conventional arrays.\n\nAnswer: A\n\nReference Solution:\nThe reserved word Packed instructs the compiler to store the values of the array in memory in the most com-pact way. Usually, values of types char andbooleando not occupy the entire memory location provided for them. Since each element of an array of such types occupies a separate memory location, this results in a considerable waste of memory space. When PACKED ARRAY representation is used, the values are packed together as closely as possible, ignoring the borders between memory location. Therefore, a packed array takes up much less memory space than one that is not packed. On the other hand, the time required to access each individual element of an array is greatly increased , since the computer not only has to locate the memory location storing the desired value, it must also separate it from other values sharing the same memory location. Thus, what is gained in termsof memory space is lost in terms of in-creased processing time. This trade-off varies considerably from one machine to another, and even from one Pascal imple-mentation to another. So the decision whether or not to use packed arrays should take that into account, as well as the requirements of the specific problem under consideration.", "ref_id": 4719, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "What arePackedarrays? How do they differfrom conventional arrays?", "options": ["Packed arrays store values in memory in the most compact way possible, taking up less space but increasing processing time.", "Packed arrays take up more memory space but reduce processing time.", "Packed arrays don't affect memory space or processing time.", "Packed arrays are the same as conventional arrays."], "answer": "A", "solution": "The reserved word Packed instructs the compiler to store the values of the array in memory in the most com-pact way. Usually, values of types char andbooleando not occupy the entire memory location provided for them. Since each element of an array of such types occupies a separate memory location, this results in a considerable waste of memory space. When PACKED ARRAY representation is used, the values are packed together as closely as possible, ignoring the borders between memory location. Therefore, a packed array takes up much less memory space than one that is not packed. On the other hand, the time required to access each individual element of an array is greatly increased , since the computer not only has to locate the memory location storing the desired value, it must also separate it from other values sharing the same memory location. Thus, what is gained in termsof memory space is lost in terms of in-creased processing time. This trade-off varies considerably from one machine to another, and even from one Pascal imple-mentation to another. So the decision whether or not to use packed arrays should take that into account, as well as the requirements of the specific problem under consideration."}, "question": "task_1"}}, {"data": {"text": "Question:\nWrite a program in Basic to play the game ofNimwith a com-puter.\n\nOptions:\nA. A program in JavaScript\nB. A program in Python\nC.             The provided Basic program to play the game of Nim\nD. A program in C++\n\nAnswer: C\n\nReference Solution:\nThe traditional game ofNimis played in the following manner: There are four rows of stones arranged as shown: 0(1) 000(3) 00000(5) 0000000(7) Let A and B be the two players. The players play according to the 3 rules below: 1)On any given turn only objects from one row may be removed. There is no restriction on which row or on how many objects you remove. 2)You cannot skip a move or remove zero objects or remove more objectsthan there are in a row. 3)Opponents take turns removing objects until there are none left. The win option should be specified in the program. The program below allows the number, of piles to be variable, the pile sizesto be variable and also the win option to be either taking the last stone(s) or being left with the last stone(s). 10PRINT \"THE GAME OP NIM\" 20DIM A (100), B (100,10), D (2) 30PRINT \"ENTER WIN OPTION - 1 TO TAKE LAST, 402 TO AVOID LAST\"; 50INPUT W 60IF W = 1 THEN 80 70IF W <> 2 THEN 30 80PRINT \"ENTER NUMBER OF PILES\"; 90INPUT N 100IF N > 100 THEN 80 110IF N < 1 THEN 80 120IF N <> INT (N) THEN 80 130PRINT \"ENTER PILE SIZES\" 140FOR I = 1 TO N 150PRINTI; 160INPUT A (I) 170IF A (I) > 2000 THEN 150 180IF A (I) <>INT(A (I)) THEN 150 190NEXT I 200PRINT \"DO YOU WANT TO MOVE FIRST?\"; 210INPUT A$ 220IF A$ = \"YES\" GOTO 1000 230IF A$ = \"NO\" GOTO 250 235PRINT \"PLEASE, YES OR NO\"; 240GOTO 210 250IF W = 1 THEN 490 260LET C = 0 270FOR I = 1 TO N 280IF A (I) = 0 THEN 320 290LET C = C + 1 300IF C = 3 THEN 390 310LET D (C) = I 320NEXT I 330IF C = 2 THEN 470 340IF A (D(1)) > 1 THEN 370 350PRINT \"MACHINE LOSES\" 360GOTO 1190 370PRINT \"MACHINE WINS\" 380GOTO 1190 390LET C = 0 400FOR I = 1 TO N 410IF A (I) > 1 THEN 490 420IF A (I) = 0 THEN 440 430LET C = C + 1 440NEXT I 450IF C/2 <> INT (C/2) THEN 350 460GOTO 490 470IF A (D (1)) = 1 THEN 370 480IF A (D (2)) = 1 THEN 370 490FOR I = 1 TO N 500LET E = A (I) 510FOR J = 0 TO 10 520LET F = E/2 530LET B (I, J) = 2\\textasteriskcentered(F -INT(F) ) 540LET E = INT (F) 550NEXT J 560NEXT I 570FOR J = 10 TO 0 STEP - 1 580LET C = 0 590LET H = 0 600FOR I = 1 TO N 610IF B (I, J) = 0 THEN 660 620LET C = C + 1 630IF A (I) < = H THEN 660 640LET H = A (I) 650LET G = I 660NEXT I 670IF C/2 <> INT (C/2) THEN 740 680NEXT J 690LET E = INT (N\\textasteriskcenteredRND (1) + 1) 700IFA(E) = 0 THEN 690 710LET F = INT (A (E)\\textasteriskcenteredRND (1) + 1) 720LET A (E) = A (E) - F 730GOTO 930 740LET A (G) = 0 750FOR J = 0 TO 10 760LET B (G, J) = 0 770LET C = 0 780FOR I = 1 TO N 790IF B (I, J) = 0 THEN 810 800LET C = C + 1 810NEXT I 820LET A (G) = A (G) + 2\\textasteriskcentered(C/2 - INT (C/2) )\\textasteriskcentered2 \\uparrow J 830NEXT J 840IF W = l THEN 930 850LET C = 0 860FOR I = 1 TO N 870IF A (I) > 1 THEN 930 880IF A (I) = 0 THEN 900 890LET C = C + 1 900NEXT I 910IF C/2 <> INT (C/2) THEN 930 920LETA(G) = 1 - A (G) 930PRINT \"PILE SIZE\" 940FOR I = 1 TO N 950PRINTI; A (I) 960NEXT I 970IF W = 2 THEN 1000 980GOSUB 1120 990IF Z = 1 THEN 370 1000PRINT \"YOUR MOVE - PILE, NUMBER TO BE REMOVED\"; 1010INPUT X,Y 1020IF X > N THEN 1000 1030IF X < 1 THEN 1000 1040IF X <> INT (X) THEN 1000 1050IF Y > A (X) THEN 1000 1060IF Y < 1 THEN 1000 1070IF Y <> INT (Y) THEN 1000 1080LET A (X) = A (X) - Y 1090GOSUB 1120 1100IF Z = 1 THEN 350 1110GOTO 250 1120LET Z = 0 1130FOR I = 1 TO N 1140IF A (I) =0 THEN 1160 1150RETURN 1160NEXT I 1170LET Z = 1 1180RETURN 1190PRINT \"DO YOU WANT TO PLAY ANOTHER GAME\" 1200INPUT A$ 1210IF A$ = \"YES\" THEN 1240 1220IF A$ = \"NO\" THEN 1250 1230GOTO 1200 1240GOTO 30 1250END.", "ref_id": 4720, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Write a program in Basic to play the game ofNimwith a com-puter.", "options": ["A program in JavaScript", "A program in Python", "The provided Basic program to play the game of Nim", "A program in C++"], "answer": "C", "solution": "The traditional game ofNimis played in the following manner: There are four rows of stones arranged as shown: 0(1) 000(3) 00000(5) 0000000(7) Let A and B be the two players. The players play according to the 3 rules below: 1)On any given turn only objects from one row may be removed. There is no restriction on which row or on how many objects you remove. 2)You cannot skip a move or remove zero objects or remove more objectsthan there are in a row. 3)Opponents take turns removing objects until there are none left. The win option should be specified in the program. The program below allows the number, of piles to be variable, the pile sizesto be variable and also the win option to be either taking the last stone(s) or being left with the last stone(s). 10PRINT \"THE GAME OP NIM\" 20DIM A (100), B (100,10), D (2) 30PRINT \"ENTER WIN OPTION - 1 TO TAKE LAST, 402 TO AVOID LAST\"; 50INPUT W 60IF W = 1 THEN 80 70IF W <> 2 THEN 30 80PRINT \"ENTER NUMBER OF PILES\"; 90INPUT N 100IF N > 100 THEN 80 110IF N < 1 THEN 80 120IF N <> INT (N) THEN 80 130PRINT \"ENTER PILE SIZES\" 140FOR I = 1 TO N 150PRINTI; 160INPUT A (I) 170IF A (I) > 2000 THEN 150 180IF A (I) <>INT(A (I)) THEN 150 190NEXT I 200PRINT \"DO YOU WANT TO MOVE FIRST?\"; 210INPUT A$ 220IF A$ = \"YES\" GOTO 1000 230IF A$ = \"NO\" GOTO 250 235PRINT \"PLEASE, YES OR NO\"; 240GOTO 210 250IF W = 1 THEN 490 260LET C = 0 270FOR I = 1 TO N 280IF A (I) = 0 THEN 320 290LET C = C + 1 300IF C = 3 THEN 390 310LET D (C) = I 320NEXT I 330IF C = 2 THEN 470 340IF A (D(1)) > 1 THEN 370 350PRINT \"MACHINE LOSES\" 360GOTO 1190 370PRINT \"MACHINE WINS\" 380GOTO 1190 390LET C = 0 400FOR I = 1 TO N 410IF A (I) > 1 THEN 490 420IF A (I) = 0 THEN 440 430LET C = C + 1 440NEXT I 450IF C/2 <> INT (C/2) THEN 350 460GOTO 490 470IF A (D (1)) = 1 THEN 370 480IF A (D (2)) = 1 THEN 370 490FOR I = 1 TO N 500LET E = A (I) 510FOR J = 0 TO 10 520LET F = E/2 530LET B (I, J) = 2\\textasteriskcentered(F -INT(F) ) 540LET E = INT (F) 550NEXT J 560NEXT I 570FOR J = 10 TO 0 STEP - 1 580LET C = 0 590LET H = 0 600FOR I = 1 TO N 610IF B (I, J) = 0 THEN 660 620LET C = C + 1 630IF A (I) < = H THEN 660 640LET H = A (I) 650LET G = I 660NEXT I 670IF C/2 <> INT (C/2) THEN 740 680NEXT J 690LET E = INT (N\\textasteriskcenteredRND (1) + 1) 700IFA(E) = 0 THEN 690 710LET F = INT (A (E)\\textasteriskcenteredRND (1) + 1) 720LET A (E) = A (E) - F 730GOTO 930 740LET A (G) = 0 750FOR J = 0 TO 10 760LET B (G, J) = 0 770LET C = 0 780FOR I = 1 TO N 790IF B (I, J) = 0 THEN 810 800LET C = C + 1 810NEXT I 820LET A (G) = A (G) + 2\\textasteriskcentered(C/2 - INT (C/2) )\\textasteriskcentered2 \\uparrow J 830NEXT J 840IF W = l THEN 930 850LET C = 0 860FOR I = 1 TO N 870IF A (I) > 1 THEN 930 880IF A (I) = 0 THEN 900 890LET C = C + 1 900NEXT I 910IF C/2 <> INT (C/2) THEN 930 920LETA(G) = 1 - A (G) 930PRINT \"PILE SIZE\" 940FOR I = 1 TO N 950PRINTI; A (I) 960NEXT I 970IF W = 2 THEN 1000 980GOSUB 1120 990IF Z = 1 THEN 370 1000PRINT \"YOUR MOVE - PILE, NUMBER TO BE REMOVED\"; 1010INPUT X,Y 1020IF X > N THEN 1000 1030IF X < 1 THEN 1000 1040IF X <> INT (X) THEN 1000 1050IF Y > A (X) THEN 1000 1060IF Y < 1 THEN 1000 1070IF Y <> INT (Y) THEN 1000 1080LET A (X) = A (X) - Y 1090GOSUB 1120 1100IF Z = 1 THEN 350 1110GOTO 250 1120LET Z = 0 1130FOR I = 1 TO N 1140IF A (I) =0 THEN 1160 1150RETURN 1160NEXT I 1170LET Z = 1 1180RETURN 1190PRINT \"DO YOU WANT TO PLAY ANOTHER GAME\" 1200INPUT A$ 1210IF A$ = \"YES\" THEN 1240 1220IF A$ = \"NO\" THEN 1250 1230GOTO 1200 1240GOTO 30 1250END."}, "question": "task_1"}}, {"data": {"text": "Question:\nWrite two FORTRAN programs which will compute n!intwo differentways: (a) First according to the standard formula for a positive integern \\geq 1, n! =n(n-1) \\textbullet\\textbullet\\textbullet (3)(2)(1) (b)thenuseStirling'sapproximation formula n! \\cong (2\\pi)1^/2n^n^+(1/2) e^-n\n\nOptions:\nA. FACTST(N-1) and FACTST(N)\nB. FACT(N) and FACTST(N)\nC.             FACT(N) and FACT(N+1)\nD. FACT(N^2) and FACTST(N^2)\n\nAnswer: B\n\nReference Solution:\nWe will formulate the answers as two function routines which will be usedin later work. Denote these two functions byFACT(N) and FACTST(N). Then by applying the above formulas directly we get the programsbelow: INTEGER FUNCTIONFACT(N) IPROD = 1 IF (N.LE.1) GO TO 200 DO 100 I = 2,N IPROD = IPR0D\\textasteriskcenteredI 100CONTINUE FACT = IPROD GO TO 300 200FACT = 1 300RETURN END FUNCTIONFACTST(N) Z1 =EXP(-FLOAT(N)) Z2 = (FLCAT(N))\\textasteriskcentered\\textasteriskcentered(FLOAT(N) + 0.5) CFLOAT CONVERTS INTEGERS TO REALS Z3 = SQRT (2\\textasteriskcentered3.14159) FACTST = Z1\\textasteriskcenteredZ2\\textasteriskcenteredZ3 RETURN END", "ref_id": 4721, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Write two FORTRAN programs which will compute n!intwo differentways: (a) First according to the standard formula for a positive integern \\geq 1, n! =n(n-1) \\textbullet\\textbullet\\textbullet (3)(2)(1) (b)thenuseStirling'sapproximation formula n! \\cong (2\\pi)1^/2n^n^+(1/2) e^-n", "options": ["FACTST(N-1) and FACTST(N)", "FACT(N) and FACTST(N)", "FACT(N) and FACT(N+1)", "FACT(N^2) and FACTST(N^2)"], "answer": "B", "solution": "We will formulate the answers as two function routines which will be usedin later work. Denote these two functions byFACT(N) and FACTST(N). Then by applying the above formulas directly we get the programsbelow: INTEGER FUNCTIONFACT(N) IPROD = 1 IF (N.LE.1) GO TO 200 DO 100 I = 2,N IPROD = IPR0D\\textasteriskcenteredI 100CONTINUE FACT = IPROD GO TO 300 200FACT = 1 300RETURN END FUNCTIONFACTST(N) Z1 =EXP(-FLOAT(N)) Z2 = (FLCAT(N))\\textasteriskcentered\\textasteriskcentered(FLOAT(N) + 0.5) CFLOAT CONVERTS INTEGERS TO REALS Z3 = SQRT (2\\textasteriskcentered3.14159) FACTST = Z1\\textasteriskcenteredZ2\\textasteriskcenteredZ3 RETURN END"}, "question": "task_1"}}, {"data": {"text": "Question:\nDesign a program that can guess any integer from 100 to 999999999 by asking questions of the user about the sums of certain digits. Use BASIC.\n\nOptions:\nA. 728999\nB. 817999\nC.             718998\nD. 718999\n\nAnswer: D\n\nReference Solution:\nLet us choose 718999 as our number to be \"guessed\" . The algorithm we shall use requires several pieces of information . First, you must type in the number of digits, which in this case is 6. Then you must type in the sums of adjacent digits starting from the left, until you reach the last digit. Finally, the sum of the second and the last digits from the left are needed if the number is even; the sum of the first and last digits, if the number is odd. At this point, the array T has stored the following quantities: T (0) = 8T (3) =18 T (1) = 9T (4) = 18 T (2) = 17T (5) = 16 Now we hit the loop in which S is computed. Let us write down these steps as they will be executed: S = 0 + (9 \\textasteriskcentered 1) = 9 S = 9 + (17 \\textasteriskcentered (-1)) = -8 S = -8 + (18 \\textasteriskcentered 1) = 10 S = 10 + (-18) = -8 S = -8 + 10 = 2 S is then divided by 2 and stored in T(6). The final loop calculates each digit, multiplies by the appropriate factor of 10, and adds the totals to give the answer. 5 DIM T(15) 7 PRINT 9 PRINT \"WRITE ANY NUMBER FROM 3 TO 9 DIGITS ON A PIECE OF PAPER\" 10 PRINT \"WHEN READY, TYPE A ZERO AND RETURN\" 11 INPUT W 12 IF W < > 0 THEN 65 13 LET S = 0 14 LET E = 0 15 LET H = -1 16 MATT = ZER 17 PRINT \"TYPE IN THE NUMBER OF DIGITS IN YOUR NUMBER\" 18 PRINT 19 INPUT N 20 LET G = N/2 21 IF G <> INT(N/2) THEN 23 22 LET E = 1 23 FOR J = 0 TO N - 2 24 LET K = J + 1 25 PRINT 26 PRINT \"WHAT IS SUM OF DIGIT\" K \"AND DIGIT\" K + 1 \"?\" 27 PRINT 28 INPUT T(J) 29 NEXT J 30 PRINT \"WHAT IS SUM OF DIGIT\" E + 1 \"AND LAST DIGIT?\" 31 PRINT 32 INPUT T(K) 36 FOR J = E TO N - 1 38 LET H = -1 \\textasteriskcentered H 40 LET S = S + T(J) \\textasteriskcentered H 41 NEXT J 42 LET S = S/2 43 LET T(K + 1) = S 44 LET G = 1 45 LET S = 0 46 FOR J = 0 TO N - 1 50 LET L = N - J - 1 52 LET T(L) = T(L) - T(L + 1) 53 LET S = S + T(L) - T(L + 1) 54 LET G = 10 \\textasteriskcentered G 56 NEXT J 58 PRINT 60 PRINT \"I BET YOUR NUMBER IS\" S 62 GO TO 7 65 END", "ref_id": 4722, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Design a program that can guess any integer from 100 to 999999999 by asking questions of the user about the sums of certain digits. Use BASIC.", "options": ["728999", "817999", "718998", "718999"], "answer": "D", "solution": "Let us choose 718999 as our number to be \"guessed\" . The algorithm we shall use requires several pieces of information . First, you must type in the number of digits, which in this case is 6. Then you must type in the sums of adjacent digits starting from the left, until you reach the last digit. Finally, the sum of the second and the last digits from the left are needed if the number is even; the sum of the first and last digits, if the number is odd. At this point, the array T has stored the following quantities: T (0) = 8T (3) =18 T (1) = 9T (4) = 18 T (2) = 17T (5) = 16 Now we hit the loop in which S is computed. Let us write down these steps as they will be executed: S = 0 + (9 \\textasteriskcentered 1) = 9 S = 9 + (17 \\textasteriskcentered (-1)) = -8 S = -8 + (18 \\textasteriskcentered 1) = 10 S = 10 + (-18) = -8 S = -8 + 10 = 2 S is then divided by 2 and stored in T(6). The final loop calculates each digit, multiplies by the appropriate factor of 10, and adds the totals to give the answer. 5 DIM T(15) 7 PRINT 9 PRINT \"WRITE ANY NUMBER FROM 3 TO 9 DIGITS ON A PIECE OF PAPER\" 10 PRINT \"WHEN READY, TYPE A ZERO AND RETURN\" 11 INPUT W 12 IF W < > 0 THEN 65 13 LET S = 0 14 LET E = 0 15 LET H = -1 16 MATT = ZER 17 PRINT \"TYPE IN THE NUMBER OF DIGITS IN YOUR NUMBER\" 18 PRINT 19 INPUT N 20 LET G = N/2 21 IF G <> INT(N/2) THEN 23 22 LET E = 1 23 FOR J = 0 TO N - 2 24 LET K = J + 1 25 PRINT 26 PRINT \"WHAT IS SUM OF DIGIT\" K \"AND DIGIT\" K + 1 \"?\" 27 PRINT 28 INPUT T(J) 29 NEXT J 30 PRINT \"WHAT IS SUM OF DIGIT\" E + 1 \"AND LAST DIGIT?\" 31 PRINT 32 INPUT T(K) 36 FOR J = E TO N - 1 38 LET H = -1 \\textasteriskcentered H 40 LET S = S + T(J) \\textasteriskcentered H 41 NEXT J 42 LET S = S/2 43 LET T(K + 1) = S 44 LET G = 1 45 LET S = 0 46 FOR J = 0 TO N - 1 50 LET L = N - J - 1 52 LET T(L) = T(L) - T(L + 1) 53 LET S = S + T(L) - T(L + 1) 54 LET G = 10 \\textasteriskcentered G 56 NEXT J 58 PRINT 60 PRINT \"I BET YOUR NUMBER IS\" S 62 GO TO 7 65 END"}, "question": "task_1"}}, {"data": {"text": "Question:\nWrite a FORTRAN program to evaluate the polynomial expression a1x^n-1 + a2x^n-2 + ... + a_n forgiven values of n, a1, a2,...,a_n using various values of x whichare read in. Let the program terminate when a zero valueof x is read in.\n\nOptions:\nA. Horner's method\nB. Secant method\nC.             Bisection method\nD. Newton's method\n\nAnswer: A\n\nReference Solution:\nThe most efficient polynomial evaluation procedure is based onthe nesting (...((a1x+ a2)x + a3)x + ... + a_n-1)x + a_n . We assume n \\leq 25. The data deck consists of a value for n followed by the ncoefficientsa_ion one or more data cards. These are fol-lowed by successivedata cards, each with a value for x; the final card contains the zerovalue. This nesting procedure is known as Horner's method for evaluating poly-nomials. We present the program segment below. CPOLYNOMIAL EVALUATION DIMENSIONA(25) READ, N,(A(J), J = 1,N) 16READ, X IF (X.EQ.O.) STOP POLY =A(1) DO 12 I = 2,N 12POLY = PGLY\\textasteriskcenteredX +A(1) GO TO 16 STOP END", "ref_id": 4723, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Write a FORTRAN program to evaluate the polynomial expression a1x^n-1 + a2x^n-2 + ... + a_n forgiven values of n, a1, a2,...,a_n using various values of x whichare read in. Let the program terminate when a zero valueof x is read in.", "options": ["Horner's method", "Secant method", "Bisection method", "Newton's method"], "answer": "A", "solution": "The most efficient polynomial evaluation procedure is based onthe nesting (...((a1x+ a2)x + a3)x + ... + a_n-1)x + a_n . We assume n \\leq 25. The data deck consists of a value for n followed by the ncoefficientsa_ion one or more data cards. These are fol-lowed by successivedata cards, each with a value for x; the final card contains the zerovalue. This nesting procedure is known as Horner's method for evaluating poly-nomials. We present the program segment below. CPOLYNOMIAL EVALUATION DIMENSIONA(25) READ, N,(A(J), J = 1,N) 16READ, X IF (X.EQ.O.) STOP POLY =A(1) DO 12 I = 2,N 12POLY = PGLY\\textasteriskcenteredX +A(1) GO TO 16 STOP END"}, "question": "task_1"}}, {"data": {"text": "Question:\nConsider the following variant ofNim. A pile of N objects is given. Two players take turns removing 1, 2 or 3 objects fromthe pile. The person who has to take the last object, loses. Write a Basic program which enables you to play this gamewith a computer.\n\nOptions:\nA. Leave the computer with 1 + 4N objects before every move\nB. Leave the computer with 2N objects before every move\nC.             Leave the computer with 3N objects before every move\nD. Leave the computer with N objects before every move\n\nAnswer: A\n\nReference Solution:\nLet us consider 2 players: you and the computer. The computer losesif it takes the last object. The question now is: How many objects mustyou leave to the computer at its penultimate move to ensure your win? The answer is:1 + the maximum number of objects always possible toremove in one move by each you and the computer. This number is 4, becauseif the computer removes the minimum possible number of objects (i.e., 1), and you - the maximum (i.e., 3) - that will give you the desired number. So, by leaving the compu-ter with 5 objects at its penultimate move, you ensure your win (providing you do not make a mistake). In fact, ifyou leave the computer with 1 + 4N (where N = 0,1,2,3...) objects before everymove, you guarantee yourself a win by removing (4 - A) objects, where\"A\" is the number of objects removed by the computer. Using this strategyand providing that you move first, you are guaranteed to win everytime, except when there are 4N objects in a pile. In that case, by usingthe same strategy, the computer can beat you. 10PRINT \"31 OBJECTS GAME\" 20PRINT \"LET'S FLIP A COIN TO SEE WHO GOES FIRST.\" 25PRINT \"IF IT COMES UP HEADS, I WIN THE TOSS.\" 30N = 31 40Q = INT (2\\textasteriskcenteredRND (5)) 50IF Q = 1 THEN 80 60PRINT \"TAILS! YOU GO FIRST\" 70GOTO 140 80PRINT \"HEADS! I GO FIRST\" 90PRINT \"I TAKE TWO OBJECTS\" 100N = N - 2 110PRINT \"THE NUMBER OF OBJECTS IS NOW\" N 120PRINT \"YOUR TURN. YOU MAY TAKE 1, 2 OR 1303 OBJECTS.\" 140PRINT \"HOW MANY DO YOU WISH TO REMOVE?\", 150INPUT K 160IF K > 3 THEN 360 170IF K < = 0 THEN 360 180N = N - K 190PRINT \"THERE ARE NOW\" ;N; \"OBJECTS REMAINING.\" 200IF N = 4 THEN 260 210IF N = 3 THEN 280 220IF N = 2 THEN 300 230IF N < = 1 THEN 400 240Z = 4 - K 250GOTO 320 260Z = 3 270GOTO 320 280Z = 2 290GOTO 320 300Z = 1 320PRINT \"MY TURN. I REMOVE\" Z \"OBJECTS\" 330N = N - Z 340IF N < = 1 THEN 380 350GOTO 110 360PRINT \"IMPOSSIBLE. HOW MANY; 1, 2 OR 3\" 370GOTO 150 380PRINT \"YOU LOST\" 390GOTO 410 400PRINT \"YOU WERE LUCKY, YOU WON\" 410STOP 420END", "ref_id": 4724, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Consider the following variant ofNim. A pile of N objects is given. Two players take turns removing 1, 2 or 3 objects fromthe pile. The person who has to take the last object, loses. Write a Basic program which enables you to play this gamewith a computer.", "options": ["Leave the computer with 1 + 4N objects before every move", "Leave the computer with 2N objects before every move", "Leave the computer with 3N objects before every move", "Leave the computer with N objects before every move"], "answer": "A", "solution": "Let us consider 2 players: you and the computer. The computer losesif it takes the last object. The question now is: How many objects mustyou leave to the computer at its penultimate move to ensure your win? The answer is:1 + the maximum number of objects always possible toremove in one move by each you and the computer. This number is 4, becauseif the computer removes the minimum possible number of objects (i.e., 1), and you - the maximum (i.e., 3) - that will give you the desired number. So, by leaving the compu-ter with 5 objects at its penultimate move, you ensure your win (providing you do not make a mistake). In fact, ifyou leave the computer with 1 + 4N (where N = 0,1,2,3...) objects before everymove, you guarantee yourself a win by removing (4 - A) objects, where\"A\" is the number of objects removed by the computer. Using this strategyand providing that you move first, you are guaranteed to win everytime, except when there are 4N objects in a pile. In that case, by usingthe same strategy, the computer can beat you. 10PRINT \"31 OBJECTS GAME\" 20PRINT \"LET'S FLIP A COIN TO SEE WHO GOES FIRST.\" 25PRINT \"IF IT COMES UP HEADS, I WIN THE TOSS.\" 30N = 31 40Q = INT (2\\textasteriskcenteredRND (5)) 50IF Q = 1 THEN 80 60PRINT \"TAILS! YOU GO FIRST\" 70GOTO 140 80PRINT \"HEADS! I GO FIRST\" 90PRINT \"I TAKE TWO OBJECTS\" 100N = N - 2 110PRINT \"THE NUMBER OF OBJECTS IS NOW\" N 120PRINT \"YOUR TURN. YOU MAY TAKE 1, 2 OR 1303 OBJECTS.\" 140PRINT \"HOW MANY DO YOU WISH TO REMOVE?\", 150INPUT K 160IF K > 3 THEN 360 170IF K < = 0 THEN 360 180N = N - K 190PRINT \"THERE ARE NOW\" ;N; \"OBJECTS REMAINING.\" 200IF N = 4 THEN 260 210IF N = 3 THEN 280 220IF N = 2 THEN 300 230IF N < = 1 THEN 400 240Z = 4 - K 250GOTO 320 260Z = 3 270GOTO 320 280Z = 2 290GOTO 320 300Z = 1 320PRINT \"MY TURN. I REMOVE\" Z \"OBJECTS\" 330N = N - Z 340IF N < = 1 THEN 380 350GOTO 110 360PRINT \"IMPOSSIBLE. HOW MANY; 1, 2 OR 3\" 370GOTO 150 380PRINT \"YOU LOST\" 390GOTO 410 400PRINT \"YOU WERE LUCKY, YOU WON\" 410STOP 420END"}, "question": "task_1"}}, {"data": {"text": "Question:\nWhat are nested records? How is the WITH statement used with them? Illustrate by designing the data structure for the following problem: A school wishes to send to each of its 1,000 students the end-of-semester report, showing the courses taken and the grades received. Assume each student takes 4 courses, the name of the course is at most 80characterlong, and the grades are integers between 0 and 100. Each re-port must also include student's full name, address and the date of first attendance. Show how the information can be accessed in the program.\n\nOptions:\nA. Nested Records are arrays within arrays.\nB. Nested Records are Records, whose fields are other records. The with statement is used instead of writing the field designators all the time.\nC.             The with statement is used to declare new records.\nD. Nested Records are simple data structures with no sub-fields.\n\nAnswer: B\n\nReference Solution:\nNested Records are Records, whose fields are other records. Such records are needed to design complex data structures, such as for this problem . We know that the record must contain information onstudent's name , address, starting date, and grades. These are obvious choices for the fields of the record. Each of these fields must also contain sub-fields. Thus, under name, we must specify first, middle, and last name. The ADDRESS field must contain num-ber and street, city, state and zip code. Starting date must include the date, which is an integer in the range of 1 to 31, the month and the year. The GRADEREPORT FIELD must con-tain the description of 4 courses and the grade associated with each. So we would need an array of 4 records - one for each course. Then the record might look like this: TYPE STUDENTREC = RECORD NAME = RECORD FIRST, Middle, Last: packed array [1. .15] of char; END; ADDRESS = RECORD Number: integer; Street, City, State: packedarray[1..20] of char; Zip: integer END; STARTDATE = RECORD DATE: 1..31; month : (jan,feb, mar,apr, may,jun,jul,aug, sep ,oct,nov,dec); year : integer END; GRADEREPORT:ARRAY[1..4] of RECORD COURSENAME = packed array [1..80] of char; GRADE: 1..100 END END; Since there are 1,000 such records, declare VAR ALLRECORDS : ARRAY[1..1000] of STUDENTREC. Here's how to initialize the complete record of, say, 66th student: With ALLRECORDS [66] DO BEGIN NAME.FIRST:='JOHN'; NAME.LAST: ='DOE'; NAME.MIDDLE: ='PETER'; With ADDRESS DO BEGIN NUMBER: = 10; STREET: = 1PUDDLE LANE'; CITY: = 'New York'; STATE: = 'New York'; ZIP: = 10010; END Start date. DATE: = 1; Start date.month:=Jan; Start date.year:=1981; GRADEREPORT[1]. COURSENAME: = 'MATH 101'; GRADEREPORT[ 1].GRADE: = 85; \\bullet \\bullet etc . END; The with statement is used instead of writing the field designators all the time . Thus, without the first WITH statement, we would have to write ALLRECORDS [66]. foreach item.", "ref_id": 4725, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "What are nested records? How is the WITH statement used with them? Illustrate by designing the data structure for the following problem: A school wishes to send to each of its 1,000 students the end-of-semester report, showing the courses taken and the grades received. Assume each student takes 4 courses, the name of the course is at most 80characterlong, and the grades are integers between 0 and 100. Each re-port must also include student's full name, address and the date of first attendance. Show how the information can be accessed in the program.", "options": ["Nested Records are arrays within arrays.", "Nested Records are Records, whose fields are other records. The with statement is used instead of writing the field designators all the time.", "The with statement is used to declare new records.", "Nested Records are simple data structures with no sub-fields."], "answer": "B", "solution": "Nested Records are Records, whose fields are other records. Such records are needed to design complex data structures, such as for this problem . We know that the record must contain information onstudent's name , address, starting date, and grades. These are obvious choices for the fields of the record. Each of these fields must also contain sub-fields. Thus, under name, we must specify first, middle, and last name. The ADDRESS field must contain num-ber and street, city, state and zip code. Starting date must include the date, which is an integer in the range of 1 to 31, the month and the year. The GRADEREPORT FIELD must con-tain the description of 4 courses and the grade associated with each. So we would need an array of 4 records - one for each course. Then the record might look like this: TYPE STUDENTREC = RECORD NAME = RECORD FIRST, Middle, Last: packed array [1. .15] of char; END; ADDRESS = RECORD Number: integer; Street, City, State: packedarray[1..20] of char; Zip: integer END; STARTDATE = RECORD DATE: 1..31; month : (jan,feb, mar,apr, may,jun,jul,aug, sep ,oct,nov,dec); year : integer END; GRADEREPORT:ARRAY[1..4] of RECORD COURSENAME = packed array [1..80] of char; GRADE: 1..100 END END; Since there are 1,000 such records, declare VAR ALLRECORDS : ARRAY[1..1000] of STUDENTREC. Here's how to initialize the complete record of, say, 66th student: With ALLRECORDS [66] DO BEGIN NAME.FIRST:='JOHN'; NAME.LAST: ='DOE'; NAME.MIDDLE: ='PETER'; With ADDRESS DO BEGIN NUMBER: = 10; STREET: = 1PUDDLE LANE'; CITY: = 'New York'; STATE: = 'New York'; ZIP: = 10010; END Start date. DATE: = 1; Start date.month:=Jan; Start date.year:=1981; GRADEREPORT[1]. COURSENAME: = 'MATH 101'; GRADEREPORT[ 1].GRADE: = 85; \\bullet \\bullet etc . END; The with statement is used instead of writing the field designators all the time . Thus, without the first WITH statement, we would have to write ALLRECORDS [66]. foreach item."}, "question": "task_1"}}, {"data": {"text": "Question:\nName and briefly describe the commonly used input and output devices.\n\nOptions:\nA. Common input and output devices include projectors, scanners, and joysticks.\nB. Common input and output devices include console monitors, terminals, tape units, disk units, diskettes, and printers.\nC.             Common input and output devices include webcams, graphic tablets, and game controllers.\nD. Common input and output devices include speakers, microphones, and touch screens.\n\nAnswer: B\n\nReference Solution:\nConsole Monitors: In the early days, teletype consoles that use 132-column wide paper were used as the primary interface device between the operator and the computer. It looked very much like the 132- column wide paper printers that are not used as much these days, but it differed from the hardcopy line printer (LP) since it was capable of both input and output. Both input and output was one line at a time. Consoles were primarily used for booting up and maintenance of the system, and for important operating system messages. Nowadays, the CRT monitors that are directly connected to the computer system are used for the same purpose. The monitors that look like the small-screen TV along with keyboards that attach to them are widely used in PCs. These monitors are ca-pable ofdotmappedgraphics where the screen contains small pixels (dots) with dimensions that usually range from 640-by-400 low resolution to 1280-by-900 high resolution. Otherwise, the screen is capable of 80-by-25 character display in line (non--graphics) mode. In addition, the monitors may have either mono-chrome or colored screens. The number and shades of colors de-pend upon the specific make and model. Terminals : Perhaps the most frequently used input-output device is the CRT terminals with a keyboard and a screen. Strictly speaking, the keyboard is used for input and the video screen is used for output. The keyboards conform to basic standards such as ASCII, ANSI, and PC, but are often specialized for the conve-nient user interface. The screen may be used in character or graphics mode. In character mode, it can display characters such as ASCII set on 24 rows (lines) and 80 columns (characters per line). In some cases, there may be 25th row (line) to display function keys on the screen (so called soft function keys used in word processing systems) . There may also be 132-column mode, where the characters are smaller and hard to read. This is re-ally a remnant of the old days when 132-column wide papers were used to print out the reports. Tape Units : Although not used as frequently, except for backup of large amounts of data, the magnetic tapes are supported by tape units (drives) that have two reels feeding each other. The reels contain tapes with densities ranging from 800 bpi (bits per inch) to 6250 bpi. The access rate (e.g. how fast the tape is read or written) depends upon the manufacture of the drive, except that the access is almost always sequential. This means that it is not possible to access records (80 or more bytes data) directly. Disk Units : Also referred to as secondary storage (as opposed to the primary memory or RAM), disks are used for both input and output. Disks allow direct (or random) access to any block of data. A block of data is generally 512 to 1024 bytes and physi-cally correspond to a disk sector that can directly by homed in by the disk head. The more precise access to data within a block is done by first reading the entire block into the primary memory. The disks have capacities that depend upon the type of computer (e.g. mainframe, mini, PC, etc.) and generally range from 10 megabytes to about half gigabytes. The personal comput-ers have non- removable hard disks referred to as HDU (Hard Disk Unit) . The capacities are, as of the 1990s, anywhere from 10 to 80 megabytes. The optical disks are usually read-only (e.g. allow storage only once), but have capacities ranging from half gigabytes to four gigabytes. Diskettes : As its name implies, a diskette is a small magnetic disk. These are also called floppy disks or simply floppies. The most common sizes are either 4.25-in. by 4.25 in. standard or 3.50-in. by 3.50-in mini diskettes. A high-density standard diskette can store up to 1.2 megabytes and requires an appropri-ate diskette drive (floppy unit) for processing. A double-den-sity standard diskette has 360-kilobyte capacity. The minidiskettes have capacities of 720 kilobytes and 1.44 mega-bytes. Printers : Although the so called line printers (LPs) that print on 132- column wide paper still exist and are used in some cases with mainframe andsuperminisystems, most printers are much more compact and print on standard (8.5-by-ll inch) paper. The number of characters per line is determined by the font size 10 (10 characters per inch), normally 80 characters per line is printed. The printers are attached to the computer through printer ports (e.g. communication interface for transferring bits of information). The ports are of 36-pinCentronixtype for paral-lel interface and of 25-pin RS-232 type for serial interfaces. The printers may be of letter-quality or dot-matrix type. The former normally uses daisywheel character fonts and serial- impact upon ribbons much like the typewriters. There is less flexibility to define characters and fonts, but the quality is letter-quality. The dot-matrix printers define characters on a matrix of size 5-by-7 (coarse) or 9-by-12 (fine). These are less expensive printers based on older technology and imprint the pattern through ribbon (reels or cartridge). The ink-jet print-ers use special inks in liquid or solid forms ejected through a matrix with higher resolution (12-by- 15, 18-by-36, or better). Using newer technology, ink-jet printers produce almost letter quality prints, and can also print in colors. The dot-matrix and ink-jet printers are capable of graphics output, and allow easy definition of fonts by software. Thermal printers utilize two different printing methods. The older, direct thermal types form characters and images by burning a heat-sensitive paper with heated pins. Thermal-transfer printers, on the other hand, employ thin-film or thick-filmprintheadsto melt and deposit on paper a wax-based in contained on amylarribbon. The thermal printers are most appropriate for color printing that is very useful in facsimile market. Finally, at the higher end, there are more expensive and reliable laser printers that produce fine quality prints in a flexible way. These printers utilize VLSI and laser technologies and ink powders referred to as toner. Hewlett-Packard's LaserJet is a typical example of these printers that are presently most popular and much sought after despite high cost. One shortcoming is that these printers are not yet capable of color prints.", "ref_id": 4726, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Name and briefly describe the commonly used input and output devices.", "options": ["Common input and output devices include projectors, scanners, and joysticks.", "Common input and output devices include console monitors, terminals, tape units, disk units, diskettes, and printers.", "Common input and output devices include webcams, graphic tablets, and game controllers.", "Common input and output devices include speakers, microphones, and touch screens."], "answer": "B", "solution": "Console Monitors: In the early days, teletype consoles that use 132-column wide paper were used as the primary interface device between the operator and the computer. It looked very much like the 132- column wide paper printers that are not used as much these days, but it differed from the hardcopy line printer (LP) since it was capable of both input and output. Both input and output was one line at a time. Consoles were primarily used for booting up and maintenance of the system, and for important operating system messages. Nowadays, the CRT monitors that are directly connected to the computer system are used for the same purpose. The monitors that look like the small-screen TV along with keyboards that attach to them are widely used in PCs. These monitors are ca-pable ofdotmappedgraphics where the screen contains small pixels (dots) with dimensions that usually range from 640-by-400 low resolution to 1280-by-900 high resolution. Otherwise, the screen is capable of 80-by-25 character display in line (non--graphics) mode. In addition, the monitors may have either mono-chrome or colored screens. The number and shades of colors de-pend upon the specific make and model. Terminals : Perhaps the most frequently used input-output device is the CRT terminals with a keyboard and a screen. Strictly speaking, the keyboard is used for input and the video screen is used for output. The keyboards conform to basic standards such as ASCII, ANSI, and PC, but are often specialized for the conve-nient user interface. The screen may be used in character or graphics mode. In character mode, it can display characters such as ASCII set on 24 rows (lines) and 80 columns (characters per line). In some cases, there may be 25th row (line) to display function keys on the screen (so called soft function keys used in word processing systems) . There may also be 132-column mode, where the characters are smaller and hard to read. This is re-ally a remnant of the old days when 132-column wide papers were used to print out the reports. Tape Units : Although not used as frequently, except for backup of large amounts of data, the magnetic tapes are supported by tape units (drives) that have two reels feeding each other. The reels contain tapes with densities ranging from 800 bpi (bits per inch) to 6250 bpi. The access rate (e.g. how fast the tape is read or written) depends upon the manufacture of the drive, except that the access is almost always sequential. This means that it is not possible to access records (80 or more bytes data) directly. Disk Units : Also referred to as secondary storage (as opposed to the primary memory or RAM), disks are used for both input and output. Disks allow direct (or random) access to any block of data. A block of data is generally 512 to 1024 bytes and physi-cally correspond to a disk sector that can directly by homed in by the disk head. The more precise access to data within a block is done by first reading the entire block into the primary memory. The disks have capacities that depend upon the type of computer (e.g. mainframe, mini, PC, etc.) and generally range from 10 megabytes to about half gigabytes. The personal comput-ers have non- removable hard disks referred to as HDU (Hard Disk Unit) . The capacities are, as of the 1990s, anywhere from 10 to 80 megabytes. The optical disks are usually read-only (e.g. allow storage only once), but have capacities ranging from half gigabytes to four gigabytes. Diskettes : As its name implies, a diskette is a small magnetic disk. These are also called floppy disks or simply floppies. The most common sizes are either 4.25-in. by 4.25 in. standard or 3.50-in. by 3.50-in mini diskettes. A high-density standard diskette can store up to 1.2 megabytes and requires an appropri-ate diskette drive (floppy unit) for processing. A double-den-sity standard diskette has 360-kilobyte capacity. The minidiskettes have capacities of 720 kilobytes and 1.44 mega-bytes. Printers : Although the so called line printers (LPs) that print on 132- column wide paper still exist and are used in some cases with mainframe andsuperminisystems, most printers are much more compact and print on standard (8.5-by-ll inch) paper. The number of characters per line is determined by the font size 10 (10 characters per inch), normally 80 characters per line is printed. The printers are attached to the computer through printer ports (e.g. communication interface for transferring bits of information). The ports are of 36-pinCentronixtype for paral-lel interface and of 25-pin RS-232 type for serial interfaces. The printers may be of letter-quality or dot-matrix type. The former normally uses daisywheel character fonts and serial- impact upon ribbons much like the typewriters. There is less flexibility to define characters and fonts, but the quality is letter-quality. The dot-matrix printers define characters on a matrix of size 5-by-7 (coarse) or 9-by-12 (fine). These are less expensive printers based on older technology and imprint the pattern through ribbon (reels or cartridge). The ink-jet print-ers use special inks in liquid or solid forms ejected through a matrix with higher resolution (12-by- 15, 18-by-36, or better). Using newer technology, ink-jet printers produce almost letter quality prints, and can also print in colors. The dot-matrix and ink-jet printers are capable of graphics output, and allow easy definition of fonts by software. Thermal printers utilize two different printing methods. The older, direct thermal types form characters and images by burning a heat-sensitive paper with heated pins. Thermal-transfer printers, on the other hand, employ thin-film or thick-filmprintheadsto melt and deposit on paper a wax-based in contained on amylarribbon. The thermal printers are most appropriate for color printing that is very useful in facsimile market. Finally, at the higher end, there are more expensive and reliable laser printers that produce fine quality prints in a flexible way. These printers utilize VLSI and laser technologies and ink powders referred to as toner. Hewlett-Packard's LaserJet is a typical example of these printers that are presently most popular and much sought after despite high cost. One shortcoming is that these printers are not yet capable of color prints."}, "question": "task_1"}}, {"data": {"text": "Question:\nIllustrate transfer of control in a PL/I program, usingGOTO statements.\n\nOptions:\nA. The GOTO statement in PL/I program processing resumes at a point without a label.\nB. The GOTO statement in PL/I program alters the processing sequence, discontinues the normal sequential execution and processing resumes at a point that is indicated by a label.\nC.             The GOTO statement continues the sequential execution.\nD. The GOTO statement in PL/I program doesn't alter the processing sequence.\n\nAnswer: B\n\nReference Solution:\nThe PL/I machine has an implicitly defined sequential execution. The execution of statements is normally a sequential process, however, a specialstatement, the GOTO statement can alter the processing sequenceof the PL/I ma-chine. This GOTO statement discontinues the normalsequen-tial execution and processing resumes at a point that is in-dicatedby a label. Examples of well formed GOTO statements are given below: 1) SUM:A= B + C; \\textbullet \\textbullet \\textbullet \\textbullet GOTO SUM; 2)GOTO NEXT; \\textbullet \\textbullet \\textbullet \\textbullet NEXT:X=Y\\textasteriskcenteredZ; 3) JUMP:GOTO TERMINATE; \\textbullet \\textbullet \\textbullet \\textbullet TERMINATE:END; The following are a few examples of not well-formed GOTO statements. a)JOE:PROCEDURE OPTIONS (MAIN); \\textbullet \\textbullet \\textbullet \\textbullet GOTO JOE; The above is wrong due to the fact that the control can only be transferred withinthe body of the main program. In other words, GOTO cannot transfercontrol to the starting point of a procedure as above. b) GOTO END_1 \\textbullet \\textbullet \\textbullet \\textbullet END END_1 The above is wrong because there is no label END_1 anywhere in the bodyof the program. END_1 is used as a part of an-other statement, but END_1 is not a label of any statement in the program body.", "ref_id": 4727, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Illustrate transfer of control in a PL/I program, usingGOTO statements.", "options": ["The GOTO statement in PL/I program processing resumes at a point without a label.", "The GOTO statement in PL/I program alters the processing sequence, discontinues the normal sequential execution and processing resumes at a point that is indicated by a label.", "The GOTO statement continues the sequential execution.", "The GOTO statement in PL/I program doesn't alter the processing sequence."], "answer": "B", "solution": "The PL/I machine has an implicitly defined sequential execution. The execution of statements is normally a sequential process, however, a specialstatement, the GOTO statement can alter the processing sequenceof the PL/I ma-chine. This GOTO statement discontinues the normalsequen-tial execution and processing resumes at a point that is in-dicatedby a label. Examples of well formed GOTO statements are given below: 1) SUM:A= B + C; \\textbullet \\textbullet \\textbullet \\textbullet GOTO SUM; 2)GOTO NEXT; \\textbullet \\textbullet \\textbullet \\textbullet NEXT:X=Y\\textasteriskcenteredZ; 3) JUMP:GOTO TERMINATE; \\textbullet \\textbullet \\textbullet \\textbullet TERMINATE:END; The following are a few examples of not well-formed GOTO statements. a)JOE:PROCEDURE OPTIONS (MAIN); \\textbullet \\textbullet \\textbullet \\textbullet GOTO JOE; The above is wrong due to the fact that the control can only be transferred withinthe body of the main program. In other words, GOTO cannot transfercontrol to the starting point of a procedure as above. b) GOTO END_1 \\textbullet \\textbullet \\textbullet \\textbullet END END_1 The above is wrong because there is no label END_1 anywhere in the bodyof the program. END_1 is used as a part of an-other statement, but END_1 is not a label of any statement in the program body."}, "question": "task_1"}}, {"data": {"text": "Question:\nWhat are the rules regarding the specification of a procedure?\n\nOptions:\nA. Procedures execute automatically during program execution\nB. Procedures can only be declared at the beginning of the program\nC.             Procedure block may appear anywhere in the program, must start with a procedure statement with at least one name, must end with an END procedure-name statement, is bypassed during execution unless invoked by a procedure reference.\nD. Procedures do not require an end statement\n\nAnswer: C\n\nReference Solution:\nThe rules for the specification of a procedure are as follows. 1. The procedure block may appear in any part of the PL/I program bodyin which a Declare statement is allowed. 2. Each procedure block must start with a procedure statement whichcontains at least one name for the proce-dure .E.g., GRAVY: BREAD: PROCEDURE; In the above, BREAD and GRAVY are names of the procedure. 3. Each procedure block must end with an END procedure-name statement.E.g., END BREAD; 4. When a procedure statement is encountered by the program controlduring execution, the program control by-passes the whole procedureblock up to the end statement of the procedure. 5. Program control will execute the procedure only when the procedureis invoked by a procedure reference. A procedure reference maybe a function reference or a sub-routine reference.E.g., CALL BREAD; Y = U\\textasteriskcenteredSHIP(X,Y); In the above, BREAD and SHIP are procedures which are ex-plicitly invokedas part of a program. The procedures will then be executed.", "ref_id": 4728, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "What are the rules regarding the specification of a procedure?", "options": ["Procedures execute automatically during program execution", "Procedures can only be declared at the beginning of the program", "Procedure block may appear anywhere in the program, must start with a procedure statement with at least one name, must end with an END procedure-name statement, is bypassed during execution unless invoked by a procedure reference.", "Procedures do not require an end statement"], "answer": "C", "solution": "The rules for the specification of a procedure are as follows. 1. The procedure block may appear in any part of the PL/I program bodyin which a Declare statement is allowed. 2. Each procedure block must start with a procedure statement whichcontains at least one name for the proce-dure .E.g., GRAVY: BREAD: PROCEDURE; In the above, BREAD and GRAVY are names of the procedure. 3. Each procedure block must end with an END procedure-name statement.E.g., END BREAD; 4. When a procedure statement is encountered by the program controlduring execution, the program control by-passes the whole procedureblock up to the end statement of the procedure. 5. Program control will execute the procedure only when the procedureis invoked by a procedure reference. A procedure reference maybe a function reference or a sub-routine reference.E.g., CALL BREAD; Y = U\\textasteriskcenteredSHIP(X,Y); In the above, BREAD and SHIP are procedures which are ex-plicitly invokedas part of a program. The procedures will then be executed."}, "question": "task_1"}}, {"data": {"text": "Question:\nGiven the function f(x,y,z) below, write f(x,y,z) as a product ofmaxterms. f(x,y,z) = (z +x) (y +z) (x + y + z) (x+y)\n\nOptions:\nA. f(x,y,z) = \u03a0M(1,3,5,7)\nB. f(x,y,z) = \u03a0M(0,2,4,6,8)\nC.             f(x,y,z) = \u03a0M(1,2,3,4,5)\nD. f(x,y,z) = \u03a0M(0,1,4,5,6,7)\n\nAnswer: D\n\nReference Solution:\nIf a switching function is specified in Product of Sum form, then it may be expanded to canonical PS form by repeatedly using the theorem given below. THEOREM: (a + b) (a +b) = a Note: in the original function f(x,y,z), the first, second, and the fourth terms can be changed using the theorem defined above. These changes will be; (z +x) = (x+ y + z) (x+y+ z) (y +z) = (x + y +z) (x+ y +z) (x+y) = (x+y+ z) (x+y+z) then the function f(x,y,z) becomes; f(x,y,z) = (x+ y + z) (x+y+z) (x + y +z) \\bullet (x+ y +z) (x+y+ z) (x+y+z) \\bullet (x + y + z) this is the desired final form of the function, now it can be translated into MAXTERM code by assigning 1's to false variables, and 0's to true variables. This procedure of coding MAXTERMS is illustrated below using the function f(x,y,z); f(x,y,z) = (x+ y + z) (x+y+z) (x + y +z) 100111001 (x+ y +z) (x+y+ z) (x+y+z) 101110111 (x + y + z) 000 In decimal arithmetic each code group represents numbers such as 4,7,1,5,6,0, with the redundant 7 being used only once, and the solution can be written as; f(x,y,z) = M_4 M_7 M_1 M_5 M_6 M_0 or f(x,y,z) = \\prod M(0,1,4,5,6,7)", "ref_id": 4729, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Given the function f(x,y,z) below, write f(x,y,z) as a product ofmaxterms. f(x,y,z) = (z +x) (y +z) (x + y + z) (x+y)", "options": ["f(x,y,z) = \u03a0M(1,3,5,7)", "f(x,y,z) = \u03a0M(0,2,4,6,8)", "f(x,y,z) = \u03a0M(1,2,3,4,5)", "f(x,y,z) = \u03a0M(0,1,4,5,6,7)"], "answer": "D", "solution": "If a switching function is specified in Product of Sum form, then it may be expanded to canonical PS form by repeatedly using the theorem given below. THEOREM: (a + b) (a +b) = a Note: in the original function f(x,y,z), the first, second, and the fourth terms can be changed using the theorem defined above. These changes will be; (z +x) = (x+ y + z) (x+y+ z) (y +z) = (x + y +z) (x+ y +z) (x+y) = (x+y+ z) (x+y+z) then the function f(x,y,z) becomes; f(x,y,z) = (x+ y + z) (x+y+z) (x + y +z) \\bullet (x+ y +z) (x+y+ z) (x+y+z) \\bullet (x + y + z) this is the desired final form of the function, now it can be translated into MAXTERM code by assigning 1's to false variables, and 0's to true variables. This procedure of coding MAXTERMS is illustrated below using the function f(x,y,z); f(x,y,z) = (x+ y + z) (x+y+z) (x + y +z) 100111001 (x+ y +z) (x+y+ z) (x+y+z) 101110111 (x + y + z) 000 In decimal arithmetic each code group represents numbers such as 4,7,1,5,6,0, with the redundant 7 being used only once, and the solution can be written as; f(x,y,z) = M_4 M_7 M_1 M_5 M_6 M_0 or f(x,y,z) = \\prod M(0,1,4,5,6,7)"}, "question": "task_1"}}, {"data": {"text": "Question:\nExplain the action of1the following procedure which includes afunction procedure within itself. SALES:PROCEDURE; DCL 1 SALES_FORCE (500) ; 2NAME; 3 FIRST_NAMECHAR(10), 3 LAST_NAMECHAR(20), 2 BASE_SALARY FIXED (6,2) 2 PERCENT_COMMISSION FIXED(2,0), A:IF BASE_SALARY(SALESMAN_INDEX)= BASE_SALARY (SALESMAN_ INDEX) THEN GOTO L; ELSE GOTO A; SALESMAN_INDEX: PROCEDURE; GETLIST(F_NAME, L_NAME); DO I = 1 TO 500 WHILE (F_NAME (I) \\lnot = FIRST_NAME (I) \\vert L_NAME (I)\\lnot=LAST_NAME (I)); END; IF I>500 THEN DO; PUT LIST (F_NAME\\vert\\vert L_NAME, 'b b NOT FOUND') GOTO ERROR; END; RETURN(I) ; END SALESMAN_INDEX; L:END SALES;\n\nOptions:\nA. 'SALES' is the label of the main procedure, and 'SALESMAN_INDEX' is a procedure within it that checks if a person with a given F_NAME and L_NAME is in the sales force. If the person is in the sales force, the program goes to 'L' (the end), otherwise, it goes back to 'A' to evaluate new values.\nB. 'SALESMAN_INDEX' is a variable within the 'SALES' procedure.\nC.             'SALES' is a function that calculates commission.\nD. 'SALES' is the only procedure in the program.\n\nAnswer: A\n\nReference Solution:\nIn the above program, 'SALES' is the label of the main procedure. The declaration shows that the variable SALES-FORCE is a 500 elementarray. The first executable statement of the program islabelled 'A'. But, in order to evaluate this statement expression, the computer comesacross the variable 'SALESMAN_INDEX' on the left hand side of theexpression of the statementlabelled'A'. Now, SALESMAN_INDEX is notin the DCL statement. Therefore, the computer checks to see if it is a procedurereference. On looking down, it sees that there is a procedure called'SALESMAN_INDEX'. Hence, the program jumps to that label. As a part of this procedure, the computer reads the data card for valuesbf variables F_NAME and L_NAME. Then, if I is evaluated, it returnsthe value of I, say I_1 as a consequence of the statement RETURN(I). That is, the value of the variable SALESMAN_INDEX in the statementlabelledA is made equal to the value of I. Now, the program comesto the right hand side of the statementlabelled'A'. Once again it seesthe function procedure reference SALESMAN_INDEX. . Hence, the programagain goes to the procedure SALESMAN_INDEX and evaluates anew value of I, say, I_2. This new value of I is returned to the right hand sideof the statementlabelled'A'. Now we have all the information required to evalu-ate the conditionalpart of statement 'A', A:IF BASE_SALARY (I_1) = BASE_SALARY (1_2)THEN ... The program is, given a list of F_NAME and L_NAME, it checks whether theperson having particular F_NAME, L_NAME is in sales force and if so wego to L. Here L islabelledto end but we can transfer control to any othercomputation e.g., calculation of commission, etc. bylabellingthat computa-tionas L. Hence, if the above condition is satisfied then we go to thestatementlabelledL, which is the END SALES statement. But, if the abovecondition is not satisfied, then we go to the ELSE part of the statement, which asks us to go back to A. This means we evaluate all over againthe function procedure SALESMAN_INDEX for new values of F_NAME and L_NAME read from data cards, and continue as before.", "ref_id": 4730, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Explain the action of1the following procedure which includes afunction procedure within itself. SALES:PROCEDURE; DCL 1 SALES_FORCE (500) ; 2NAME; 3 FIRST_NAMECHAR(10), 3 LAST_NAMECHAR(20), 2 BASE_SALARY FIXED (6,2) 2 PERCENT_COMMISSION FIXED(2,0), A:IF BASE_SALARY(SALESMAN_INDEX)= BASE_SALARY (SALESMAN_ INDEX) THEN GOTO L; ELSE GOTO A; SALESMAN_INDEX: PROCEDURE; GETLIST(F_NAME, L_NAME); DO I = 1 TO 500 WHILE (F_NAME (I) \\lnot = FIRST_NAME (I) \\vert L_NAME (I)\\lnot=LAST_NAME (I)); END; IF I>500 THEN DO; PUT LIST (F_NAME\\vert\\vert L_NAME, 'b b NOT FOUND') GOTO ERROR; END; RETURN(I) ; END SALESMAN_INDEX; L:END SALES;", "options": ["'SALES' is the label of the main procedure, and 'SALESMAN_INDEX' is a procedure within it that checks if a person with a given F_NAME and L_NAME is in the sales force. If the person is in the sales force, the program goes to 'L' (the end), otherwise, it goes back to 'A' to evaluate new values.", "'SALESMAN_INDEX' is a variable within the 'SALES' procedure.", "'SALES' is a function that calculates commission.", "'SALES' is the only procedure in the program."], "answer": "A", "solution": "In the above program, 'SALES' is the label of the main procedure. The declaration shows that the variable SALES-FORCE is a 500 elementarray. The first executable statement of the program islabelled 'A'. But, in order to evaluate this statement expression, the computer comesacross the variable 'SALESMAN_INDEX' on the left hand side of theexpression of the statementlabelled'A'. Now, SALESMAN_INDEX is notin the DCL statement. Therefore, the computer checks to see if it is a procedurereference. On looking down, it sees that there is a procedure called'SALESMAN_INDEX'. Hence, the program jumps to that label. As a part of this procedure, the computer reads the data card for valuesbf variables F_NAME and L_NAME. Then, if I is evaluated, it returnsthe value of I, say I_1 as a consequence of the statement RETURN(I). That is, the value of the variable SALESMAN_INDEX in the statementlabelledA is made equal to the value of I. Now, the program comesto the right hand side of the statementlabelled'A'. Once again it seesthe function procedure reference SALESMAN_INDEX. . Hence, the programagain goes to the procedure SALESMAN_INDEX and evaluates anew value of I, say, I_2. This new value of I is returned to the right hand sideof the statementlabelled'A'. Now we have all the information required to evalu-ate the conditionalpart of statement 'A', A:IF BASE_SALARY (I_1) = BASE_SALARY (1_2)THEN ... The program is, given a list of F_NAME and L_NAME, it checks whether theperson having particular F_NAME, L_NAME is in sales force and if so wego to L. Here L islabelledto end but we can transfer control to any othercomputation e.g., calculation of commission, etc. bylabellingthat computa-tionas L. Hence, if the above condition is satisfied then we go to thestatementlabelledL, which is the END SALES statement. But, if the abovecondition is not satisfied, then we go to the ELSE part of the statement, which asks us to go back to A. This means we evaluate all over againthe function procedure SALESMAN_INDEX for new values of F_NAME and L_NAME read from data cards, and continue as before."}, "question": "task_1"}}, {"data": {"text": "Question:\nDefine the following terms, making clear the distinctions between them:a) Bitb) Bytec) Word.\n\nOptions:\nA. Word is the elementary data unit, Byte is a group of 8 bits, Bit is dependent on the hardware architecture.\nB. Bit is the most elementary data unit, Byte is a group of 8 bits, Word is dependent upon the hardware architecture of the computer.\nC.             Bit is a group of 8 units, Byte is dependent upon the hardware architecture, Word is the most elementary data unit.\nD. Byte is the elementary data unit, Bit is a group of 8 bytes, Word is dependent on the software.\n\nAnswer: B\n\nReference Solution:\na) The bit is the most elementary data unit that corresponds to a binary digit in computer's memory. Generally the binary 1 is represented as high voltage and binary 0 is represented as low or negative voltage in a digital computer's registers and memory. However, this also depends on the nature of media. For example, on magnetic disks and tape reels, the bit is stored as traces of magnetism. The bit is also typically used to measure the rate at which data is transmitted over communica-tion media (e.g. twisted copper wire, coaxial cable, air, etc). A kilobit per second is one thousand bits per second, a megabit per second is one million bits per second. As of 1990, we do not yet speak of gigabits per second since there are no medium over which that high a communication rate can be achieved. b) The byte is a group of 8 bits. A byte may represent ASCII (American Standard Code for Information Interchange) char-acters or numbers in the computer. Byte is the basic unit for expressing storage capacities in computers. A kilobyte is a thousand bytes, a megabyte is a million bytes, and a gigabyte is one billion bytes. c) The word is less well defined. Its definition is depen-dent upon the hardware architecture of the computer. In general, the term \"word\" is used to indicate the length of registers and addressable memory locations. If the computer has an 8-bit pro-cessor (CPU), such as INTEL 8080A, then the word is 8 bits. If the computer has a 16-bit processor, such as PDP-11, then the word is 16 bits. Finally, if the computer has a 32-bit proces-sor, then the word is 32 bits. The term \"word\", other than indi-cating the smallest addressable units in a computer's memory, is not a very useful measure since it is not well defined. Perhaps the best definition is that a word is 16 bits (two bytes), a double word is 32 bits (four bytes).", "ref_id": 4731, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Define the following terms, making clear the distinctions between them:a) Bitb) Bytec) Word.", "options": ["Word is the elementary data unit, Byte is a group of 8 bits, Bit is dependent on the hardware architecture.", "Bit is the most elementary data unit, Byte is a group of 8 bits, Word is dependent upon the hardware architecture of the computer.", "Bit is a group of 8 units, Byte is dependent upon the hardware architecture, Word is the most elementary data unit.", "Byte is the elementary data unit, Bit is a group of 8 bytes, Word is dependent on the software."], "answer": "B", "solution": "a) The bit is the most elementary data unit that corresponds to a binary digit in computer's memory. Generally the binary 1 is represented as high voltage and binary 0 is represented as low or negative voltage in a digital computer's registers and memory. However, this also depends on the nature of media. For example, on magnetic disks and tape reels, the bit is stored as traces of magnetism. The bit is also typically used to measure the rate at which data is transmitted over communica-tion media (e.g. twisted copper wire, coaxial cable, air, etc). A kilobit per second is one thousand bits per second, a megabit per second is one million bits per second. As of 1990, we do not yet speak of gigabits per second since there are no medium over which that high a communication rate can be achieved. b) The byte is a group of 8 bits. A byte may represent ASCII (American Standard Code for Information Interchange) char-acters or numbers in the computer. Byte is the basic unit for expressing storage capacities in computers. A kilobyte is a thousand bytes, a megabyte is a million bytes, and a gigabyte is one billion bytes. c) The word is less well defined. Its definition is depen-dent upon the hardware architecture of the computer. In general, the term \"word\" is used to indicate the length of registers and addressable memory locations. If the computer has an 8-bit pro-cessor (CPU), such as INTEL 8080A, then the word is 8 bits. If the computer has a 16-bit processor, such as PDP-11, then the word is 16 bits. Finally, if the computer has a 32-bit proces-sor, then the word is 32 bits. The term \"word\", other than indi-cating the smallest addressable units in a computer's memory, is not a very useful measure since it is not well defined. Perhaps the best definition is that a word is 16 bits (two bytes), a double word is 32 bits (four bytes)."}, "question": "task_1"}}, {"data": {"text": "Question:\nGiven a two-dimensional array AMATR which contains 10 rows and 10 columns and a one-dimensional array called DIAG which contains 10 elements, write a program segment in FORTRAN to compute the elements of D1AG from DIAG(I) = AMATR(I, I) for I =1,2,.. .,10. Then compute the trace of AMATR, which is defined as trace(AMATR) = 10\\sum_i= 1AMATR(I, I) = 10\\sum_i= 1DIAG(I).\n\nOptions:\nA. DIMENSION AMATR (10,10), DIAG (10) TRACE = 1.0 DO 100 I = 1,10 DIAG (I) = AMATR (I, I) TRACE = TRACE + DIAG (I) 100CONTINUE STOP END\nB. DIMENSION AMATR (10,10), DIAG (10) TRACE = 0.0 DO 100 I = 1,10 DIAG (I) = AMATR (I, I) TRACE = TRACE + DIAG (I) 100CONTINUE STOP END\nC.             DIMENSION AMATR (10,10), DIAG (10) TRACE = 0.0 DO 100 I = 1,10 DIAG (I) = AMATR (I, I) TRACE = TRACE * DIAG (I) 100CONTINUE STOP END\nD. DIMENSION AMATR (10,10), DIAG (10) TRACE = 0.0 DO 100 I = 1,10 DIAG (I) = AMATR (I, I) TRACE = TRACE - DIAG (I) 100CONTINUE STOP END\n\nAnswer: B\n\nReference Solution:\nDIMENSION AMATR (10,10), DIAG (10) TRACE = 0.0 DO 100 I = 1,10 DIAG (I) = AMATR (I, I) TRACE = TRACE + DIAG (I) 100CONTINUE STOP END", "ref_id": 4732, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Given a two-dimensional array AMATR which contains 10 rows and 10 columns and a one-dimensional array called DIAG which contains 10 elements, write a program segment in FORTRAN to compute the elements of D1AG from DIAG(I) = AMATR(I, I) for I =1,2,.. .,10. Then compute the trace of AMATR, which is defined as trace(AMATR) = 10\\sum_i= 1AMATR(I, I) = 10\\sum_i= 1DIAG(I).", "options": ["DIMENSION AMATR (10,10), DIAG (10) TRACE = 1.0 DO 100 I = 1,10 DIAG (I) = AMATR (I, I) TRACE = TRACE + DIAG (I) 100CONTINUE STOP END", "DIMENSION AMATR (10,10), DIAG (10) TRACE = 0.0 DO 100 I = 1,10 DIAG (I) = AMATR (I, I) TRACE = TRACE + DIAG (I) 100CONTINUE STOP END", "DIMENSION AMATR (10,10), DIAG (10) TRACE = 0.0 DO 100 I = 1,10 DIAG (I) = AMATR (I, I) TRACE = TRACE * DIAG (I) 100CONTINUE STOP END", "DIMENSION AMATR (10,10), DIAG (10) TRACE = 0.0 DO 100 I = 1,10 DIAG (I) = AMATR (I, I) TRACE = TRACE - DIAG (I) 100CONTINUE STOP END"], "answer": "B", "solution": "DIMENSION AMATR (10,10), DIAG (10) TRACE = 0.0 DO 100 I = 1,10 DIAG (I) = AMATR (I, I) TRACE = TRACE + DIAG (I) 100CONTINUE STOP END"}, "question": "task_1"}}, {"data": {"text": "Question:\nWrite a Basic program that allows a player to play Tic-Tac-Toe with a computer. Tic-Tac-Toe with a computer.\n\nOptions:\nA. The game board is unmarked\nB. The game board is color-coded\nC.             The game board is numbered\nD. The game board is lettered\n\nAnswer: C\n\nReference Solution:\nThe game board is numbered", "ref_id": 4733, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Write a Basic program that allows a player to play Tic-Tac-Toe with a computer. Tic-Tac-Toe with a computer.", "options": ["The game board is unmarked", "The game board is color-coded", "The game board is numbered", "The game board is lettered"], "answer": "C", "solution": "The game board is numbered"}, "question": "task_1"}}, {"data": {"text": "Question:\nDevelop a FORTRAN program to useLagrangian interpolationto evaluate F(x) = x3 at x = 3, given the table below: i 1 2 3 4 x_i 1 2 4 7 f_i 1 8 64 343 f_i \\equiv f(x_i)\n\nOptions:\nA. 26.9999980\nB. 25.9999980\nC.             28.0000010\nD. 33.0000000\n\nAnswer: A\n\nReference Solution:\nThe Lagrange polynomials of degree m are defined as P_j(x) =A_j^m^+1\\prod(k=1)k\\not =j(x -x_k) whereA_j= ^m+1\\prod(k=1)k\\not =j[1/(x_j-x_k)] Here m = 3 and we approximate f(x) by 4\\sum_i_=1f(x_i)P_i (x). The evaluations of P_j(x) are shown below, for x = 3. P1(x) \\equiv P(x,1) = {(x-2)(x-4)(x-7)} / {(x1-x2)(x1-x3)(x1-x4)} = {(x-2)(x-4)(x-7)}/ (-18) P2(x) \\equiv P(x,2) = {(x-1)(x-4)(x-7)} / {(x2-x1)(x2-x3)(x2-x4)} = {(x-1)(x-4)(x-7)} / 10 P3(x) \\equiv P(x,3) = {(x-1)(x-2)(x-7)} / {(x3-x1)(x3-x2)(x3-x4)} = {(x-1)(x-2)(x-7)} / 18 P4(x) = P(x,4) = {(x-1)(x-2)(x-4)} / {(x4-x1)(x4-x2)(x4-x3)} = {(x-1)(x-2)(x-4)} / 90 ThusF(3) \\approx 4\\sum_i_=1 f(x_i) P(3,I) = 1(-2/9) + 8(4/5) + 64(4/9) + 343(-2/90) = 26.9999980 which is very close to 33 = 27. The program and sample output are given below: CPROGRAM 3.3 CPROGRAM FOR LAGRANGIAN INTERPOLATION CUNEVENLY SPACED PIVOTAL POINTS DIMENSIONX(50), P(50), F(50) PUNCH 994 READ 999, N, (X(I), F(I), I = 1,N) 1READ 998, XO DO 10 J = 1,N P(J) = 1 DO 10 I = 1,N IF (I - J) 9, 10, 9 9P(J) = P(J) \\textasteriskcentered (XO - X(I))/(X(J) - X(I)) 10CONTINUE FO = O DO 20 I = 1,N 20FO = FO +P(I) \\textasteriskcentered F(I) PUNCH 997 PUNCH 996, (I,X(I),F(I), P(I), I = 1,N) PUNCH 995, XO, FO GO TO 1 994FORMAT (//, 19X, 24H RESULTS FROM PROGRAM 3.3) 995FORMAT (19X, 6H AT X = F5.2, 21H THE VALUE OF F(X) IS F12.7) 996FORMAT (I10, 3F14.7) 997FORMAT (//, 9X, 1H1, 8X,4HX(I), 10X, 4HF(I), 9X, 6HP(X,I)) 998FORMAT (8F10.0) 999FORMAT (I5/8F10.0) END [SAMPLE]RESULTSFROMPROGRAM 3.3 X(I) F(I) P(X,I) 1 1.0000000 1.0000000 -0.2222222 2 2.0000000 8.0000000 0.8000000 3 4.0000000 64.0000000 0.4444444 4 7.0000000 343.0000000 -0.0222222 AT X = 3.00 THE VALUE OF F(X) IS 26.9999980", "ref_id": 4734, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Develop a FORTRAN program to useLagrangian interpolationto evaluate F(x) = x3 at x = 3, given the table below: i 1 2 3 4 x_i 1 2 4 7 f_i 1 8 64 343 f_i \\equiv f(x_i)", "options": ["26.9999980", "25.9999980", "28.0000010", "33.0000000"], "answer": "A", "solution": "The Lagrange polynomials of degree m are defined as P_j(x) =A_j^m^+1\\prod(k=1)k\\not =j(x -x_k) whereA_j= ^m+1\\prod(k=1)k\\not =j[1/(x_j-x_k)] Here m = 3 and we approximate f(x) by 4\\sum_i_=1f(x_i)P_i (x). The evaluations of P_j(x) are shown below, for x = 3. P1(x) \\equiv P(x,1) = {(x-2)(x-4)(x-7)} / {(x1-x2)(x1-x3)(x1-x4)} = {(x-2)(x-4)(x-7)}/ (-18) P2(x) \\equiv P(x,2) = {(x-1)(x-4)(x-7)} / {(x2-x1)(x2-x3)(x2-x4)} = {(x-1)(x-4)(x-7)} / 10 P3(x) \\equiv P(x,3) = {(x-1)(x-2)(x-7)} / {(x3-x1)(x3-x2)(x3-x4)} = {(x-1)(x-2)(x-7)} / 18 P4(x) = P(x,4) = {(x-1)(x-2)(x-4)} / {(x4-x1)(x4-x2)(x4-x3)} = {(x-1)(x-2)(x-4)} / 90 ThusF(3) \\approx 4\\sum_i_=1 f(x_i) P(3,I) = 1(-2/9) + 8(4/5) + 64(4/9) + 343(-2/90) = 26.9999980 which is very close to 33 = 27. The program and sample output are given below: CPROGRAM 3.3 CPROGRAM FOR LAGRANGIAN INTERPOLATION CUNEVENLY SPACED PIVOTAL POINTS DIMENSIONX(50), P(50), F(50) PUNCH 994 READ 999, N, (X(I), F(I), I = 1,N) 1READ 998, XO DO 10 J = 1,N P(J) = 1 DO 10 I = 1,N IF (I - J) 9, 10, 9 9P(J) = P(J) \\textasteriskcentered (XO - X(I))/(X(J) - X(I)) 10CONTINUE FO = O DO 20 I = 1,N 20FO = FO +P(I) \\textasteriskcentered F(I) PUNCH 997 PUNCH 996, (I,X(I),F(I), P(I), I = 1,N) PUNCH 995, XO, FO GO TO 1 994FORMAT (//, 19X, 24H RESULTS FROM PROGRAM 3.3) 995FORMAT (19X, 6H AT X = F5.2, 21H THE VALUE OF F(X) IS F12.7) 996FORMAT (I10, 3F14.7) 997FORMAT (//, 9X, 1H1, 8X,4HX(I), 10X, 4HF(I), 9X, 6HP(X,I)) 998FORMAT (8F10.0) 999FORMAT (I5/8F10.0) END [SAMPLE]RESULTSFROMPROGRAM 3.3 X(I) F(I) P(X,I) 1 1.0000000 1.0000000 -0.2222222 2 2.0000000 8.0000000 0.8000000 3 4.0000000 64.0000000 0.4444444 4 7.0000000 343.0000000 -0.0222222 AT X = 3.00 THE VALUE OF F(X) IS 26.9999980"}, "question": "task_1"}}, {"data": {"text": "Question:\n(a) Explain what is meant by even parity and odd parity. (b) Decode the following under the odd parity 8421 redundant (8421 R) code and determine if an error has occurred. (i) 00011 (ii) 01011 (iii) 01001 . (c) Decode the following four-digit number under the horizontal and vertical odd parity 8421 R coding scheme and determine if it had been correctly transmitted: 01101 00101 01011 00100 1101\n\nOptions:\nA. Only the first sequence has an error\nB. All sequences have an error\nC.             First sequence has an error, the second sequence is correct and represents decimal 5, third sequence has an error, and the bit in the fourth column and the second row of the four-digit number is in error.\nD. All sequences are correct\n\nAnswer: C\n\nReference Solution:\n(a) The even parity system adds a 1-bit to a data word if the word has an odd number of 1-bits or adds a 0-bit if the word has an even number of 1-bits. Thus, in an even parity system every legal code word has an even number of 1-bits. The odd parity system adds a 1-bit to a data word if the word has an even number of 1-bits, or adds a 0-bit if the word has an odd number of 1-bits. Thus, in an odd parity system every legal code word has an odd number of 1-bits. In an odd parity system it is also true that every legal code word has at least one 1-bit and at least one 0-bit, thus yielding additional information on whether or not the transmission line is operative. (b) When a parity bit is added to an 8421 code, it is sometimes known as the 8421 redundant (8421 R) code. The parity bit here-is called a redundancy bit. In an odd parity system, this parity bit would be 1 if the 8421 code word had an even number of 1's and 0 if the 8421 code word had an odd number of 1's. Thus, with the addition of the parity bit, every number in the odd parity 8421 R code has either one 1-bit or three 1-bits. If a received word has two or no 1-bits, an error has occurred. In decoding, the rightmost bit is not used, and the other four bits are decoded as regular 8421 code representation. (i) Since 00011 has two 1-bits, an error has occurred. (ii) Since 01011 has three 1-bits the word has been correctly trans-mitted. 01011 in 8421 R = 0101 in 8421 = decimal 5 . (iii) Since 01001 has two 1-bits, an error has occurred. (c) With odd parity, the presence of an even number of 1-bits indicates an error, but the precise faulty bit is not known. This can be over-come by checking for parity in columns as well as rows. This pro-cedure is called horizontal and vertical odd parity check. Thus, if the received message is: 01101 \\leftarrow first row 00101\\leftarrowsecond row 01011 \\leftarrow third row 00100 \\leftarrow fourth row first column\\rightarrow 1101 \\leftarrow fourth column the rightmost bits of the first four rows are row parity bits, and the last row consists of column parity bits. The first, third and fourth rows contain an odd number of 1-bits, so no error has occurred in those rows. But the second row has two 1-bits, indicating an error in that row. To determine which bit in that row is faulty, check the column parity bits. The first, second and third columns contain an odd number of 1-bits, so no error has occurred in those columns. But the fourth column has two 1-bits, indicating an error in that column. Therefore, the bit in the fourth column and the second row is in error. Note that this system not only has error- detecting capabilities, but error correcting capabilities as well, since, once the faulty bit is located, it can be corrected by changing it to its complement. (Recall that a bit in error is the complement of the input value and hence, complementing it again would yield the original input value, by the involution law.) The amount of redund-ancy in an error-correcting code must be much higher than in a mere error-detecting code. Also, note that although the regular parity (8421 R) system cannot pick up two errors occurring in the same data word (since the first error would result in an even number of 1-bits and the second error would result in an odd number of 1-bits, thus allowing the received word to pass the parity check), the horizontal and vertical parity system will indicate an error if a double error has occurred. The ability to detect the faulty bit is lost, however. Again, this encoding, decoding and error-correcting scheme is auto-matically implemented by the machine hardware.", "ref_id": 4735, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "(a) Explain what is meant by even parity and odd parity. (b) Decode the following under the odd parity 8421 redundant (8421 R) code and determine if an error has occurred. (i) 00011 (ii) 01011 (iii) 01001 . (c) Decode the following four-digit number under the horizontal and vertical odd parity 8421 R coding scheme and determine if it had been correctly transmitted: 01101 00101 01011 00100 1101", "options": ["Only the first sequence has an error", "All sequences have an error", "First sequence has an error, the second sequence is correct and represents decimal 5, third sequence has an error, and the bit in the fourth column and the second row of the four-digit number is in error.", "All sequences are correct"], "answer": "C", "solution": "(a) The even parity system adds a 1-bit to a data word if the word has an odd number of 1-bits or adds a 0-bit if the word has an even number of 1-bits. Thus, in an even parity system every legal code word has an even number of 1-bits. The odd parity system adds a 1-bit to a data word if the word has an even number of 1-bits, or adds a 0-bit if the word has an odd number of 1-bits. Thus, in an odd parity system every legal code word has an odd number of 1-bits. In an odd parity system it is also true that every legal code word has at least one 1-bit and at least one 0-bit, thus yielding additional information on whether or not the transmission line is operative. (b) When a parity bit is added to an 8421 code, it is sometimes known as the 8421 redundant (8421 R) code. The parity bit here-is called a redundancy bit. In an odd parity system, this parity bit would be 1 if the 8421 code word had an even number of 1's and 0 if the 8421 code word had an odd number of 1's. Thus, with the addition of the parity bit, every number in the odd parity 8421 R code has either one 1-bit or three 1-bits. If a received word has two or no 1-bits, an error has occurred. In decoding, the rightmost bit is not used, and the other four bits are decoded as regular 8421 code representation. (i) Since 00011 has two 1-bits, an error has occurred. (ii) Since 01011 has three 1-bits the word has been correctly trans-mitted. 01011 in 8421 R = 0101 in 8421 = decimal 5 . (iii) Since 01001 has two 1-bits, an error has occurred. (c) With odd parity, the presence of an even number of 1-bits indicates an error, but the precise faulty bit is not known. This can be over-come by checking for parity in columns as well as rows. This pro-cedure is called horizontal and vertical odd parity check. Thus, if the received message is: 01101 \\leftarrow first row 00101\\leftarrowsecond row 01011 \\leftarrow third row 00100 \\leftarrow fourth row first column\\rightarrow 1101 \\leftarrow fourth column the rightmost bits of the first four rows are row parity bits, and the last row consists of column parity bits. The first, third and fourth rows contain an odd number of 1-bits, so no error has occurred in those rows. But the second row has two 1-bits, indicating an error in that row. To determine which bit in that row is faulty, check the column parity bits. The first, second and third columns contain an odd number of 1-bits, so no error has occurred in those columns. But the fourth column has two 1-bits, indicating an error in that column. Therefore, the bit in the fourth column and the second row is in error. Note that this system not only has error- detecting capabilities, but error correcting capabilities as well, since, once the faulty bit is located, it can be corrected by changing it to its complement. (Recall that a bit in error is the complement of the input value and hence, complementing it again would yield the original input value, by the involution law.) The amount of redund-ancy in an error-correcting code must be much higher than in a mere error-detecting code. Also, note that although the regular parity (8421 R) system cannot pick up two errors occurring in the same data word (since the first error would result in an even number of 1-bits and the second error would result in an odd number of 1-bits, thus allowing the received word to pass the parity check), the horizontal and vertical parity system will indicate an error if a double error has occurred. The ability to detect the faulty bit is lost, however. Again, this encoding, decoding and error-correcting scheme is auto-matically implemented by the machine hardware."}, "question": "task_1"}}, {"data": {"text": "Question:\nCategorize the various procedural verbs used in COBOL.\n\nOptions:\nA. Data Manipulation, Sequence Control, Error Handling, Compiler Directing, Input / Output\nB. Input / Output, Arithmetic, Data movement and Manipulated, Sequence Control, Compiler Directing\nC.             Data Definition, Arithmetic, Data movement and Manipulated, Error Handling, Compiler Directing\nD. Data Definition, File Control, Arithmetic, Input / Output, Error Handling\n\nAnswer: B\n\nReference Solution:\nProcedural Verbs: Verbs specify action to be performed. In COBOL, each verb built into the system causes a specific series of events to occur when the program is running. The various verbs in COBOL are categorized in the following manner. Input / OutputOPEN CLOSE READ WRITE ACCEPT DISPLAY ArithmeticADD SUBTRACT MULTIPLY DIVIDE CAMPUTE Data movement and ManipulatedMOVE EXAMINE Sequence ControlGO TO ALTER PERFORM STOP CompilerDirectingENTER NOTE EXIT", "ref_id": 4736, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Categorize the various procedural verbs used in COBOL.", "options": ["Data Manipulation, Sequence Control, Error Handling, Compiler Directing, Input / Output", "Input / Output, Arithmetic, Data movement and Manipulated, Sequence Control, Compiler Directing", "Data Definition, Arithmetic, Data movement and Manipulated, Error Handling, Compiler Directing", "Data Definition, File Control, Arithmetic, Input / Output, Error Handling"], "answer": "B", "solution": "Procedural Verbs: Verbs specify action to be performed. In COBOL, each verb built into the system causes a specific series of events to occur when the program is running. The various verbs in COBOL are categorized in the following manner. Input / OutputOPEN CLOSE READ WRITE ACCEPT DISPLAY ArithmeticADD SUBTRACT MULTIPLY DIVIDE CAMPUTE Data movement and ManipulatedMOVE EXAMINE Sequence ControlGO TO ALTER PERFORM STOP CompilerDirectingENTER NOTE EXIT"}, "question": "task_1"}}, {"data": {"text": "Question:\nWrite in FORTRAN a complex function to find the complex numberof larg-est magnitude in an array of complex numbers.\n\nOptions:\nA. COMPLEX FUNCTIONMID(N,A) COMPLEXA(N) MID =A(N/2) RETURN END\nB. COMPLEX FUNCTIONMAX(N,A) COMPLEXA(N) MAX =A(1) IF (N. EQ. l) RETURN DO 7 I = 1,N IF (ABS(A(I)).LE.ABS(MAX)) GO TO 7 MAX =A(I) 7CONTINUE RETURN END\nC.             COMPLEX FUNCTIONMIN(N,A) COMPLEXA(N) MIN =A(1) IF (N. EQ. l) RETURN DO 7 I = 1,N IF (ABS(A(I)).GE.ABS(MIN)) GO TO 7 MIN =A(I) 7CONTINUE RETURN END\nD. COMPLEX FUNCTIONAVE(N,A) COMPLEXA(N) AVE =A(1) DO 7 I = 1,N AVE = AVE + A(I) 7CONTINUE AVE = AVE/N RETURN END\n\nAnswer: B\n\nReference Solution:\nOur function will make use of a complex arrayAdimension-ed size N. In addition, the complex absolute value library function is used. Otherwise no new concepts are involved. Let z = x +iywherex,yare real numbers and i2 = -1. The modulus or absolutevalue of z is given by \\vertz\\vert = \\surd(x2 + y2) . Since x, y are real, there are an infinite number of complex numbersqfa givenmagnitude. COMPLEX FUNCTIONMAX(N,A) COMPLEXA(N) MAX =A(1) IF (N. EQ. l) RETURN DO 7 I = 1,N IF (ABS(A(I)).LE.ABS(MAX)) GO TO 7 MAX =A(I) 7CONTINUE RETURN END", "ref_id": 4737, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Write in FORTRAN a complex function to find the complex numberof larg-est magnitude in an array of complex numbers.", "options": ["COMPLEX FUNCTIONMID(N,A) COMPLEXA(N) MID =A(N/2) RETURN END", "COMPLEX FUNCTIONMAX(N,A) COMPLEXA(N) MAX =A(1) IF (N. EQ. l) RETURN DO 7 I = 1,N IF (ABS(A(I)).LE.ABS(MAX)) GO TO 7 MAX =A(I) 7CONTINUE RETURN END", "COMPLEX FUNCTIONMIN(N,A) COMPLEXA(N) MIN =A(1) IF (N. EQ. l) RETURN DO 7 I = 1,N IF (ABS(A(I)).GE.ABS(MIN)) GO TO 7 MIN =A(I) 7CONTINUE RETURN END", "COMPLEX FUNCTIONAVE(N,A) COMPLEXA(N) AVE =A(1) DO 7 I = 1,N AVE = AVE + A(I) 7CONTINUE AVE = AVE/N RETURN END"], "answer": "B", "solution": "Our function will make use of a complex arrayAdimension-ed size N. In addition, the complex absolute value library function is used. Otherwise no new concepts are involved. Let z = x +iywherex,yare real numbers and i2 = -1. The modulus or absolutevalue of z is given by \\vertz\\vert = \\surd(x2 + y2) . Since x, y are real, there are an infinite number of complex numbersqfa givenmagnitude. COMPLEX FUNCTIONMAX(N,A) COMPLEXA(N) MAX =A(1) IF (N. EQ. l) RETURN DO 7 I = 1,N IF (ABS(A(I)).LE.ABS(MAX)) GO TO 7 MAX =A(I) 7CONTINUE RETURN END"}, "question": "task_1"}}, {"data": {"text": "Question:\nA list of numbers (1 through 9) is given. The object is to arrange the numbers in ascending order. A move is made by specifying how many numbers (starting from the left) are to be placed in reverse order. For example, suppose 214356789 is the starting posi-tion. Then \"reverse 2\" gives 124356789. \"Reverse 5\" gives 534126789. Write a Basic program to play Reverse with the computer.\n\nOptions:\nA. Analytical and descriptive\nB. Algorithmic and heuristic\nC.             Descriptive and heuristic\nD. Algorithmic and statistical\n\nAnswer: B\n\nReference Solution:\nThere are two approaches to the game - one algorithmic, and the other heuristic. The algorithmic solution guarantees a win in a certain number of moves (if there are N numbers, it takes 2N - 3 moves). The heuristic method takes advantage of the information at any moment to improve the strategy for minimizing the number of moves. The player decides which method to pursue. Here is the program for this game: 5PRINT \"REVERSE - A GAME OF SKILL\" 10DIM A (20) 20REMN = NUMBER OF NUMBERS 30N = 9 40REMMAKE A RANDOM LIST A (1) TO A (N) 50A (1) = INT ((N - 1) \\textasteriskcenteredRND (1) + 2) 60FOR K = 2 TO N 70A (K) = INT (N\\textasteriskcenteredRND (1) + 1) 80FOR J = 1 TO K - 1 90IF A (K) = A (J) THEN 70 100NEXT J 110NEXT K 120REM PRINT ORIGINAL LIST AND START GAME 130PRINT \"THE LIST IS:\" 140T = 0 150GOSUB 430 160PRINT \"HOW MANY TO BE REVERSED?\\textquotedblright 170INPUT R 180IF R = 0 THEN 370 190IF R < = N THEN 240 200REM THE COMPUTER CANNOT REVERSE MORE THAN 210REM N NUMBERS 220PRINT \"TOO MANY. I CAN REVERSE AT MOST\" ;N 230GOTO 160 240T = T + 1 250REM REVERSE R NUMBERS AND PRINT NEW LIST 260FOR K = 1 TO INT(R/2) 270Z = A (K) 280A (K) = A (R - K + 1) 290A (R - K + 1) = Z 300NEXT K 310GOSUB 430 320REM CHECK FOR A WIN 330FOR K = 1 TO N 340IF A(K) <> K THEN 160 350NEXT K 360PRINT \"YOU WON IT IN\"; T; \"MOVES!\" 370PRINT \"TRY AGAIN (YES OR NO)\"; 380INPUT A$ 390IF A$ = \"YES\" THEN 50 400PRINT \"GOOD GAME, THANKS.\" 410GOTO 470 420REM SUBROUTINE TO PRINT LIST 430FOR K = 1 TO N 440PRINT A (K) 450NEXT K 460RETURN 470END", "ref_id": 4738, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "A list of numbers (1 through 9) is given. The object is to arrange the numbers in ascending order. A move is made by specifying how many numbers (starting from the left) are to be placed in reverse order. For example, suppose 214356789 is the starting posi-tion. Then \"reverse 2\" gives 124356789. \"Reverse 5\" gives 534126789. Write a Basic program to play Reverse with the computer.", "options": ["Analytical and descriptive", "Algorithmic and heuristic", "Descriptive and heuristic", "Algorithmic and statistical"], "answer": "B", "solution": "There are two approaches to the game - one algorithmic, and the other heuristic. The algorithmic solution guarantees a win in a certain number of moves (if there are N numbers, it takes 2N - 3 moves). The heuristic method takes advantage of the information at any moment to improve the strategy for minimizing the number of moves. The player decides which method to pursue. Here is the program for this game: 5PRINT \"REVERSE - A GAME OF SKILL\" 10DIM A (20) 20REMN = NUMBER OF NUMBERS 30N = 9 40REMMAKE A RANDOM LIST A (1) TO A (N) 50A (1) = INT ((N - 1) \\textasteriskcenteredRND (1) + 2) 60FOR K = 2 TO N 70A (K) = INT (N\\textasteriskcenteredRND (1) + 1) 80FOR J = 1 TO K - 1 90IF A (K) = A (J) THEN 70 100NEXT J 110NEXT K 120REM PRINT ORIGINAL LIST AND START GAME 130PRINT \"THE LIST IS:\" 140T = 0 150GOSUB 430 160PRINT \"HOW MANY TO BE REVERSED?\\textquotedblright 170INPUT R 180IF R = 0 THEN 370 190IF R < = N THEN 240 200REM THE COMPUTER CANNOT REVERSE MORE THAN 210REM N NUMBERS 220PRINT \"TOO MANY. I CAN REVERSE AT MOST\" ;N 230GOTO 160 240T = T + 1 250REM REVERSE R NUMBERS AND PRINT NEW LIST 260FOR K = 1 TO INT(R/2) 270Z = A (K) 280A (K) = A (R - K + 1) 290A (R - K + 1) = Z 300NEXT K 310GOSUB 430 320REM CHECK FOR A WIN 330FOR K = 1 TO N 340IF A(K) <> K THEN 160 350NEXT K 360PRINT \"YOU WON IT IN\"; T; \"MOVES!\" 370PRINT \"TRY AGAIN (YES OR NO)\"; 380INPUT A$ 390IF A$ = \"YES\" THEN 50 400PRINT \"GOOD GAME, THANKS.\" 410GOTO 470 420REM SUBROUTINE TO PRINT LIST 430FOR K = 1 TO N 440PRINT A (K) 450NEXT K 460RETURN 470END"}, "question": "task_1"}}, {"data": {"text": "Question:\nAs we have seen in the previous problem, character strings in Pascal have fixed length. However, we treat a string as having a varying length if we ignore all trailing blanks. Consider, for example, the following implementation: CONST STRSIZE = 80; TYPE STRING = RECORD WORD: PACKED ARRAY [1. .STRSIZE] of CHAR; length: 1..strsize END; where the field length represents the position of the last non trailing-blank character. For example, the string 'HELLObbb... 'haslength 5 and 75 trailing blanks, and the string 'GOODbbbBYEbbbb....' has length and 70 trailing blanks . Assuming the above defini-tions, write PROCEDURE SUBSTRING (S1:STRING;var S2:string;p,n: integer); which copies the first n characters, starting with posi-tion p in the string S1 into string S2. For example, if S1='ABCDEFGHIJbbbb.....', then after substring (S1, S2, 4,3 )S2 becomes 'DEFbbb....'.\n\nOptions:\nA. PROCEDURE SUBSTRING (S1: string;varS2: string, p, n : integer); IF (P+N-1)>strsizethen Write1n ('ERROR-SUBSTRING is out of RANGE')\nB. PROCEDURE SUBSTRING (S1: string;varS2: string, p, n : integer); J: = 1;\nC.             PROCEDURE SUBSTRING (S1: string;varS2: string, p, n : integer); VAR I, J: integer; BEGIN IF (P+N-1)>strsizethen Write1n ('ERROR-SUBSTRING is out of RANGE') {checkto see if desired substring is within the first one} ELSE BEGIN J: = 1; {initial position of the second string} FOR I: = P to P + N - 1 DO {start copying with position p} BEGIN S2.W0RD[ J]: = S1.W0RD[I] J: = J +1; {increment position count for 2string} END;{all required characters copied, pad the rest of the string S2 with blanks) S2.length: = J - 1; FOR I:=J tostrsizeDO S2.W0RD[I]: '' END END;\nD. PROCEDURE SUBSTRING (S1: string;varS2: string, p, n : integer); S2.length: = J - 1;\n\nAnswer: C\n\nReference Solution:\nPROCEDURE SUBSTRING (S1: string;varS2: string, p, n : integer); VAR I, J: integer; BEGIN IF (P+N-1)>strsizethen Write1n ('ERROR-SUBSTRING is out of RANGE') {checkto see if desired substring is within the first one} ELSE BEGIN J: = 1; {initial position of the second string} FOR I: = P to P + N - 1 DO {start copying with position p} BEGIN S2.W0RD[ J]: = S1.W0RD[I] J: = J +1; {increment position count for 2string} END;{all required characters copied, pad the rest of the string S2 with blanks) S2.length: = J - 1; FOR I:=J tostrsizeDO S2.W0RD[I]: '' END END;", "ref_id": 4739, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "As we have seen in the previous problem, character strings in Pascal have fixed length. However, we treat a string as having a varying length if we ignore all trailing blanks. Consider, for example, the following implementation: CONST STRSIZE = 80; TYPE STRING = RECORD WORD: PACKED ARRAY [1. .STRSIZE] of CHAR; length: 1..strsize END; where the field length represents the position of the last non trailing-blank character. For example, the string 'HELLObbb... 'haslength 5 and 75 trailing blanks, and the string 'GOODbbbBYEbbbb....' has length and 70 trailing blanks . Assuming the above defini-tions, write PROCEDURE SUBSTRING (S1:STRING;var S2:string;p,n: integer); which copies the first n characters, starting with posi-tion p in the string S1 into string S2. For example, if S1='ABCDEFGHIJbbbb.....', then after substring (S1, S2, 4,3 )S2 becomes 'DEFbbb....'.", "options": ["PROCEDURE SUBSTRING (S1: string;varS2: string, p, n : integer); IF (P+N-1)>strsizethen Write1n ('ERROR-SUBSTRING is out of RANGE')", "PROCEDURE SUBSTRING (S1: string;varS2: string, p, n : integer); J: = 1;", "PROCEDURE SUBSTRING (S1: string;varS2: string, p, n : integer); VAR I, J: integer; BEGIN IF (P+N-1)>strsizethen Write1n ('ERROR-SUBSTRING is out of RANGE') {checkto see if desired substring is within the first one} ELSE BEGIN J: = 1; {initial position of the second string} FOR I: = P to P + N - 1 DO {start copying with position p} BEGIN S2.W0RD[ J]: = S1.W0RD[I] J: = J +1; {increment position count for 2string} END;{all required characters copied, pad the rest of the string S2 with blanks) S2.length: = J - 1; FOR I:=J tostrsizeDO S2.W0RD[I]: '' END END;", "PROCEDURE SUBSTRING (S1: string;varS2: string, p, n : integer); S2.length: = J - 1;"], "answer": "C", "solution": "PROCEDURE SUBSTRING (S1: string;varS2: string, p, n : integer); VAR I, J: integer; BEGIN IF (P+N-1)>strsizethen Write1n ('ERROR-SUBSTRING is out of RANGE') {checkto see if desired substring is within the first one} ELSE BEGIN J: = 1; {initial position of the second string} FOR I: = P to P + N - 1 DO {start copying with position p} BEGIN S2.W0RD[ J]: = S1.W0RD[I] J: = J +1; {increment position count for 2string} END;{all required characters copied, pad the rest of the string S2 with blanks) S2.length: = J - 1; FOR I:=J tostrsizeDO S2.W0RD[I]: '' END END;"}, "question": "task_1"}}, {"data": {"text": "Question:\nWrite a FORTRAN subroutine to determine the largest element (in absolute value) in theithrow of N \u00d7 N array called ARRAY.\n\nOptions:\nA. FUNCTION LARGE (ARRAY, N, I, BIG, J)\nB. SUBROUTINE BIG (ARRAY, N, I, LARGE, J)\nC.             SUBROUTINE SMALL (ARRAY, N, I, BIG, J)\nD. SUBROUTINE LARGE (ARRAY, N, I, BIG, J)\n\nAnswer: D\n\nReference Solution:\nLet the arguments of the subroutine be denoted by ARRAY, N, I, BIG, J. Here ARRAY stands for a square array whose dimensions are N \u00d7 N, I stands for the row in which we wish to determine the maximum element, denoted by BIG, is to be found and J stands for the column in which BIG is located. The only trick to the algorithm is to implement a sequential comparison of each element of theithrow to the largest preceding value. The subroutine looks as follows: SUBROUTINE LARGE (ARRAY, N, I, BIG, J) DIMENSION ARRAY (N, N) BIG = ABS (ARRAY (1, 1)) J = 1 DO 9 K = 2, N IF (ABS (ARRAY (I, K)) .LT.BIG) GO TO 9 CSET BIG TO THE NEW VALUE BIG = ABS (ARRAY (I,K)) CUPDATE THE COLUMN OF THE NEW BIG ELEMENT. J = K 9CONTINUE RETURN END", "ref_id": 4740, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Write a FORTRAN subroutine to determine the largest element (in absolute value) in theithrow of N \u00d7 N array called ARRAY.", "options": ["FUNCTION LARGE (ARRAY, N, I, BIG, J)", "SUBROUTINE BIG (ARRAY, N, I, LARGE, J)", "SUBROUTINE SMALL (ARRAY, N, I, BIG, J)", "SUBROUTINE LARGE (ARRAY, N, I, BIG, J)"], "answer": "D", "solution": "Let the arguments of the subroutine be denoted by ARRAY, N, I, BIG, J. Here ARRAY stands for a square array whose dimensions are N \u00d7 N, I stands for the row in which we wish to determine the maximum element, denoted by BIG, is to be found and J stands for the column in which BIG is located. The only trick to the algorithm is to implement a sequential comparison of each element of theithrow to the largest preceding value. The subroutine looks as follows: SUBROUTINE LARGE (ARRAY, N, I, BIG, J) DIMENSION ARRAY (N, N) BIG = ABS (ARRAY (1, 1)) J = 1 DO 9 K = 2, N IF (ABS (ARRAY (I, K)) .LT.BIG) GO TO 9 CSET BIG TO THE NEW VALUE BIG = ABS (ARRAY (I,K)) CUPDATE THE COLUMN OF THE NEW BIG ELEMENT. J = K 9CONTINUE RETURN END"}, "question": "task_1"}}, {"data": {"text": "Question:\nBriefly discuss the major functional unit of the Central Processing Unit (CPU).\n\nOptions:\nA. The CPU consists of three major functional units: Control Unit (CU), Arithmetic Control Unit (ALU), and Internal Storage Unit (ISU).\nB. The CPU consists of four major functional units: Control Unit (CU), Arithmetic Control Unit (ALU), Internal Storage Unit (ISU), and Cache Memory.\nC.             The CPU consists of one major functional unit: Control Unit (CU).\nD. The CPU consists of two major functional units: Control Unit (CU) and Arithmetic Control Unit (ALU).\n\nAnswer: A\n\nReference Solution:\nThe CPU (Central Processing Units), or simply PU or PE (Processing Element) since there may be multiple cooperating units, is the engine that executes the instructions (software). The conventional CPU, also referred to as the Von Neumann type processor is sequential. It fetches , decodes, and executes in-structions one at a time. Generally, the CPU (or simply the processor) consists of three major functional units: Control Unit (CU): Controls the fetch, decode, execute cycles for instructions stored in memory. Arithmetic Control Unit (ALU): Accomplishes arithmetic operations and logical comparisons of words of data (a word of data is as long as the length of register in bits). Internal Storage Unit (ISU): This is the fast internal memory, not to be confused with primary memory that is external to a processor chip, that temporarily stores and manipulates data. Typically, it consists of a well defined set of regis-ters. The registers hold small chunks of data (8 bits, 16 bits , 32 bits, 64 bits) to be manipulated. In addition, this unit contains the address and data busses, in a way analogous to highways, for data to move data to and from memory. Finally, this unit contains busses (a bunch of wires) for I/O, as when a signal needs to be sent to CPU (e.g. and I/O interrupt ) regard-ing the status of an attached I/O device (also referred to as peripheral).", "ref_id": 4741, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Briefly discuss the major functional unit of the Central Processing Unit (CPU).", "options": ["The CPU consists of three major functional units: Control Unit (CU), Arithmetic Control Unit (ALU), and Internal Storage Unit (ISU).", "The CPU consists of four major functional units: Control Unit (CU), Arithmetic Control Unit (ALU), Internal Storage Unit (ISU), and Cache Memory.", "The CPU consists of one major functional unit: Control Unit (CU).", "The CPU consists of two major functional units: Control Unit (CU) and Arithmetic Control Unit (ALU)."], "answer": "A", "solution": "The CPU (Central Processing Units), or simply PU or PE (Processing Element) since there may be multiple cooperating units, is the engine that executes the instructions (software). The conventional CPU, also referred to as the Von Neumann type processor is sequential. It fetches , decodes, and executes in-structions one at a time. Generally, the CPU (or simply the processor) consists of three major functional units: Control Unit (CU): Controls the fetch, decode, execute cycles for instructions stored in memory. Arithmetic Control Unit (ALU): Accomplishes arithmetic operations and logical comparisons of words of data (a word of data is as long as the length of register in bits). Internal Storage Unit (ISU): This is the fast internal memory, not to be confused with primary memory that is external to a processor chip, that temporarily stores and manipulates data. Typically, it consists of a well defined set of regis-ters. The registers hold small chunks of data (8 bits, 16 bits , 32 bits, 64 bits) to be manipulated. In addition, this unit contains the address and data busses, in a way analogous to highways, for data to move data to and from memory. Finally, this unit contains busses (a bunch of wires) for I/O, as when a signal needs to be sent to CPU (e.g. and I/O interrupt ) regard-ing the status of an attached I/O device (also referred to as peripheral)."}, "question": "task_1"}}, {"data": {"text": "Question:\nDescribe the usage of a standard computer terminal in terms of its keyboard for input and screen for output.\n\nOptions:\nA. The keyboard of a terminal consists of 50 keys and the screen is 60 columns by 30 lines.\nB. A typical keyboard of a terminal consists of about 100 keys and the screen typically is 80 columns by 24 lines. Keyboards come in three types: PC, ASCII and ANSI keyboards. The screen may be monochrome or color.\nC.             The screen of a terminal can only be monochrome.\nD. Keyboards come in two types: PC and ASCII keyboards.\n\nAnswer: B\n\nReference Solution:\nA typical keyboard of a terminal (or a monitor that is directly connected to the computer) consists of about 100 keys in a way analogous to typewriter keyboard. The keyboards, as of 1990s, come in three different types: a) PC keyboards. In addition to keys for typing letters and numbers, moving the cursor, and rolling the screen, these keyboards contain function keys that can be programmed to input a predetermined sequence of characters, b)ASCII keyboards. These are simpler keyboards and may not have function keys or may have function keys that are preprogrammed . c) ANSI keyboards. These keyboards do much the same thing as the ASCII keyboards, except that they must adhere to the ANSI standards for various control character and escape sequences (sequence of characters entered after an escape key) for changing the behavior of the terminal itself (e.g. reverse screen, blinking characters, etc). The screen typically is 80 columns by 24 lines. There may be a 25th line for displaying terminal status information or current function keys when the function keys are programmable by soft-ware. The screen may be monochrome (actually green or amber) or color. With colored terminals , the screen colors can be set for background (the main 80-by-24 or 80-by-25 area), borders (the area surrounding the main area), and foreground (the characters typed).", "ref_id": 4742, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Describe the usage of a standard computer terminal in terms of its keyboard for input and screen for output.", "options": ["The keyboard of a terminal consists of 50 keys and the screen is 60 columns by 30 lines.", "A typical keyboard of a terminal consists of about 100 keys and the screen typically is 80 columns by 24 lines. Keyboards come in three types: PC, ASCII and ANSI keyboards. The screen may be monochrome or color.", "The screen of a terminal can only be monochrome.", "Keyboards come in two types: PC and ASCII keyboards."], "answer": "B", "solution": "A typical keyboard of a terminal (or a monitor that is directly connected to the computer) consists of about 100 keys in a way analogous to typewriter keyboard. The keyboards, as of 1990s, come in three different types: a) PC keyboards. In addition to keys for typing letters and numbers, moving the cursor, and rolling the screen, these keyboards contain function keys that can be programmed to input a predetermined sequence of characters, b)ASCII keyboards. These are simpler keyboards and may not have function keys or may have function keys that are preprogrammed . c) ANSI keyboards. These keyboards do much the same thing as the ASCII keyboards, except that they must adhere to the ANSI standards for various control character and escape sequences (sequence of characters entered after an escape key) for changing the behavior of the terminal itself (e.g. reverse screen, blinking characters, etc). The screen typically is 80 columns by 24 lines. There may be a 25th line for displaying terminal status information or current function keys when the function keys are programmable by soft-ware. The screen may be monochrome (actually green or amber) or color. With colored terminals , the screen colors can be set for background (the main 80-by-24 or 80-by-25 area), borders (the area surrounding the main area), and foreground (the characters typed)."}, "question": "task_1"}}, {"data": {"text": "Question:\nWhat is recursion? WhydoesPL/I have a recursive procedurewhile FORTRAN does not?\n\nOptions:\nA. Recursion is a data structure\nB. Recursion is a procedure that invokes itself\nC.             Recursion is a programming language\nD. Recursion is a type of loop\n\nAnswer: B\n\nReference Solution:\nIn pure mathematics, the Fibonacci sequence is a recursive procedure. If you recall, Fibonacci numbers are generated by using prcedingnumbers to continue the sequence. For example, F_0 = 0 F_1 = 1 F_n = F_n - _1 + F_n - _2 for n = 2,3,... isthe method for obtaining Fibonacci numbers. In computer science, recursion takes on a slightly dif-ferent meaning. We may want, in the course of a program, a certain procedure to invokeitself by means of a CALL state-ment. By repeating the calling procedure, you are actually reducing the size of the program. For example, in this PL/I code segment, we want to store values in the array VALUE.We are assuming that we are filling the array from top to bottom bydecrementing the variable KOUNT. When KOUNT is 0, we want to terminate. STORAGE:PROC RECURSIVE IF KOUNT> = 1. THEN DO; VALUE(KOUNT) = INDEX; KOUNT=KOUNT - 1; CALL STORAGE; END; END STORAGE; In this procedure, each stage of processing contains all subsequent stages, i.e., the first stage is incomplete until the final stage has been completed. Using recursion, one can streamline the code, cutting down on repeatedlines of information. At the machine level, recursive procedures mustsave their addresses for subsequent invocations. This is generally accomplishedby a stacking procedure, in which addresses are pushed ontothe stack after an invocation and popped up each time the procedure isin-voked again. There is a danger when using recursive procedures, the danger beingrelated to the saving of machine addresses. Each time a procedure isinvoked recursively, the memory space used to save the addresses containsall of the previous information from the other invocations. If a recursivepro-cedure is not terminated correctly, the memory block will grow indefinitely, consuming valuable space in the machine.", "ref_id": 4743, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "What is recursion? WhydoesPL/I have a recursive procedurewhile FORTRAN does not?", "options": ["Recursion is a data structure", "Recursion is a procedure that invokes itself", "Recursion is a programming language", "Recursion is a type of loop"], "answer": "B", "solution": "In pure mathematics, the Fibonacci sequence is a recursive procedure. If you recall, Fibonacci numbers are generated by using prcedingnumbers to continue the sequence. For example, F_0 = 0 F_1 = 1 F_n = F_n - _1 + F_n - _2 for n = 2,3,... isthe method for obtaining Fibonacci numbers. In computer science, recursion takes on a slightly dif-ferent meaning. We may want, in the course of a program, a certain procedure to invokeitself by means of a CALL state-ment. By repeating the calling procedure, you are actually reducing the size of the program. For example, in this PL/I code segment, we want to store values in the array VALUE.We are assuming that we are filling the array from top to bottom bydecrementing the variable KOUNT. When KOUNT is 0, we want to terminate. STORAGE:PROC RECURSIVE IF KOUNT> = 1. THEN DO; VALUE(KOUNT) = INDEX; KOUNT=KOUNT - 1; CALL STORAGE; END; END STORAGE; In this procedure, each stage of processing contains all subsequent stages, i.e., the first stage is incomplete until the final stage has been completed. Using recursion, one can streamline the code, cutting down on repeatedlines of information. At the machine level, recursive procedures mustsave their addresses for subsequent invocations. This is generally accomplishedby a stacking procedure, in which addresses are pushed ontothe stack after an invocation and popped up each time the procedure isin-voked again. There is a danger when using recursive procedures, the danger beingrelated to the saving of machine addresses. Each time a procedure isinvoked recursively, the memory space used to save the addresses containsall of the previous information from the other invocations. If a recursivepro-cedure is not terminated correctly, the memory block will grow indefinitely, consuming valuable space in the machine."}, "question": "task_1"}}, {"data": {"text": "Question:\nFor the following PL/I program, CONDITION' arises. b) Show what will be printed out if the program is run. c) Write a corrected program to avoid errors due to this condition. d) Show what the print out will be from the corrected program . EXAMPLE:PROCOPTIONS(MAIN); DCL (B(6),C) CHAR(4), Z FIXED (2); GET LIST (Z,C); DO I=1 TO Z; B(I)=SUBSTR(C,1,I); PUTLIST(I,B(I)); END; END EXAMPLE; The DATA CARD holds data as follows:6,ROVE.\n\nOptions:\nA. SYNTAX ERROR\nB. NULL POINTER EXCEPTION\nC.             STRINGRANGE CONDITION\nD. ARRAY OUT OF BOUNDS\n\nAnswer: C\n\nReference Solution:\na) The purpose of the above program is to illus-trate a type of conditionknown as 'STRINGRANGE CONDITION'. In the program, the array B is declared as having 6ele-ments . The GET LIST statement gets the value of Z from the DATA CARD asZ = 6. Also, the value of C is obtained from the DATA CARD as C = 'ROVE'. In the next statement, viz., DO I = 1 TO Z, the value of Z = 6 gets substituted. Hence, the DO loop statement becomes DO I = 1 TO 6;. This means that the DO loop will be performed 6 times. Each time., thevalue of an array element B(I) is calculated. This value ofB(I) = SUBSTR(C,1,I) means that from C, i.e., from 'ROVE', starting from the first character, select I characters. These selectedI characters are to be assigned to B(I). Thus, for example, if 1 = 2, then SUBSTR(C,1,2) gives B (2) = 'RO'. In the given program, as Z = 6, the loop will be perform-ed 6 times. But, during the 5th loop, on substituting values ofIand C in the equation: B(I) = SUBSTR(C,1,I) , gives: B(5) = SUBSTR ('ROVE',1,5). The above statement tries to find a substring of 'ROVE', starting fromthe first character up to (and including) the fifth character. However, 'ROVE' has only 4 characters. Hence, the computer will just print the available characters. The programmermust be informed. Hence, the computer is pro-grammed to printout a message stating that the STRINGRANGE CONDITION had occurredin a certain program statement of the program. b) The printout of the program will be as follows: 1'R ' 2'RO ' 3'ROV ' 4'ROVE ' 5'ROVE ' 6'ROVE ' c) The program can be corrected as follows: The computer must be told thatit must look out for the STRINGRANGE CON-DITION. This is done by usinga word within parentheses, viz., (STRINGRANGE):, as a prefix to thefirst program state-ment, as shown below. Also, in the body of the program, a statement such as:. On STRINGRANGE GOTO .....,must be in-cluded. A good place for inserting this statement is just after the DCL statementso that the computer reads it be-fore it enters the loop. The corrected program can now be written as shown below: (STRINGRANGE) :EXAMPLE:PROC OPTIONS(MAIN); DCL(B(6),C) CHAR(4), Z FIXED(2) ; ON STRINGRANGEB(I) = '0000' ; GETLIST(Z ,C) ; DO I = 1 TO Z; B (I) = SUBSTR(C, 1,I) ; PUTLIST(I,B(I)); END; FINISH:END EXAMPLE; In the above program the program is made to go to the FINISH label, whichis the end of the program when the STRINGRANGE CONDITION arises. But as a matter of fact any valid instruc-tion could be given to the computerinstead of the 'GOTO FINISH' instruction. d) The print-out of the corrected program is as follows: 1'R ' 2'RO ' 3'ROV ' 4'ROVE ' 5'0000 ' 6'0000 ' The computer will also print out a STRINGRANGE CONDITION mes-sage. It is assumed that the user of the program knows that whenever '0000' is printedout it means that a STRINGRANGE CONDITION has occurred at that stage.", "ref_id": 4744, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "For the following PL/I program, CONDITION' arises. b) Show what will be printed out if the program is run. c) Write a corrected program to avoid errors due to this condition. d) Show what the print out will be from the corrected program . EXAMPLE:PROCOPTIONS(MAIN); DCL (B(6),C) CHAR(4), Z FIXED (2); GET LIST (Z,C); DO I=1 TO Z; B(I)=SUBSTR(C,1,I); PUTLIST(I,B(I)); END; END EXAMPLE; The DATA CARD holds data as follows:6,ROVE.", "options": ["SYNTAX ERROR", "NULL POINTER EXCEPTION", "STRINGRANGE CONDITION", "ARRAY OUT OF BOUNDS"], "answer": "C", "solution": "a) The purpose of the above program is to illus-trate a type of conditionknown as 'STRINGRANGE CONDITION'. In the program, the array B is declared as having 6ele-ments . The GET LIST statement gets the value of Z from the DATA CARD asZ = 6. Also, the value of C is obtained from the DATA CARD as C = 'ROVE'. In the next statement, viz., DO I = 1 TO Z, the value of Z = 6 gets substituted. Hence, the DO loop statement becomes DO I = 1 TO 6;. This means that the DO loop will be performed 6 times. Each time., thevalue of an array element B(I) is calculated. This value ofB(I) = SUBSTR(C,1,I) means that from C, i.e., from 'ROVE', starting from the first character, select I characters. These selectedI characters are to be assigned to B(I). Thus, for example, if 1 = 2, then SUBSTR(C,1,2) gives B (2) = 'RO'. In the given program, as Z = 6, the loop will be perform-ed 6 times. But, during the 5th loop, on substituting values ofIand C in the equation: B(I) = SUBSTR(C,1,I) , gives: B(5) = SUBSTR ('ROVE',1,5). The above statement tries to find a substring of 'ROVE', starting fromthe first character up to (and including) the fifth character. However, 'ROVE' has only 4 characters. Hence, the computer will just print the available characters. The programmermust be informed. Hence, the computer is pro-grammed to printout a message stating that the STRINGRANGE CONDITION had occurredin a certain program statement of the program. b) The printout of the program will be as follows: 1'R ' 2'RO ' 3'ROV ' 4'ROVE ' 5'ROVE ' 6'ROVE ' c) The program can be corrected as follows: The computer must be told thatit must look out for the STRINGRANGE CON-DITION. This is done by usinga word within parentheses, viz., (STRINGRANGE):, as a prefix to thefirst program state-ment, as shown below. Also, in the body of the program, a statement such as:. On STRINGRANGE GOTO .....,must be in-cluded. A good place for inserting this statement is just after the DCL statementso that the computer reads it be-fore it enters the loop. The corrected program can now be written as shown below: (STRINGRANGE) :EXAMPLE:PROC OPTIONS(MAIN); DCL(B(6),C) CHAR(4), Z FIXED(2) ; ON STRINGRANGEB(I) = '0000' ; GETLIST(Z ,C) ; DO I = 1 TO Z; B (I) = SUBSTR(C, 1,I) ; PUTLIST(I,B(I)); END; FINISH:END EXAMPLE; In the above program the program is made to go to the FINISH label, whichis the end of the program when the STRINGRANGE CONDITION arises. But as a matter of fact any valid instruc-tion could be given to the computerinstead of the 'GOTO FINISH' instruction. d) The print-out of the corrected program is as follows: 1'R ' 2'RO ' 3'ROV ' 4'ROVE ' 5'0000 ' 6'0000 ' The computer will also print out a STRINGRANGE CONDITION mes-sage. It is assumed that the user of the program knows that whenever '0000' is printedout it means that a STRINGRANGE CONDITION has occurred at that stage."}, "question": "task_1"}}, {"data": {"text": "Question:\nExplain what a procedure is, and whatare the different types ofprocedures.\n\nOptions:\nA. A procedure is a set of instructions in a cooking recipe.\nB. A procedure is a sequence of steps in a dance routine.\nC.             A procedure is a set of calculations or expressions often executed in a program. Types include internal, external, function, and subroutine procedures.\nD. A procedure is a series of actions conducted in a science experiment.\n\nAnswer: C\n\nReference Solution:\nIf a certain set of calculations or a certain set of expressions to be executedoccur often in a program, it becomes convenient to use a procedurefor the given set. PL/Iprovidesthis very important facility. A procedure that is contained in some other procedure is called an iternalprocedure and a procedure that is not included within another procedureis said to be an external procedure. A reference in the program to the name of a procedure is called a procedure-reference. A procedure can be a function procedure or a subroutine procedure. A function procedure is like a built-in function and initiates an evaluationof the .procedure. The result value produced will be used for furthercalculations in the pro-gram.", "ref_id": 4745, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Explain what a procedure is, and whatare the different types ofprocedures.", "options": ["A procedure is a set of instructions in a cooking recipe.", "A procedure is a sequence of steps in a dance routine.", "A procedure is a set of calculations or expressions often executed in a program. Types include internal, external, function, and subroutine procedures.", "A procedure is a series of actions conducted in a science experiment."], "answer": "C", "solution": "If a certain set of calculations or a certain set of expressions to be executedoccur often in a program, it becomes convenient to use a procedurefor the given set. PL/Iprovidesthis very important facility. A procedure that is contained in some other procedure is called an iternalprocedure and a procedure that is not included within another procedureis said to be an external procedure. A reference in the program to the name of a procedure is called a procedure-reference. A procedure can be a function procedure or a subroutine procedure. A function procedure is like a built-in function and initiates an evaluationof the .procedure. The result value produced will be used for furthercalculations in the pro-gram."}, "question": "task_1"}}, {"data": {"text": "Question:\nA) ProgramB) Heuristic programmingC) Time sharing D) Computer languageE) Data processing\n\nOptions:\nA. Program: A tool for controlling computer hardware. Heuristic programming: A strategy for developing software. Time sharing: A strategy for managing computer resources. Computer language: A system of symbols and rules used to write programs. Data processing: A method for converting raw data into meaningful information.\nB. Program: A series of operations carried out by a computer. Heuristic programming: A technique for creating efficient algorithms. Time sharing: A method for multitasking on a single computer. Computer language: A language used to write computer programs. Data processing: A process for transforming data into useful information.\nC.             Program: A list of tasks for a user to follow. Heuristic programming: A method for solving complex problems. Time sharing: A method for dividing computer resources. Computer language: A tool for communicating with computers. Data processing: A process for organizing and analyzing data.\nD. Program: A set of instructions telling the computer what to do. Heuristic programming: Short-cut approximate solutions to intractable problems. Time sharing: Multiple users and their programs share the CPU by taking turns at quick time intervals. Computer language: A language that computer understands. Data processing: Manipulation of data to achieve a desired and useful result.\n\nAnswer: D\n\nReference Solution:\nA)Program: A set of instructions telling the computer what to do. When the program is written in an HLL (High Level Language) such as Pascal or COBOL, the instructions are referred to as statements. B) Heuristic programming: The term \"heuristic\" refers to short-cut approximate solutions to problems that are otherwise very difficult to solve (e.g. intractable) . Heuristic program-ming may be used in Artificial Intelligence software in order to guide the computer toward a practical (common sense) solution to a given problem orsubproblem. C) Time sharing: The best way to understand the concept of time sharing is to contrast it with multiprogramming. Multipro-gramming allows multiple programs that are ready for execution to reside in primary memory. While one program is doing some-thing unrelated to CPU, such as input-output, another one can run on CPU doing computations. This way, I/O activity involving slower devices is overlapped by computations involving fast CPU in order to increase the utilization of resources. Typically, a program (defined as a process by the operating system) is sus-pended whenever it needs to do I/O, and the CPU is assigned to another program. After finishing I/O, the suspended program is again readied for CPU assignment. Timesharing requires multiprogramming and not vice versa. In time sharing, in addition to multiprogramming where a process is suspended upon, say I/O request; each process (program) is regularly suspended after its time quantum (in milliseconds) expires. The purpose is to let multiple users and their programs to share the CPU by taking turns at quick time intervals (usu-ally in round robin fashion). Although the CPU can do only one thing at a time (e.g. can run one program at a time), the users feel as if they are simultaneously using the CPU. This idea is sometimes referred to as \"virtual machines,\" where if there are ten users on a fast CPU, each feels as if he/she is using a machine ten times as slow (on the average, of course!). D) Computer language : A language that computer understands as opposed to natural language that homo sapiens can understand. These languages come in families belonging to various hierarchi-cal levels. From bottom to top, the hierarchy looks like: Ma-chine languages, Assembly languages, High-level languages, and Very high-level languages. E) Data processing : Data processing involves manipulation of data that represents facts, events, actions, or concepts in order to achieve a desired and useful result in terms of new data. Although not essential, data processing makes a heavy use of computer systems.", "ref_id": 4746, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "A) ProgramB) Heuristic programmingC) Time sharing D) Computer languageE) Data processing", "options": ["Program: A tool for controlling computer hardware. Heuristic programming: A strategy for developing software. Time sharing: A strategy for managing computer resources. Computer language: A system of symbols and rules used to write programs. Data processing: A method for converting raw data into meaningful information.", "Program: A series of operations carried out by a computer. Heuristic programming: A technique for creating efficient algorithms. Time sharing: A method for multitasking on a single computer. Computer language: A language used to write computer programs. Data processing: A process for transforming data into useful information.", "Program: A list of tasks for a user to follow. Heuristic programming: A method for solving complex problems. Time sharing: A method for dividing computer resources. Computer language: A tool for communicating with computers. Data processing: A process for organizing and analyzing data.", "Program: A set of instructions telling the computer what to do. Heuristic programming: Short-cut approximate solutions to intractable problems. Time sharing: Multiple users and their programs share the CPU by taking turns at quick time intervals. Computer language: A language that computer understands. Data processing: Manipulation of data to achieve a desired and useful result."], "answer": "D", "solution": "A)Program: A set of instructions telling the computer what to do. When the program is written in an HLL (High Level Language) such as Pascal or COBOL, the instructions are referred to as statements. B) Heuristic programming: The term \"heuristic\" refers to short-cut approximate solutions to problems that are otherwise very difficult to solve (e.g. intractable) . Heuristic program-ming may be used in Artificial Intelligence software in order to guide the computer toward a practical (common sense) solution to a given problem orsubproblem. C) Time sharing: The best way to understand the concept of time sharing is to contrast it with multiprogramming. Multipro-gramming allows multiple programs that are ready for execution to reside in primary memory. While one program is doing some-thing unrelated to CPU, such as input-output, another one can run on CPU doing computations. This way, I/O activity involving slower devices is overlapped by computations involving fast CPU in order to increase the utilization of resources. Typically, a program (defined as a process by the operating system) is sus-pended whenever it needs to do I/O, and the CPU is assigned to another program. After finishing I/O, the suspended program is again readied for CPU assignment. Timesharing requires multiprogramming and not vice versa. In time sharing, in addition to multiprogramming where a process is suspended upon, say I/O request; each process (program) is regularly suspended after its time quantum (in milliseconds) expires. The purpose is to let multiple users and their programs to share the CPU by taking turns at quick time intervals (usu-ally in round robin fashion). Although the CPU can do only one thing at a time (e.g. can run one program at a time), the users feel as if they are simultaneously using the CPU. This idea is sometimes referred to as \"virtual machines,\" where if there are ten users on a fast CPU, each feels as if he/she is using a machine ten times as slow (on the average, of course!). D) Computer language : A language that computer understands as opposed to natural language that homo sapiens can understand. These languages come in families belonging to various hierarchi-cal levels. From bottom to top, the hierarchy looks like: Ma-chine languages, Assembly languages, High-level languages, and Very high-level languages. E) Data processing : Data processing involves manipulation of data that represents facts, events, actions, or concepts in order to achieve a desired and useful result in terms of new data. Although not essential, data processing makes a heavy use of computer systems."}, "question": "task_1"}}, {"data": {"text": "Question:\nExplain the difference between truncation and rounding. How can one operation be made to perform the function of the other?\n\nOptions:\nA. Multiply by .5 before truncation\nB. Subtract .5 from every number before rounding\nC.             Add .5 to every number to be rounded before truncation, or subtract .5 from every number to be truncated before rounding\nD. Add 1 to every number before truncation\n\nAnswer: C\n\nReference Solution:\nConsider the real number 5.6158 whose integer part is 5 and fractional part is .6158. This number can be converted into a whole number (integer) in one of two ways. First, the fractional part can be chopped off to give 5, and this is called truncation. Second, the integer whose value is closest to 5.6158 is 6, and this process is known as rounding. Suppose the computer is capable of truncation only. How can we accomplish rounding? Just add .5 to every number to be rounded before the truncation. The truncated increased value will be equal to rounded initial value. For example: 5.6158 ROUNDED= 6 5.6158 + .5000 = 6.1158 TRUNCATED = 6 Suppose the computer is capable of rounding only, and we need to truncate. In that case, simply subtract .5 from every number to be truncated before the rounding. The rounded de-creased value will be equal to truncated initial value. For example: 5.6158 TRUNCATED = 5 5.6158 - .5000 = 5.1158 ROUNDED = 5", "ref_id": 4747, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Explain the difference between truncation and rounding. How can one operation be made to perform the function of the other?", "options": ["Multiply by .5 before truncation", "Subtract .5 from every number before rounding", "Add .5 to every number to be rounded before truncation, or subtract .5 from every number to be truncated before rounding", "Add 1 to every number before truncation"], "answer": "C", "solution": "Consider the real number 5.6158 whose integer part is 5 and fractional part is .6158. This number can be converted into a whole number (integer) in one of two ways. First, the fractional part can be chopped off to give 5, and this is called truncation. Second, the integer whose value is closest to 5.6158 is 6, and this process is known as rounding. Suppose the computer is capable of truncation only. How can we accomplish rounding? Just add .5 to every number to be rounded before the truncation. The truncated increased value will be equal to rounded initial value. For example: 5.6158 ROUNDED= 6 5.6158 + .5000 = 6.1158 TRUNCATED = 6 Suppose the computer is capable of rounding only, and we need to truncate. In that case, simply subtract .5 from every number to be truncated before the rounding. The rounded de-creased value will be equal to truncated initial value. For example: 5.6158 TRUNCATED = 5 5.6158 - .5000 = 5.1158 ROUNDED = 5"}, "question": "task_1"}}, {"data": {"text": "Question:\nstore the product in Y.\n\nOptions:\nA. The scalar product of vector A by scalar D is stored in Y\nB. The length of a scalar is stored in Y\nC.             The sum of vector A and vector B is stored in Y\nD. The scalar product of vector A by scalar D is stored in X\n\nAnswer: A\n\nReference Solution:\nFirst remember that the sum of two vectors is obtained by A + B = (A_1 + B_1 , A_2 + B_2,....,A_N + B_N), where N is the total number of vector elements. The scalar (or dot) product of vector A by scalar D is D\\bulletA = (DA_1, DA_2, DA_3,...,DA_N). Finally, the length of a scalar is written as \\vertA \\vert =\\surd(A^2_1 + A^2_2 + A^2_3 + .....+A^2_N). All three calculations can be made in one program segment: CFIND VECTOR SUM, SCALAR PRODUCT, SCALAR NORM ALENG =0.0 DO 20 I = 1,N X(I) = A(I) + B(I) Y(I) = D\\textasteriskcenteredA(I) ALENG = ALENG + A(I)\\textasteriskcentered\\textasteriskcentered2 20CONTINUE ALENG = SQRT (ALENG) WRITE (5,100) X(I),Y(I),ALENG 100FORMAT (1X,'VECTOR SUM =', F10.4, 'SCALAR PRODUCT =', Note that N should be defined in the program before the above segment occurs.", "ref_id": 4748, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "store the product in Y.", "options": ["The scalar product of vector A by scalar D is stored in Y", "The length of a scalar is stored in Y", "The sum of vector A and vector B is stored in Y", "The scalar product of vector A by scalar D is stored in X"], "answer": "A", "solution": "First remember that the sum of two vectors is obtained by A + B = (A_1 + B_1 , A_2 + B_2,....,A_N + B_N), where N is the total number of vector elements. The scalar (or dot) product of vector A by scalar D is D\\bulletA = (DA_1, DA_2, DA_3,...,DA_N). Finally, the length of a scalar is written as \\vertA \\vert =\\surd(A^2_1 + A^2_2 + A^2_3 + .....+A^2_N). All three calculations can be made in one program segment: CFIND VECTOR SUM, SCALAR PRODUCT, SCALAR NORM ALENG =0.0 DO 20 I = 1,N X(I) = A(I) + B(I) Y(I) = D\\textasteriskcenteredA(I) ALENG = ALENG + A(I)\\textasteriskcentered\\textasteriskcentered2 20CONTINUE ALENG = SQRT (ALENG) WRITE (5,100) X(I),Y(I),ALENG 100FORMAT (1X,'VECTOR SUM =', F10.4, 'SCALAR PRODUCT =', Note that N should be defined in the program before the above segment occurs."}, "question": "task_1"}}, {"data": {"text": "Question:\nArray A contains all odd integers from 1 to 100 (e.g. 1,3,5,7,.......99) in random order, and is declared as follows : TYPEARRAYTYPE = ARRAY [1..50] of integer; VARA :ARRAYTYPE; Write a short procedure that will accept A and return an array with the same elements in sorted, increasing order.\n\nOptions:\nA. PROCEDURE SORT (A: ARRAYTYPE; VAR B:ARRAYTYPE ); VARi, X:integer ; BEGIN FORi: =1 to 50 DO BEGIN X: = A [i] div 2 + 1; B[x]: = A[i] END END\nB. PROCEDURE SORT (A: ARRAYTYPE; VAR B:ARRAYTYPE ); VARi, X:integer ; BEGIN FORi: =1 to 50 DO BEGIN X: = A [i] + 2 ; B[x]: = A[i] END END\nC.             PROCEDURE SORT (A: ARRAYTYPE; VAR B:ARRAYTYPE ); VARi, X:integer ; BEGIN FORi: =1 to 50 DO BEGIN X: = A [i] div 2 - 1; B[x]: = A[i] END END\nD. FORi: =1 to 50 DO BEGIN X: = A [i] * 2 + 1; B[x]: = A[i] END\n\nAnswer: A\n\nReference Solution:\nThe key here is to recognize the relationship be-tween the indices and the elements of the array. Thus, given an element e, we can compute its correct place in the array - let's call it X, from the following formula: X: = ediv 2 + 1; This is, then, the procedure: PROCEDURE SORT (A: ARRAYTYPE; VAR B:ARRAYTYPE ); VARi, X:integer ; BEGIN FORi: =1 to 50 DO BEGIN X: = A [i] div 2 + 1; B[x]: = A[i] END END; Let's simulate this procedure for an Array of 5 elements con-taining odd integers from 1 to 10 in random order: A 7 9 3 5 1 Wheni= 1,x= A[1] div 2 + 1 = 7 div 2 + 1 = 4. B[4]: = A [1] = 7 The array B now looks: 7 at step 2 ,i= 2, x = A[2] div 2 + 1 = 5 B[ 5]: = 9.Array B now looks: 7 9 At step 3,i= 3, x = 3 div 2 + 1 = 2 B[ 2] : = 3 3 7 9 Fori=4, x=5 div 2+1 = 3 B[ 3] : 5 3 5 7 9 Finally , fori= 5, x = 1 div 2 + 1 = 1 B[ 1] : = 1.Now array B is in sorted increasing order: 1 3 5 7 9 The procedure works exactly like this for larger numbers.", "ref_id": 4749, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Array A contains all odd integers from 1 to 100 (e.g. 1,3,5,7,.......99) in random order, and is declared as follows : TYPEARRAYTYPE = ARRAY [1..50] of integer; VARA :ARRAYTYPE; Write a short procedure that will accept A and return an array with the same elements in sorted, increasing order.", "options": ["PROCEDURE SORT (A: ARRAYTYPE; VAR B:ARRAYTYPE ); VARi, X:integer ; BEGIN FORi: =1 to 50 DO BEGIN X: = A [i] div 2 + 1; B[x]: = A[i] END END", "PROCEDURE SORT (A: ARRAYTYPE; VAR B:ARRAYTYPE ); VARi, X:integer ; BEGIN FORi: =1 to 50 DO BEGIN X: = A [i] + 2 ; B[x]: = A[i] END END", "PROCEDURE SORT (A: ARRAYTYPE; VAR B:ARRAYTYPE ); VARi, X:integer ; BEGIN FORi: =1 to 50 DO BEGIN X: = A [i] div 2 - 1; B[x]: = A[i] END END", "FORi: =1 to 50 DO BEGIN X: = A [i] * 2 + 1; B[x]: = A[i] END"], "answer": "A", "solution": "The key here is to recognize the relationship be-tween the indices and the elements of the array. Thus, given an element e, we can compute its correct place in the array - let's call it X, from the following formula: X: = ediv 2 + 1; This is, then, the procedure: PROCEDURE SORT (A: ARRAYTYPE; VAR B:ARRAYTYPE ); VARi, X:integer ; BEGIN FORi: =1 to 50 DO BEGIN X: = A [i] div 2 + 1; B[x]: = A[i] END END; Let's simulate this procedure for an Array of 5 elements con-taining odd integers from 1 to 10 in random order: A 7 9 3 5 1 Wheni= 1,x= A[1] div 2 + 1 = 7 div 2 + 1 = 4. B[4]: = A [1] = 7 The array B now looks: 7 at step 2 ,i= 2, x = A[2] div 2 + 1 = 5 B[ 5]: = 9.Array B now looks: 7 9 At step 3,i= 3, x = 3 div 2 + 1 = 2 B[ 2] : = 3 3 7 9 Fori=4, x=5 div 2+1 = 3 B[ 3] : 5 3 5 7 9 Finally , fori= 5, x = 1 div 2 + 1 = 1 B[ 1] : = 1.Now array B is in sorted increasing order: 1 3 5 7 9 The procedure works exactly like this for larger numbers."}, "question": "task_1"}}, {"data": {"text": "Question:\nA building society lends money to house purchasers subject to a monthly payment of one per cent of the amount borrowed . This payment covers both capital repayment and interest due, interest being charged at a rate of eight percent per annum, calculated monthly. Write a program which reads in the amount of a loan, tabulates the series of payments required, as a four column table showing the payment number, the interest.duethat month, the capital repayment that month, and the outstanding capital balance. The table should also show the final non-standard payment required to complete the payment.\n\nOptions:\nA. PROGRAM MONTHLYPAYMENT\nB. PROGRAM INTERESTCALCULATION\nC.             PROGRAM LOANPAYMENT\nD. PROGRAM LOANREPAYMENT\n\nAnswer: C\n\nReference Solution:\nPROGRAM LOANPAYMENT (INPUT, OUTPUT); (\\textasteriskcentered This program reads in the amount of a loan \\textasteriskcentered) (\\textasteriskcentered and prints the repayment table showing \\textasteriskcentered) (\\textasteriskcentered the payment number, the monthly interest, \\textasteriskcentered) (\\textasteriskcentered the interest repayment, and the residual \\textasteriskcentered) (\\textasteriskcentered balance. \\textasteriskcentered) CONST ANNUALRATE =8;(\\textasteriskcentered per cent \\textasteriskcentered) VARNUMBER :1 . . MAXINT; INTEREST, REPAYMENT, LOAN, PAYMENT, RESIDUE, MONTHRATE:REAL; BEGIN READ (LOAN); WRITE ('AMOUNT BORROWED =' ,LOAN: 12:2); PAYMENT: = LOAN/100; WRITELN (' ':10, 'MONTHLY REPAYMENT =', PAYMENT:10:2); WRITELN; WRITELN; WRITELN ('NUMBER INTEREST REPAYMENT RESIDUE'); WRITELN; MONTHRATE: =ANNUALRATE/100/12; NUMBER: = 1; RESIDUE: = LOAN; REPEAT INTEREST: = MONTHRATE\\textasteriskcenteredRESI DUE; REPAYMENT: = PAYMENT - INTEREST; RESIDUE: = RESIDUE - REPAYMENT; WRITELN (NUMBER: 7, INTEREST: 10:2, REPAYMENT; 10:2, RESIDUE:10:2 ); NUMBER: = NUMBER +1 UNTIL RESIDUE+RESI DUE \\textasteriskcenteredMONTHR ATE <= PAYMENT; WRITELN; WRITELN; WRITELN ('LAST PAYMENT=', RESIDUE+RESIDUE \\textasteriskcenteredMONTHRATE: 10:2) END.", "ref_id": 4750, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "A building society lends money to house purchasers subject to a monthly payment of one per cent of the amount borrowed . This payment covers both capital repayment and interest due, interest being charged at a rate of eight percent per annum, calculated monthly. Write a program which reads in the amount of a loan, tabulates the series of payments required, as a four column table showing the payment number, the interest.duethat month, the capital repayment that month, and the outstanding capital balance. The table should also show the final non-standard payment required to complete the payment.", "options": ["PROGRAM MONTHLYPAYMENT", "PROGRAM INTERESTCALCULATION", "PROGRAM LOANPAYMENT", "PROGRAM LOANREPAYMENT"], "answer": "C", "solution": "PROGRAM LOANPAYMENT (INPUT, OUTPUT); (\\textasteriskcentered This program reads in the amount of a loan \\textasteriskcentered) (\\textasteriskcentered and prints the repayment table showing \\textasteriskcentered) (\\textasteriskcentered the payment number, the monthly interest, \\textasteriskcentered) (\\textasteriskcentered the interest repayment, and the residual \\textasteriskcentered) (\\textasteriskcentered balance. \\textasteriskcentered) CONST ANNUALRATE =8;(\\textasteriskcentered per cent \\textasteriskcentered) VARNUMBER :1 . . MAXINT; INTEREST, REPAYMENT, LOAN, PAYMENT, RESIDUE, MONTHRATE:REAL; BEGIN READ (LOAN); WRITE ('AMOUNT BORROWED =' ,LOAN: 12:2); PAYMENT: = LOAN/100; WRITELN (' ':10, 'MONTHLY REPAYMENT =', PAYMENT:10:2); WRITELN; WRITELN; WRITELN ('NUMBER INTEREST REPAYMENT RESIDUE'); WRITELN; MONTHRATE: =ANNUALRATE/100/12; NUMBER: = 1; RESIDUE: = LOAN; REPEAT INTEREST: = MONTHRATE\\textasteriskcenteredRESI DUE; REPAYMENT: = PAYMENT - INTEREST; RESIDUE: = RESIDUE - REPAYMENT; WRITELN (NUMBER: 7, INTEREST: 10:2, REPAYMENT; 10:2, RESIDUE:10:2 ); NUMBER: = NUMBER +1 UNTIL RESIDUE+RESI DUE \\textasteriskcenteredMONTHR ATE <= PAYMENT; WRITELN; WRITELN; WRITELN ('LAST PAYMENT=', RESIDUE+RESIDUE \\textasteriskcenteredMONTHRATE: 10:2) END."}, "question": "task_1"}}, {"data": {"text": "Question:\nDesign a computer program to playHexapawn. What is unusual about this program?\n\nOptions:\nA. The program for Hexapawn is unusual because it uses advanced algorithms to predict the opponent's moves.\nB. The program for Hexapawn is unusual because it requires a high level of computational power.\nC.             The program for Hexapawn is unusual because it learns from its mistakes, erasing moves that led to defeat and saving only winning sequences of moves.\nD. The program for Hexapawn is unusual because it is designed to always win.\n\nAnswer: C\n\nReference Solution:\nHexapawnis played on a 3 \u00d7 3 chess board. There are six pieces - three white pawns and three black pawns. The movements of the pawns are the same as in chess. The initial position is B B B W W W The object of the game is to get a passed pawn i.e. a pawn on the enemy's last rank. The first one to obtain a passed pawn (i.e. to place his pawn to any starting position of his opponent's pawns) wins. Alternatively, if no more moves are possible, (the position is totally blocked), then the person who made the last move is the winner. The squares are num-bered as follows: 123 456 789 The program forHexapawnis an application of cybernetics. The computer records every unfamiliar position in its memory including all the moves that follow. Now assume that the computer loses a game. It erases the move that led to de-feat. As an example: B Computer You W B W Here, with the computer to move, it could win by playing 6 to 9 (or even 1 to 5). However, if it plays 1 to 4 then you can win by moving 5 to 2. If this same position occurs in another game, the computer (assuming it played the losing move in the first game) will not even consider 1 to 4 but will play 6 to 9 or 1 to 5 instead. The computer has learn-ed from the first game. If the computer gets a position from which all moves have been deleted (they all led to defeat) it erases the move that got it there and resigns. In this way it saves only winning sequences of moves. If it plays long enough and encounters a great variety of unfamiliar positions it will become unbeatable. Note that this method of \"learning\" cannot be used to create an unbeatable program in chess. The number of different positions in chess is of astronomical order and the chances of a computer encountering an exactly similar position twice are vanishingly small (apart from the openingand elementary end-game positions). Thus the program would have to be modified withstrategicalconcepts and evaluation of would have to be modified withstrategicalconcepts and evaluation of pieces. pieces. 10PRINT \"HEXAPAWN\" 20DIM B (19,9) M (19,4), S (9), P$ (3) 30W = O: L = 0 40DEF FNR(X) = - 3\\textasteriskcentered(X = 1) - (X = 3) - 4\\textasteriskcentered(X = 6) - 6\\textasteriskcentered(X = 4) - 7\\textasteriskcentered(X= 9) - 9\\textasteriskcentered(X = 7) + FNS(X) 60DEF FNS(X) = - X\\textasteriskcentered(X = 2 OR X = 5 OR X = 8) 70DEF FNM(Y) = Y - INT(Y/10)\\textasteriskcentered10 80P$ = \"X\\bullet0\" 90FOR I = 1 TO 19: FOR J = 1 TO 9: READ B(I,J): NEXT J:NEXT I 100FOR I = 1 TO 19: FOR J = 1 TO 4: READ M(I,J): NEXT J: NEXT I 110X = 0: Y = 0 120S(4) = 0: S(5) = 0: S(6) = 0 130S(1) = - 1: S(2) = - 1: S(3) = - 1 140S(7) = 1: S(8) = 1; S(9) = 1 150GOSUB 1200 160PRINT \"YOUR MOVE\"; 170INPUT M1,M2 180IF M1 = INT (Ml) AND M2 = INT (M2) AND M1 > 0 AND M1 < 10 AND M2 > 0 AND M2 < 10 THEN 220 200PRINT \"ILLEGAL COORDINATES\\textquotedblright. 210GOTO 160 220IF S (M1) = 1 THEN 240 230PRINT \"ILLEGAL MOVE.\": GOTO 160 240IF S(M2) = 1 THEN 230 250IF M2 - M1 <> - 3 AND S(M2) <> - 1 THEN 230 260IF M2 > M1 THEN 230 270IF M2 - M1 = - 3 AND (S(M2) <> 0) THEN 230 280IF M2 - M1 < - 4 THEN 230 290IF M1 = 7 AND M2 a 3 THEN 230 300S (M1) = 0 310S (M2) = 1 320GOSUB 1200 330IF S (1) = 1 OR S (2) = 1 OR S (3) = 1 THEN 960 340FOR I = 1 TO 9 342IF S(I) = - 1 THEN 348 344NEXT I 346GOTO 960 348FOR I = 1 TO 9 350IF S (I) <> - 1 THEN 420 360IF S (I + 3) = 0 THEN 440 370IF FNR (I) = I THEN 410 380IF I > 3 THEN 396 390IF S (5) = 1 THEN 440 393GOTO 420 396IF S (8) = 1 THEN 440 400GOTO 420 410IF S (I + 2) = 1 OR S (I + 4) = 1 THEN 440 420NEXT I 430GOTO 960 440FOR I = 1 TO 19 450FOR J = 1 TO 3 460FOR K = 3 TO 1 STEP - 1 470T ((J - 1)\\textasteriskcentered3 + K) = B (I,( J - 1)\\textasteriskcentered3 + 4 - K) 480NEXT K 490NEXT J 500FOR J = 1 TO 9 510IF S (J) <> B (I,J) THEN 542 520NEXT J 530R = 0 540GOTO 590 542FOR J = 1 TO 9 544IF S (J) <> T (J) THEN 550 546NEXT J 548R = 1 549GOTO 590 550NEXT I 560REM THE TERMINATION OF THIS LOOP IS IMPOSSIBLE 570PRINT \"ILLEGAL BOARD PATTERN.\" 580STOP 590X = I 600FOR I = 1 TO 4 610IF M (X, I) <> 0 THEN 650 620NEXT I 630PRINT \"I RESIGN\" 640GOTO 960 650Y = INT(RND (1)\\textasteriskcentered4 + 1) 660IF M (X,Y) = 0 THEN 650 670IF R <> 0 THEN 730 680PRINT \"I MOVE FROM\"; STR$ (INT(M(X,Y)/10)); \"TO\"; STR$ (FNM (M(X,Y))) 700S (INT (M(X,Y)/10) ) = 0 710S (FNM (M(X,Y))) = - 1 720GOTO 770 730PRINT \"I MOVE FROM\"; STR$ (FNR (INT (M(X, Y) /10))) ; \"TO\" 740PRINT STR$ (FNR (FNM (M(X,Y)))) 750S (FNR (INT (M(X,Y)/10))) = 0 760S (FNR (FNM (M(X,Y)))) = - 1 770GOSUB 1200 780IF S (7) = - 1 OR S (8) = - 1 OR S (9) = - 1 THEN 1020 790FOR I = 1 TO 9 800IF S(I) = 1 THEN 830 810NEXT I 820GOTO 1020 830FOR I = 1 TO 9 840IF S (I) <> 1 THEN 930 850IF S (I - 3) = 0 THEN 160 860IF FNR (I) = I THEN 920 870IF I < 7 THEN 900 880IF S (5) = - 1 THEN 160 890GOTO 930 900IF S (2) = - 1 THEN 160 910GOTO 930 920IF S (I - 2) = - 1 OR S (I - 4) = - 1 THEN 160 930NEXT I 940PRINT \"YOU CAN'T MOVE, SO\"; 950GOTO 1020 960PRINT \"YOU WIN\" 970M (X,Y) = 0 980L = L + 1 990PRINT \"I HAVE WON\"; W;\" AND YOU\"; L; 1000\"OUT OF\"; L + W; \"GAMES.\" 1010PRINT: GOTO 30 1020PRINT \"I WIN\" 1030W = W + 1 1040GOTO 990 1050DATA- 1, - 1, - 1,1,0,0,0,1,1, - 1, - 1, - 1,0,1,0,1,0,1 1060DATA- 1,0, - 1, - 1,1,0,0,0,1,0, - 1, - 1,1, - 1,0,0,0,1 1070DATA- 1,0, - 1,1,1,0,0,1,0, - 1, - 1,0,1,0,1,0,0,1 1080DATA0, -1, -1,0, -1,1,1,0,0,0, -1, -1, -1,1,1,1,0,0 1090DATA- 1,0, - 1, - 1,0,1,0,1,0,0, - 1, - 1,0,1,0,0,0,1 1100DATA0, - 1, - 1,0,1,0,1,0,0, - 1,0, - 1,1,0,0,0,0,1 1110DATA0,0, - 1, - 1, - 1,1,0,0,0, - 1,0,0,1,1,1,0,0,0 1120DATA0, - 1,0, - 1,1,1,0,0,0, - 1,0,0, - 1, - 1,1,0,0,0 1130DATA0,0, - 1, - 1,1,0,0,0,0,0, - 1,0,1, - 1,0,0,0,0 1140DATA- 1,0,0, - 1,1,0,0,0,0 1150DATA24,25,36,0,14,15,36,0,15,35,36,47,36,58,59,0 1160DATA15,35,36,0,24,25,26,0,26,57,58,0 1170DATA26,35,0,0,47,48,0,0,35,36,0,0,35,36,0,0 1180DATA36,0,0,0,47,58,0,0,15,0,0,0 1190DATA26,47,0,0,47,58,0,0,35,36,47,0,28,58,0,0,15,47,0,0 1200PRINT: FOR I = 1 TO 3 1210FOR J = 1 TO 3 1220PRINT TAB (10); MID$ (P$,S((I - 1)\\textasteriskcentered3 + J) + 2,1); 1230NEXT J 1240PRINT: NEXT I 1250PRINT 1260RETURN 1270END", "ref_id": 4751, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Design a computer program to playHexapawn. What is unusual about this program?", "options": ["The program for Hexapawn is unusual because it uses advanced algorithms to predict the opponent's moves.", "The program for Hexapawn is unusual because it requires a high level of computational power.", "The program for Hexapawn is unusual because it learns from its mistakes, erasing moves that led to defeat and saving only winning sequences of moves.", "The program for Hexapawn is unusual because it is designed to always win."], "answer": "C", "solution": "Hexapawnis played on a 3 \u00d7 3 chess board. There are six pieces - three white pawns and three black pawns. The movements of the pawns are the same as in chess. The initial position is B B B W W W The object of the game is to get a passed pawn i.e. a pawn on the enemy's last rank. The first one to obtain a passed pawn (i.e. to place his pawn to any starting position of his opponent's pawns) wins. Alternatively, if no more moves are possible, (the position is totally blocked), then the person who made the last move is the winner. The squares are num-bered as follows: 123 456 789 The program forHexapawnis an application of cybernetics. The computer records every unfamiliar position in its memory including all the moves that follow. Now assume that the computer loses a game. It erases the move that led to de-feat. As an example: B Computer You W B W Here, with the computer to move, it could win by playing 6 to 9 (or even 1 to 5). However, if it plays 1 to 4 then you can win by moving 5 to 2. If this same position occurs in another game, the computer (assuming it played the losing move in the first game) will not even consider 1 to 4 but will play 6 to 9 or 1 to 5 instead. The computer has learn-ed from the first game. If the computer gets a position from which all moves have been deleted (they all led to defeat) it erases the move that got it there and resigns. In this way it saves only winning sequences of moves. If it plays long enough and encounters a great variety of unfamiliar positions it will become unbeatable. Note that this method of \"learning\" cannot be used to create an unbeatable program in chess. The number of different positions in chess is of astronomical order and the chances of a computer encountering an exactly similar position twice are vanishingly small (apart from the openingand elementary end-game positions). Thus the program would have to be modified withstrategicalconcepts and evaluation of would have to be modified withstrategicalconcepts and evaluation of pieces. pieces. 10PRINT \"HEXAPAWN\" 20DIM B (19,9) M (19,4), S (9), P$ (3) 30W = O: L = 0 40DEF FNR(X) = - 3\\textasteriskcentered(X = 1) - (X = 3) - 4\\textasteriskcentered(X = 6) - 6\\textasteriskcentered(X = 4) - 7\\textasteriskcentered(X= 9) - 9\\textasteriskcentered(X = 7) + FNS(X) 60DEF FNS(X) = - X\\textasteriskcentered(X = 2 OR X = 5 OR X = 8) 70DEF FNM(Y) = Y - INT(Y/10)\\textasteriskcentered10 80P$ = \"X\\bullet0\" 90FOR I = 1 TO 19: FOR J = 1 TO 9: READ B(I,J): NEXT J:NEXT I 100FOR I = 1 TO 19: FOR J = 1 TO 4: READ M(I,J): NEXT J: NEXT I 110X = 0: Y = 0 120S(4) = 0: S(5) = 0: S(6) = 0 130S(1) = - 1: S(2) = - 1: S(3) = - 1 140S(7) = 1: S(8) = 1; S(9) = 1 150GOSUB 1200 160PRINT \"YOUR MOVE\"; 170INPUT M1,M2 180IF M1 = INT (Ml) AND M2 = INT (M2) AND M1 > 0 AND M1 < 10 AND M2 > 0 AND M2 < 10 THEN 220 200PRINT \"ILLEGAL COORDINATES\\textquotedblright. 210GOTO 160 220IF S (M1) = 1 THEN 240 230PRINT \"ILLEGAL MOVE.\": GOTO 160 240IF S(M2) = 1 THEN 230 250IF M2 - M1 <> - 3 AND S(M2) <> - 1 THEN 230 260IF M2 > M1 THEN 230 270IF M2 - M1 = - 3 AND (S(M2) <> 0) THEN 230 280IF M2 - M1 < - 4 THEN 230 290IF M1 = 7 AND M2 a 3 THEN 230 300S (M1) = 0 310S (M2) = 1 320GOSUB 1200 330IF S (1) = 1 OR S (2) = 1 OR S (3) = 1 THEN 960 340FOR I = 1 TO 9 342IF S(I) = - 1 THEN 348 344NEXT I 346GOTO 960 348FOR I = 1 TO 9 350IF S (I) <> - 1 THEN 420 360IF S (I + 3) = 0 THEN 440 370IF FNR (I) = I THEN 410 380IF I > 3 THEN 396 390IF S (5) = 1 THEN 440 393GOTO 420 396IF S (8) = 1 THEN 440 400GOTO 420 410IF S (I + 2) = 1 OR S (I + 4) = 1 THEN 440 420NEXT I 430GOTO 960 440FOR I = 1 TO 19 450FOR J = 1 TO 3 460FOR K = 3 TO 1 STEP - 1 470T ((J - 1)\\textasteriskcentered3 + K) = B (I,( J - 1)\\textasteriskcentered3 + 4 - K) 480NEXT K 490NEXT J 500FOR J = 1 TO 9 510IF S (J) <> B (I,J) THEN 542 520NEXT J 530R = 0 540GOTO 590 542FOR J = 1 TO 9 544IF S (J) <> T (J) THEN 550 546NEXT J 548R = 1 549GOTO 590 550NEXT I 560REM THE TERMINATION OF THIS LOOP IS IMPOSSIBLE 570PRINT \"ILLEGAL BOARD PATTERN.\" 580STOP 590X = I 600FOR I = 1 TO 4 610IF M (X, I) <> 0 THEN 650 620NEXT I 630PRINT \"I RESIGN\" 640GOTO 960 650Y = INT(RND (1)\\textasteriskcentered4 + 1) 660IF M (X,Y) = 0 THEN 650 670IF R <> 0 THEN 730 680PRINT \"I MOVE FROM\"; STR$ (INT(M(X,Y)/10)); \"TO\"; STR$ (FNM (M(X,Y))) 700S (INT (M(X,Y)/10) ) = 0 710S (FNM (M(X,Y))) = - 1 720GOTO 770 730PRINT \"I MOVE FROM\"; STR$ (FNR (INT (M(X, Y) /10))) ; \"TO\" 740PRINT STR$ (FNR (FNM (M(X,Y)))) 750S (FNR (INT (M(X,Y)/10))) = 0 760S (FNR (FNM (M(X,Y)))) = - 1 770GOSUB 1200 780IF S (7) = - 1 OR S (8) = - 1 OR S (9) = - 1 THEN 1020 790FOR I = 1 TO 9 800IF S(I) = 1 THEN 830 810NEXT I 820GOTO 1020 830FOR I = 1 TO 9 840IF S (I) <> 1 THEN 930 850IF S (I - 3) = 0 THEN 160 860IF FNR (I) = I THEN 920 870IF I < 7 THEN 900 880IF S (5) = - 1 THEN 160 890GOTO 930 900IF S (2) = - 1 THEN 160 910GOTO 930 920IF S (I - 2) = - 1 OR S (I - 4) = - 1 THEN 160 930NEXT I 940PRINT \"YOU CAN'T MOVE, SO\"; 950GOTO 1020 960PRINT \"YOU WIN\" 970M (X,Y) = 0 980L = L + 1 990PRINT \"I HAVE WON\"; W;\" AND YOU\"; L; 1000\"OUT OF\"; L + W; \"GAMES.\" 1010PRINT: GOTO 30 1020PRINT \"I WIN\" 1030W = W + 1 1040GOTO 990 1050DATA- 1, - 1, - 1,1,0,0,0,1,1, - 1, - 1, - 1,0,1,0,1,0,1 1060DATA- 1,0, - 1, - 1,1,0,0,0,1,0, - 1, - 1,1, - 1,0,0,0,1 1070DATA- 1,0, - 1,1,1,0,0,1,0, - 1, - 1,0,1,0,1,0,0,1 1080DATA0, -1, -1,0, -1,1,1,0,0,0, -1, -1, -1,1,1,1,0,0 1090DATA- 1,0, - 1, - 1,0,1,0,1,0,0, - 1, - 1,0,1,0,0,0,1 1100DATA0, - 1, - 1,0,1,0,1,0,0, - 1,0, - 1,1,0,0,0,0,1 1110DATA0,0, - 1, - 1, - 1,1,0,0,0, - 1,0,0,1,1,1,0,0,0 1120DATA0, - 1,0, - 1,1,1,0,0,0, - 1,0,0, - 1, - 1,1,0,0,0 1130DATA0,0, - 1, - 1,1,0,0,0,0,0, - 1,0,1, - 1,0,0,0,0 1140DATA- 1,0,0, - 1,1,0,0,0,0 1150DATA24,25,36,0,14,15,36,0,15,35,36,47,36,58,59,0 1160DATA15,35,36,0,24,25,26,0,26,57,58,0 1170DATA26,35,0,0,47,48,0,0,35,36,0,0,35,36,0,0 1180DATA36,0,0,0,47,58,0,0,15,0,0,0 1190DATA26,47,0,0,47,58,0,0,35,36,47,0,28,58,0,0,15,47,0,0 1200PRINT: FOR I = 1 TO 3 1210FOR J = 1 TO 3 1220PRINT TAB (10); MID$ (P$,S((I - 1)\\textasteriskcentered3 + J) + 2,1); 1230NEXT J 1240PRINT: NEXT I 1250PRINT 1260RETURN 1270END"}, "question": "task_1"}}, {"data": {"text": "Question:\nWrite a program to determine the prime factorizations of integers greater than 1.\n\nOptions:\nA. The solution is a graph representing the prime factorizations of integers.\nB. The solution is a computer program for determining the prime factorizations of integers greater than 1, based on the Fundamental Theorem of Arithmetic and specific facts about prime numbers.\nC.             The solution is a mathematical formula for determining the prime factorizations.\nD. The solution is a table showing the prime factorizations of integers.\n\nAnswer: B\n\nReference Solution:\nAccording to the Fundamental Theorem of Arithmetic any integer can be expressed as the product of primes. Some examples 108 = 2 \u00d7 2 \u00d7 3 \u00d7 3 \u00d7 3 = 22 \u00d7 33 390 = 2 \u00d7 3 \u00d7 5 \u00d7 13 -210 = -(2 \u00d7 3 \u00d7 5 \u00d7 7) The algorithm for computing the prime factors of a positive integer greater than 1 is based on the following facts: 1) Let p be a prime \\leq \\surdn. If n is divisible by no such p, then n is a prime. 2) Let p be a divisor of n. Then q = n/p is an integer, and any other prime divisor of n divides q. 3) n has at most one prime factor greater than \\surdn . Using these facts we can construct the following computer program. The program assumes that a table of primes for the range 1-1000 was developed earlier and can be obtained from the secondary memory files. Thus, the program can find prime factorizations for all numbers less than (1000)2 = 1,000,000. Execution terminates when the considered integer N is 1 or less. The program looks as follows: PRIME FACTORIZATION CRESERVE MEMORY FOR PRIME DIVISORS (NPR), FOR PRIME FACTORS (NFAC) , AND FOR THE NUMBER OF TIMES EACH PRIME FACTOR OCCURS (NBR). DIMENSION NPR(168), NFAC(8), NBR(8). CREAD IN THE PRIMES LESS THAN 1000. C(THERE ARE 168 OF THEM) READ (5,5)(NPR(I), I = 1, 168) 5FORMAT (20I4) 10READ (5,15) N 15FORMAT (I7) IF (N - 2) 85,75,20 CCOPY N INTO INT FOR TESTING PURPOSES. 20INT = N RN = INT NRT = SQRT(RN) CSTART A COUNTER FOR THE NUMBER OF DIFFERENT PRIMES THAT DIVIDE N. J = 0 DO 45 I = 1, 168 CNF COUNTS THE OCCURRENCES OF EACH PRIME FACTOR NF = 0 CBRANCH OUT OF THE DO LOOP IF CTHE CURRENT PRIME IS GREATER CTHAN THE SQUARE ROOT OF INT. IF (NPR(I) - NRT) 25,25,50 25KINT = INT/NPR(I) IF (INT - KINT\\textasteriskcenteredNPR(I)) 35,30,35 CIF NPR(I) DIVIDES INT, STORE THE CQUOTIENT KINT IN INT. THUS, THIS CQUOTIENT IS NOW THE DIVIDEND FOR FURTHER TESTING. 30INT = KINT NF = NF + 1 GO TO 25 35IF (NF) 45,45,40 CINCREMENT J BY 1 IF NF IS POSITIVE CAND IF NPR(I) DOES NOT DIVIDE INT. CTHEN STORE THE PRIME NPR(I), AS THE CJ-TH MEMBER OF NFAC AND STORE CTHE MULTIPLICITY NF IN NBR(J). 40J = J + 1 NFAC(J) = NPR(I) NBR(J) = NF RN = INT NRT = SQRT(RN) 45CONTINUE CN IS PRIME IF AND ONLY IF J = 0 50IF (J) 75,75,55 55IF (INT-1) 65,65,60 60J = J + 1 NFAC (J) = INT NBR(J) = 1 CPRINT PRIME FACTORIZATION 65WRITE (6,70) N, (NFAC(I) ,NBR(I), I = 1,J) 70FORMAT (1HO, I7, 3H = , 8(I5, 1H( ,I2, 1H))) GO TO 10 75WRITE (6,80) N 80FORMAT (1HO, I7, 9H IS PRIME) GO TO 10 85STOP END", "ref_id": 4752, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Write a program to determine the prime factorizations of integers greater than 1.", "options": ["The solution is a graph representing the prime factorizations of integers.", "The solution is a computer program for determining the prime factorizations of integers greater than 1, based on the Fundamental Theorem of Arithmetic and specific facts about prime numbers.", "The solution is a mathematical formula for determining the prime factorizations.", "The solution is a table showing the prime factorizations of integers."], "answer": "B", "solution": "According to the Fundamental Theorem of Arithmetic any integer can be expressed as the product of primes. Some examples 108 = 2 \u00d7 2 \u00d7 3 \u00d7 3 \u00d7 3 = 22 \u00d7 33 390 = 2 \u00d7 3 \u00d7 5 \u00d7 13 -210 = -(2 \u00d7 3 \u00d7 5 \u00d7 7) The algorithm for computing the prime factors of a positive integer greater than 1 is based on the following facts: 1) Let p be a prime \\leq \\surdn. If n is divisible by no such p, then n is a prime. 2) Let p be a divisor of n. Then q = n/p is an integer, and any other prime divisor of n divides q. 3) n has at most one prime factor greater than \\surdn . Using these facts we can construct the following computer program. The program assumes that a table of primes for the range 1-1000 was developed earlier and can be obtained from the secondary memory files. Thus, the program can find prime factorizations for all numbers less than (1000)2 = 1,000,000. Execution terminates when the considered integer N is 1 or less. The program looks as follows: PRIME FACTORIZATION CRESERVE MEMORY FOR PRIME DIVISORS (NPR), FOR PRIME FACTORS (NFAC) , AND FOR THE NUMBER OF TIMES EACH PRIME FACTOR OCCURS (NBR). DIMENSION NPR(168), NFAC(8), NBR(8). CREAD IN THE PRIMES LESS THAN 1000. C(THERE ARE 168 OF THEM) READ (5,5)(NPR(I), I = 1, 168) 5FORMAT (20I4) 10READ (5,15) N 15FORMAT (I7) IF (N - 2) 85,75,20 CCOPY N INTO INT FOR TESTING PURPOSES. 20INT = N RN = INT NRT = SQRT(RN) CSTART A COUNTER FOR THE NUMBER OF DIFFERENT PRIMES THAT DIVIDE N. J = 0 DO 45 I = 1, 168 CNF COUNTS THE OCCURRENCES OF EACH PRIME FACTOR NF = 0 CBRANCH OUT OF THE DO LOOP IF CTHE CURRENT PRIME IS GREATER CTHAN THE SQUARE ROOT OF INT. IF (NPR(I) - NRT) 25,25,50 25KINT = INT/NPR(I) IF (INT - KINT\\textasteriskcenteredNPR(I)) 35,30,35 CIF NPR(I) DIVIDES INT, STORE THE CQUOTIENT KINT IN INT. THUS, THIS CQUOTIENT IS NOW THE DIVIDEND FOR FURTHER TESTING. 30INT = KINT NF = NF + 1 GO TO 25 35IF (NF) 45,45,40 CINCREMENT J BY 1 IF NF IS POSITIVE CAND IF NPR(I) DOES NOT DIVIDE INT. CTHEN STORE THE PRIME NPR(I), AS THE CJ-TH MEMBER OF NFAC AND STORE CTHE MULTIPLICITY NF IN NBR(J). 40J = J + 1 NFAC(J) = NPR(I) NBR(J) = NF RN = INT NRT = SQRT(RN) 45CONTINUE CN IS PRIME IF AND ONLY IF J = 0 50IF (J) 75,75,55 55IF (INT-1) 65,65,60 60J = J + 1 NFAC (J) = INT NBR(J) = 1 CPRINT PRIME FACTORIZATION 65WRITE (6,70) N, (NFAC(I) ,NBR(I), I = 1,J) 70FORMAT (1HO, I7, 3H = , 8(I5, 1H( ,I2, 1H))) GO TO 10 75WRITE (6,80) N 80FORMAT (1HO, I7, 9H IS PRIME) GO TO 10 85STOP END"}, "question": "task_1"}}, {"data": {"text": "Question:\nGiven 25 equally spaced data points x_i (i= 1,...,25) and 25 functionalvaluesy_i= f(x_i ) [arranged in ascending order ], writea program to evaluate^(X)25\\int_(X)1 f(x)dxusing the trapezoidalrule.\n\nOptions:\nA. (h/2) (y1 + 2y2 + 2y3 + ...+ 2y24 + y25)\nB. (h/2) (2y1 + 2y2 + 2y3 + ...+ 2y24 + 2y25)\nC.             (h/2) (y1 + y2 + y3 + ...+ y24 + y25)\nD. h (y1 + 2y2 + 2y3 + ...+ 2y24 + y25)\n\nAnswer: A\n\nReference Solution:\nAccording to the trapezoidal rule of integration, (X)25\\int_(X)1 f (x)dx= Area \\approx (h/2) (y1 + 2y2 + 2y3 + ...+ 2y24 + y25). We adopt the following computational strategy: accumulate 24\\sum_i=2y_iin a DO loop, double the result, add it to (y1+ y25), and multiply by h =X(2) - X(1). The program (which assumes values of X and Y have alreadybeen read in) is given below. You should also remember that the error margin for the trapezoid rule is givenby E \\leq (1/12 )( )( b - a)h2 \\vertf\"(\\xi)\\vertX_n\\leq \\xi \\leq X1. b - a)h2 \\vertf\"(\\xi)\\vertX_n\\leq \\xi \\leq X1. Knowing this, you can use a suitable N to calculate the integration to a closeapproximation. REAL H SUM = 0.0 DO 50 I = 2,24 50SUM = SUM +Y(I) H =X(2) - X(1) AREA = 0.5\\textasteriskcenteredH\\textasteriskcentered(Y(1) + 2.0\\textasteriskcenteredSUM + Y(25))", "ref_id": 4753, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Given 25 equally spaced data points x_i (i= 1,...,25) and 25 functionalvaluesy_i= f(x_i ) [arranged in ascending order ], writea program to evaluate^(X)25\\int_(X)1 f(x)dxusing the trapezoidalrule.", "options": ["(h/2) (y1 + 2y2 + 2y3 + ...+ 2y24 + y25)", "(h/2) (2y1 + 2y2 + 2y3 + ...+ 2y24 + 2y25)", "(h/2) (y1 + y2 + y3 + ...+ y24 + y25)", "h (y1 + 2y2 + 2y3 + ...+ 2y24 + y25)"], "answer": "A", "solution": "According to the trapezoidal rule of integration, (X)25\\int_(X)1 f (x)dx= Area \\approx (h/2) (y1 + 2y2 + 2y3 + ...+ 2y24 + y25). We adopt the following computational strategy: accumulate 24\\sum_i=2y_iin a DO loop, double the result, add it to (y1+ y25), and multiply by h =X(2) - X(1). The program (which assumes values of X and Y have alreadybeen read in) is given below. You should also remember that the error margin for the trapezoid rule is givenby E \\leq (1/12 )( )( b - a)h2 \\vertf\"(\\xi)\\vertX_n\\leq \\xi \\leq X1. b - a)h2 \\vertf\"(\\xi)\\vertX_n\\leq \\xi \\leq X1. Knowing this, you can use a suitable N to calculate the integration to a closeapproximation. REAL H SUM = 0.0 DO 50 I = 2,24 50SUM = SUM +Y(I) H =X(2) - X(1) AREA = 0.5\\textasteriskcenteredH\\textasteriskcentered(Y(1) + 2.0\\textasteriskcenteredSUM + Y(25))"}, "question": "task_1"}}, {"data": {"text": "Question:\nWrite a trapezoidal integration routine in FORTRAN to evaluate^.4\\int0 sin2 xdx+ ^.3\\int_.1 cos2 xdx.\n\nOptions:\nA. FUNCTIONTRAP(A,B,N,FX) H = (B - A)/N SUM = 0 K = N - 1 DO 6 I = 1,K 6SUM = SUM +FX(A + I\textasteriskcenteredH) TRAP = (FX(A) + FX(B) + SUM)\textasteriskcentered(H/2.) RETURN END\nB. FUNCTIONTRAP(A,B,N,FX) H = (B - A)/N SUM = 0 K = N - 1 DO 6 I = 1,K 6SUM = SUM +FX(A + I\textasteriskcenteredH) TRAP = (FX(A) + FX(B) + 2.\textasteriskcenteredSUM)\textasteriskcentered(H/2.) RETURN END\nC.             FUNCTIONTRAP(A,B,N,FX) H = (B - A)/N SUM = 0 K = N - 1 DO 6 I = 1,K 6SUM = SUM +FX(A + I\textasteriskcenteredH) TRAP = (FX(A) + FX(B) + 2.\textasteriskcenteredSUM)\textasteriskcentered(H) RETURN END\nD. FUNCTIONTRAP(A,B,N,FX) H = (B - A)/N SUM = 0 K = N - 1 DO 6 I = 1,K 6SUM = SUM +FX(A + I\textasteriskcenteredH) TRAP = (FX(A) + 2.\textasteriskcenteredSUM)\textasteriskcentered(H/2.) RETURN END\n\nAnswer: B\n\nReference Solution:\nLet us structure the problem as follows: there shall be a main routinewhich calls a trapezoid function routine, which in turn references twofunction routines defining the functions sin2x and cos2x. First note that accordingto the trapezoid rule ^b\\int_af(x)dx\\approx (h/2)[f(a) + 2f(a+h) + 2f(a+2h) + ... + 2f(a+(n-1)h)+f(b)], whereh = (b-a)/n is the number of trapezoids. Thus we have FUNCTIONTRAP(A,B,N,FX) H = (B - A)/N SUM = 0 K = N - 1 DO 6 I = 1,K 6SUM = SUM +FX(A + I\\textasteriskcenteredH) TRAP = (FX(A) + FX(B) + 2.\\textasteriskcenteredSUM)\\textasteriskcentered(H/2.) RETURN END The main calling program and function routines are given below. EXTERNAL FX1, FX2 APPROX =TRAP(0.,.4,5,FX1) + TRAP(.1,.3,5,FX2) PRINT, APPROX STOP END FUNCTION FX1(X) FX1 = (SIN X)\\textasteriskcentered\\textasteriskcentered2 RETURN END FUNCTION FX2(X) FX2 = (COS X)\\textasteriskcentered\\textasteriskcentered2 RETURN END Notice that the main program uses an EXTERNAL statement. This declara-tionmust be used in every calling program which passes the name ofa subprogram or built-in function to another subprogram. Also rememberthat the main program is entered first. After the END statement inthe main program, all subroutines may be entered. In this program, it is up to you to define the accuracy of the integra-tion. In otherwords, you choose the value of N, which determines the number of iterationsto be done.", "ref_id": 4754, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Write a trapezoidal integration routine in FORTRAN to evaluate^.4\\int0 sin2 xdx+ ^.3\\int_.1 cos2 xdx.", "options": ["FUNCTIONTRAP(A,B,N,FX) H = (B - A)/N SUM = 0 K = N - 1 DO 6 I = 1,K 6SUM = SUM +FX(A + I\textasteriskcenteredH) TRAP = (FX(A) + FX(B) + SUM)\textasteriskcentered(H/2.) RETURN END", "FUNCTIONTRAP(A,B,N,FX) H = (B - A)/N SUM = 0 K = N - 1 DO 6 I = 1,K 6SUM = SUM +FX(A + I\textasteriskcenteredH) TRAP = (FX(A) + FX(B) + 2.\textasteriskcenteredSUM)\textasteriskcentered(H/2.) RETURN END", "FUNCTIONTRAP(A,B,N,FX) H = (B - A)/N SUM = 0 K = N - 1 DO 6 I = 1,K 6SUM = SUM +FX(A + I\textasteriskcenteredH) TRAP = (FX(A) + FX(B) + 2.\textasteriskcenteredSUM)\textasteriskcentered(H) RETURN END", "FUNCTIONTRAP(A,B,N,FX) H = (B - A)/N SUM = 0 K = N - 1 DO 6 I = 1,K 6SUM = SUM +FX(A + I\textasteriskcenteredH) TRAP = (FX(A) + 2.\textasteriskcenteredSUM)\textasteriskcentered(H/2.) RETURN END"], "answer": "B", "solution": "Let us structure the problem as follows: there shall be a main routinewhich calls a trapezoid function routine, which in turn references twofunction routines defining the functions sin2x and cos2x. First note that accordingto the trapezoid rule ^b\\int_af(x)dx\\approx (h/2)[f(a) + 2f(a+h) + 2f(a+2h) + ... + 2f(a+(n-1)h)+f(b)], whereh = (b-a)/n is the number of trapezoids. Thus we have FUNCTIONTRAP(A,B,N,FX) H = (B - A)/N SUM = 0 K = N - 1 DO 6 I = 1,K 6SUM = SUM +FX(A + I\\textasteriskcenteredH) TRAP = (FX(A) + FX(B) + 2.\\textasteriskcenteredSUM)\\textasteriskcentered(H/2.) RETURN END The main calling program and function routines are given below. EXTERNAL FX1, FX2 APPROX =TRAP(0.,.4,5,FX1) + TRAP(.1,.3,5,FX2) PRINT, APPROX STOP END FUNCTION FX1(X) FX1 = (SIN X)\\textasteriskcentered\\textasteriskcentered2 RETURN END FUNCTION FX2(X) FX2 = (COS X)\\textasteriskcentered\\textasteriskcentered2 RETURN END Notice that the main program uses an EXTERNAL statement. This declara-tionmust be used in every calling program which passes the name ofa subprogram or built-in function to another subprogram. Also rememberthat the main program is entered first. After the END statement inthe main program, all subroutines may be entered. In this program, it is up to you to define the accuracy of the integra-tion. In otherwords, you choose the value of N, which determines the number of iterationsto be done."}, "question": "task_1"}}, {"data": {"text": "Question:\nDevelop a program to find rare prime decades. Consider a decade to be a series of numbers between and including 10a + 1 and 10a + 10, where a = 0,1,2,3... Rare decades are those which contain four primes. Output such decades less than 5000.\n\nOptions:\nA. Fermat's method\nB. Newton's method\nC.             Euler's method\nD. Sieve of Eratosthenes\n\nAnswer: D\n\nReference Solution:\nThe rarity of this occurrence is due to the fact that in any decade, there can be at most four primes. If you consider that in each decade there are five even numbers and one odd number that is a multiple of five, you should recognize that the remaining four possible primes must end with 1,3,7, or 9. The only exception to this rule is the first decade, the primes of which are 2,3,5 and 7. The needed algorithm must check the odd integers between 3 and 5000 to establish the existence of primes. To do this task, a FUNCTION subprogram IPRIME is used. This subprogram may use the Sieve of Eratosthenes (developed earlier) or some other method. It is assumed that the subprogram returns either of the two values: a 1 if the integer is a prime, a 0 if it is composite. The main program makes use of a four element queue. Each time a prime is found, it is stored in the array K. When four consecutive primes are in the queue, a check is made to see if they are included in one decade. If so, the entire queue is printed out. If not, the first prime in the queue is removed, the remaining three elements move up one position, and the next prime is inserted at the end of the queue. This process continues until I reaches 5000. The program looks as follows: DIMENSION K(4) K(1) = 2 ISUM = 1 J = 2 I = 3 II = 1 CDO WHILE I IS LESS THAN 5000 20IF (I.GE. 5000) GO TO 60 CASSIGN A NEW DECADE TO ISUM IF II = 5 IF (II.LT. 5) GO TO 5 ISUM = ISUM + 10 II = 0 CIF I IS A PRIME, ASSIGN IT TO K(J) 5CALL IPRIME (I) IF (IPRIME.EQ. 0) GO TO 57 K(J) = I J = J + 1 I = 1+2 II = II + 1 IF (J.LE.4) GO TO 20 CCHECK IF ALL 4 PRIMES IN ARRAY K ARE WITHIN CTHE SAME DECADE IF (K(1).LT.ISUM) GO TO 30 IF (K(4). GE. ISUM + 10) GO TO 30 CIF, IN FACT, THEY ARE - OUTPUT THE ARRAY K WRITE (5,100)(K(J), J = 1,4) 100FORMAT (4(2X,I4)/) J = 1 GO TO 20 CIF THEY ARE NOT WITHIN ONE DECADE 30DO 35 N = 2,4 35K(N-1) = K(N) J = 4 GO TO 20 57I = I + 2 II = II + 1 GO TO 20 60STOP END", "ref_id": 4755, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Develop a program to find rare prime decades. Consider a decade to be a series of numbers between and including 10a + 1 and 10a + 10, where a = 0,1,2,3... Rare decades are those which contain four primes. Output such decades less than 5000.", "options": ["Fermat's method", "Newton's method", "Euler's method", "Sieve of Eratosthenes"], "answer": "D", "solution": "The rarity of this occurrence is due to the fact that in any decade, there can be at most four primes. If you consider that in each decade there are five even numbers and one odd number that is a multiple of five, you should recognize that the remaining four possible primes must end with 1,3,7, or 9. The only exception to this rule is the first decade, the primes of which are 2,3,5 and 7. The needed algorithm must check the odd integers between 3 and 5000 to establish the existence of primes. To do this task, a FUNCTION subprogram IPRIME is used. This subprogram may use the Sieve of Eratosthenes (developed earlier) or some other method. It is assumed that the subprogram returns either of the two values: a 1 if the integer is a prime, a 0 if it is composite. The main program makes use of a four element queue. Each time a prime is found, it is stored in the array K. When four consecutive primes are in the queue, a check is made to see if they are included in one decade. If so, the entire queue is printed out. If not, the first prime in the queue is removed, the remaining three elements move up one position, and the next prime is inserted at the end of the queue. This process continues until I reaches 5000. The program looks as follows: DIMENSION K(4) K(1) = 2 ISUM = 1 J = 2 I = 3 II = 1 CDO WHILE I IS LESS THAN 5000 20IF (I.GE. 5000) GO TO 60 CASSIGN A NEW DECADE TO ISUM IF II = 5 IF (II.LT. 5) GO TO 5 ISUM = ISUM + 10 II = 0 CIF I IS A PRIME, ASSIGN IT TO K(J) 5CALL IPRIME (I) IF (IPRIME.EQ. 0) GO TO 57 K(J) = I J = J + 1 I = 1+2 II = II + 1 IF (J.LE.4) GO TO 20 CCHECK IF ALL 4 PRIMES IN ARRAY K ARE WITHIN CTHE SAME DECADE IF (K(1).LT.ISUM) GO TO 30 IF (K(4). GE. ISUM + 10) GO TO 30 CIF, IN FACT, THEY ARE - OUTPUT THE ARRAY K WRITE (5,100)(K(J), J = 1,4) 100FORMAT (4(2X,I4)/) J = 1 GO TO 20 CIF THEY ARE NOT WITHIN ONE DECADE 30DO 35 N = 2,4 35K(N-1) = K(N) J = 4 GO TO 20 57I = I + 2 II = II + 1 GO TO 20 60STOP END"}, "question": "task_1"}}, {"data": {"text": "Question:\nA and B are the players. A tells B to pick a number between 1 and 100. He then asks B to tell him the remainders when the secret chosen number is divided successively by 3, 5 and 7. A then tells B the number he originally chose.\n\nOptions:\nA. 41\nB. 51\nC.             36\nD. 70\n\nAnswer: A\n\nReference Solution:\nThe game is centered on the notion of congruence. Let x be the unknown number chosen by B, 1 \\leq x \\leq 100. Now x divided by 3 can give a remainder of 0, 1 or 2. The numbers between 1 and 100 can be arranged in three sets S_0 = {3,6,9,...,90,93,96,99} S_1 = {1,4,7,...,94, 97,100} S_2 = {2,5,8,...,92,95,98} Note that {S_0,S_1,S_2} forms a partition of 1 - 100. Similarly, on division by 5, the possible remainders 0,1,2,3,4 give rise to the disjoint sets S_0 = { ,5,10,...,90,95,100} S_1 = {1, 6,11,...,91,96} S_2 = {2,7,12,...,92,97} S_3 = {3,8,13,...93,98} S_4 = {4,9,14,...,94,99} Finally division by 7 yields the following Sets:S_0 = {7,14,...,91,98} S_1 = {1,8,15,...,92,99}S_2 = {2,9,16,...,93,100} S_3 = {3,10,17,...,87,94}S_4 = {4,11,...,88,95} S_5 = {5,12,...,89,96}S_6 = {6,13,...,90,97}. To be concrete, suppose x = 41. Then the remainders are 2,1, 6 when 41 is divided by 3,5 and 7 respectively. Thus, x = 41 lies in S_2 = {2,5,8,...,95,98} S_1 = {1,6,11,...,91,96} and S_6 = {6,13,...,90,97}. In fact, 41 is the only number that simultaneously lies in these three sets ! Now memorizing the above sets is one way of mastering this puzzle but fortunately, a much simpler algorithm exists. It uses the fact that 3 \u00d7 5 \u00d7 7 = 105. Let the secret number be x and let A, B, C be the remainders. Then x \\equiv D = 70A + 21B + 15C (mod 105)(1) Thus, for x = 41, 70(2) + 21(1) + 15(6) = 140 + 21 + 90 = 251. But we need x \\leq 100. Note that 251 - 105 = 146 and 146 - 105 = 41. Thus, 251 when divided by an integral multiple of 105 leaves a remainder of 41. We say 251 is congruent to 41 modu-lo 105 and write 41 \\equiv 251 (mod 105). The program follows: 10PRINT \\textquotedblleftTHINK OF A NUMBER BETWEEN 1 and 100.\" 20PRINT \"YOUR NUMBER DIVIDED BY 3 HAS A REMAINDER OF\\textquotedblright; 30INPUT A 40PRINT \"YOUR NUMBER DIVIDED BY 5 HAS A REMAINDER OF\\textquotedblright; 50INPUT B 60PRINT \"YOUR NUMBER DIVIDED BY 7 HAS A REMAINDER OF\\textquotedblright; 70INPUT C 80D = 70\\textasteriskcenteredA + 21\\textasteriskcenteredB + 15\\textasteriskcenteredC 90IF D < = 105 THEN 120 100D = D - 105 110GOTO 90 120PRINT \"YOUR NUMBER WAS\\textquotedblright; D;\", RIGHT?\"; 130INPUT A$ 140IF A$ = \"YES\" THEN 170 150REM SOMETIMES HUMANS MAKE ERRORS 160IF A$ = \"NO\" THEN 190 165PRINT \"VERY FUNNY! NOW TRY 'YES' OR 'NO'.\" 166GO TO 120 170PRINT \"HAL HAS SPOKEN TRULY\" 180GOTO 200 190PRINT \"CHECK YOUR ARITHMETIC\" 200PRINT \"LET'S TRY AGAIN.\" 210GOTO 10 220END", "ref_id": 4756, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "A and B are the players. A tells B to pick a number between 1 and 100. He then asks B to tell him the remainders when the secret chosen number is divided successively by 3, 5 and 7. A then tells B the number he originally chose.", "options": ["41", "51", "36", "70"], "answer": "A", "solution": "The game is centered on the notion of congruence. Let x be the unknown number chosen by B, 1 \\leq x \\leq 100. Now x divided by 3 can give a remainder of 0, 1 or 2. The numbers between 1 and 100 can be arranged in three sets S_0 = {3,6,9,...,90,93,96,99} S_1 = {1,4,7,...,94, 97,100} S_2 = {2,5,8,...,92,95,98} Note that {S_0,S_1,S_2} forms a partition of 1 - 100. Similarly, on division by 5, the possible remainders 0,1,2,3,4 give rise to the disjoint sets S_0 = { ,5,10,...,90,95,100} S_1 = {1, 6,11,...,91,96} S_2 = {2,7,12,...,92,97} S_3 = {3,8,13,...93,98} S_4 = {4,9,14,...,94,99} Finally division by 7 yields the following Sets:S_0 = {7,14,...,91,98} S_1 = {1,8,15,...,92,99}S_2 = {2,9,16,...,93,100} S_3 = {3,10,17,...,87,94}S_4 = {4,11,...,88,95} S_5 = {5,12,...,89,96}S_6 = {6,13,...,90,97}. To be concrete, suppose x = 41. Then the remainders are 2,1, 6 when 41 is divided by 3,5 and 7 respectively. Thus, x = 41 lies in S_2 = {2,5,8,...,95,98} S_1 = {1,6,11,...,91,96} and S_6 = {6,13,...,90,97}. In fact, 41 is the only number that simultaneously lies in these three sets ! Now memorizing the above sets is one way of mastering this puzzle but fortunately, a much simpler algorithm exists. It uses the fact that 3 \u00d7 5 \u00d7 7 = 105. Let the secret number be x and let A, B, C be the remainders. Then x \\equiv D = 70A + 21B + 15C (mod 105)(1) Thus, for x = 41, 70(2) + 21(1) + 15(6) = 140 + 21 + 90 = 251. But we need x \\leq 100. Note that 251 - 105 = 146 and 146 - 105 = 41. Thus, 251 when divided by an integral multiple of 105 leaves a remainder of 41. We say 251 is congruent to 41 modu-lo 105 and write 41 \\equiv 251 (mod 105). The program follows: 10PRINT \\textquotedblleftTHINK OF A NUMBER BETWEEN 1 and 100.\" 20PRINT \"YOUR NUMBER DIVIDED BY 3 HAS A REMAINDER OF\\textquotedblright; 30INPUT A 40PRINT \"YOUR NUMBER DIVIDED BY 5 HAS A REMAINDER OF\\textquotedblright; 50INPUT B 60PRINT \"YOUR NUMBER DIVIDED BY 7 HAS A REMAINDER OF\\textquotedblright; 70INPUT C 80D = 70\\textasteriskcenteredA + 21\\textasteriskcenteredB + 15\\textasteriskcenteredC 90IF D < = 105 THEN 120 100D = D - 105 110GOTO 90 120PRINT \"YOUR NUMBER WAS\\textquotedblright; D;\", RIGHT?\"; 130INPUT A$ 140IF A$ = \"YES\" THEN 170 150REM SOMETIMES HUMANS MAKE ERRORS 160IF A$ = \"NO\" THEN 190 165PRINT \"VERY FUNNY! NOW TRY 'YES' OR 'NO'.\" 166GO TO 120 170PRINT \"HAL HAS SPOKEN TRULY\" 180GOTO 200 190PRINT \"CHECK YOUR ARITHMETIC\" 200PRINT \"LET'S TRY AGAIN.\" 210GOTO 10 220END"}, "question": "task_1"}}, {"data": {"text": "Question:\nThe function of programcopydeckis to copy a deck of cards, reading from the fileindeckand writing to the fileoutdeck. Blank cards inindeckare not copied tooutdeck. Write the program copydeckto copy a deck of cards.\n\nOptions:\nA. PROGRAM copydeck(indeck,outdeck, output); blank = ''; TYPE colindex=1 . .maxcol; card= PACKED ARRAY [colindex] of char; cardfile=FILE of card; VAR indeck,outdeck:cardfile; buffer,blankcard:card; column :colindex; BEGIN For column: = 1TomaxcolDO blankcard [ column]:= blank; rewrite(outdeck); WHILE NOTeof(indeck) DO BEGIN read(indeck, buffer); IF buffer <>blankcard THEN write (outdeck, buffer) END {while} END. {copydeck}\nB. PROGRAM copydeck(indeck,outdeck, output); CONST maxcol= 80; blank = ''; TYPE colindex=1 . .maxcol; card= PACKED ARRAY [colindex] of char; cardfile=FILE of card; VAR indeck,outdeck:cardfile; buffer,blankcard:card; column :colindex; BEGIN For column: = 1TomaxcolDO blankcard [ column]:= blank; reset(indeck); WHILE NOTeof(indeck) DO BEGIN read(indeck, buffer); IF buffer =blankcard THEN write (outdeck, buffer) END {while} END. {copydeck}\nC.             PROGRAM copydeck(indeck,outdeck, output); CONST maxcol= 80; blank = ''; TYPE colindex=1 . .maxcol; card= PACKED ARRAY [colindex] of char; cardfile=FILE of card; VAR indeck,outdeck:cardfile; buffer,blankcard:card; column :colindex; BEGIN For column: = 1TomaxcolDO blankcard [ column]:= blank; reset(indeck); rewrite(outdeck); WHILE NOTeof(indeck) DO BEGIN read(indeck, buffer); IF buffer <>blankcard THEN write (outdeck, buffer) END {while} END. {copydeck}\nD. PROGRAM copydeck(indeck,outdeck, output); CONST maxcol= 80; blank = ' '; reset(indeck); rewrite(outdeck); WHILE NOTeof(indeck) DO BEGIN read(indeck, buffer); IF buffer <>blankcard THEN write (outdeck, buffer) END {while} END. {copydeck}\n\nAnswer: C\n\nReference Solution:\nPROGRAMcopydeck(indeck,outdeck, output); CONST maxcol= 80; blank = ''; TYPE colindex=1 . .maxcol; card= PACKED ARRAY [colindex] of char; cardfile=FILE of card; VAR indeck,outdeck:cardfile; buffer,blankcard:card; column :colindex; BEGIN For column: = 1TomaxcolDO blankcard [ column]:= blank; reset(indeck); rewrite(outdeck); WHILE NOTeof(indeck) DO BEGIN read(indeck, buffer); IF buffer <>blankcard THEN write (outdeck, buffer) END {while} END. {copydeck}", "ref_id": 4757, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "The function of programcopydeckis to copy a deck of cards, reading from the fileindeckand writing to the fileoutdeck. Blank cards inindeckare not copied tooutdeck. Write the program copydeckto copy a deck of cards.", "options": ["PROGRAM copydeck(indeck,outdeck, output); blank = ''; TYPE colindex=1 . .maxcol; card= PACKED ARRAY [colindex] of char; cardfile=FILE of card; VAR indeck,outdeck:cardfile; buffer,blankcard:card; column :colindex; BEGIN For column: = 1TomaxcolDO blankcard [ column]:= blank; rewrite(outdeck); WHILE NOTeof(indeck) DO BEGIN read(indeck, buffer); IF buffer <>blankcard THEN write (outdeck, buffer) END {while} END. {copydeck}", "PROGRAM copydeck(indeck,outdeck, output); CONST maxcol= 80; blank = ''; TYPE colindex=1 . .maxcol; card= PACKED ARRAY [colindex] of char; cardfile=FILE of card; VAR indeck,outdeck:cardfile; buffer,blankcard:card; column :colindex; BEGIN For column: = 1TomaxcolDO blankcard [ column]:= blank; reset(indeck); WHILE NOTeof(indeck) DO BEGIN read(indeck, buffer); IF buffer =blankcard THEN write (outdeck, buffer) END {while} END. {copydeck}", "PROGRAM copydeck(indeck,outdeck, output); CONST maxcol= 80; blank = ''; TYPE colindex=1 . .maxcol; card= PACKED ARRAY [colindex] of char; cardfile=FILE of card; VAR indeck,outdeck:cardfile; buffer,blankcard:card; column :colindex; BEGIN For column: = 1TomaxcolDO blankcard [ column]:= blank; reset(indeck); rewrite(outdeck); WHILE NOTeof(indeck) DO BEGIN read(indeck, buffer); IF buffer <>blankcard THEN write (outdeck, buffer) END {while} END. {copydeck}", "PROGRAM copydeck(indeck,outdeck, output); CONST maxcol= 80; blank = ' '; reset(indeck); rewrite(outdeck); WHILE NOTeof(indeck) DO BEGIN read(indeck, buffer); IF buffer <>blankcard THEN write (outdeck, buffer) END {while} END. {copydeck}"], "answer": "C", "solution": "PROGRAMcopydeck(indeck,outdeck, output); CONST maxcol= 80; blank = ''; TYPE colindex=1 . .maxcol; card= PACKED ARRAY [colindex] of char; cardfile=FILE of card; VAR indeck,outdeck:cardfile; buffer,blankcard:card; column :colindex; BEGIN For column: = 1TomaxcolDO blankcard [ column]:= blank; reset(indeck); rewrite(outdeck); WHILE NOTeof(indeck) DO BEGIN read(indeck, buffer); IF buffer <>blankcard THEN write (outdeck, buffer) END {while} END. {copydeck}"}, "question": "task_1"}}, {"data": {"text": "Question:\nWhat is the output of the following program? PROGRAM TEST (output); VAR I, J, K, COUNT : integer; BEGIN I: = 1; J: = 2; K: = 3; count: = 1; write1n (I div J, K mod J); while count < = 3 DO BEGIN If I < J then If K > J then If (K > I) or (I = J) then write1n (I) ELSE write1n (J) ELSE write1n (K); CASE COUNT OF 1: J: = 0; 2: BEGIN K: = K - 1; J: = J + K END; 3:I: = 2 \\textasteriskcentered I; END; count : = count + 1; END {while count........} END.\n\nOptions:\nA. 2 1\nB. 1 2\nC.             2 2\nD. 0 1\n\nAnswer: B\n\nReference Solution:\nThe first line of output will be the results of two operations: I div J and K mod J. The first is integer division; giving the number of times I contains J. Substitu-ting values for I and J we get 1 div 2 = 0. K mod J is defined as K - (K div J)\\textasteriskcenteredJ, or the remainder we get when dividing K by J. 3 mod 2 = 1 Thus the first line of output is 0 1. Then, the program enters the WHILE Loop with I = 1, J = 2, K = 3 and count = l. The first statement is true, so the THEN part is executed. The second IF statement is also true, so the control passes to its THEN part. For the third IF statement to be true, at least one of the conditions, i.e. either K > I or I = J, or both must be true. This is the case, so write1n (I) is executed, outputting 1. Then control passes to the CASE statement. Since COUNT = 1, the statement corresponding to 1 is executed, and J becomes equal to 0. Count is then incremented and becomes equal to 2, going back to the begin-ning of the loop. Count is less than 3, so we go through the loop again. The first IF statement is false this time, and there is no ELSE part corresponding to it. Note that an ELSE always corresponds to the last 'open1 IF before it. Thus the first ELSE statement corresponds to the third IF and the second ELSE to the second IF, and there is no ELSE corresponding to the first IF. Therefore control now passes to the CASE statement, without printing out anything. This time count = 2, so the group of statements corresponding to 2 is executed, setting K to 2, and J to 2 (it had value 0 be-fore). Count is then incremented to 3, which is <=3, so we go through the loop again, with I = 1, J = 2, K = 2, count = 3.The first IF statement is true, the second is not, so the second ELSE is executed, printing out the value of k - 2. Control then passes to the case statement, and the ex-pression corresponding to 3 (the current value of count) is executed setting I to 2. Count then becomes 4, and the loop terminates. The total output of the program is: 1 2", "ref_id": 4758, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "What is the output of the following program? PROGRAM TEST (output); VAR I, J, K, COUNT : integer; BEGIN I: = 1; J: = 2; K: = 3; count: = 1; write1n (I div J, K mod J); while count < = 3 DO BEGIN If I < J then If K > J then If (K > I) or (I = J) then write1n (I) ELSE write1n (J) ELSE write1n (K); CASE COUNT OF 1: J: = 0; 2: BEGIN K: = K - 1; J: = J + K END; 3:I: = 2 \\textasteriskcentered I; END; count : = count + 1; END {while count........} END.", "options": ["2 1", "1 2", "2 2", "0 1"], "answer": "B", "solution": "The first line of output will be the results of two operations: I div J and K mod J. The first is integer division; giving the number of times I contains J. Substitu-ting values for I and J we get 1 div 2 = 0. K mod J is defined as K - (K div J)\\textasteriskcenteredJ, or the remainder we get when dividing K by J. 3 mod 2 = 1 Thus the first line of output is 0 1. Then, the program enters the WHILE Loop with I = 1, J = 2, K = 3 and count = l. The first statement is true, so the THEN part is executed. The second IF statement is also true, so the control passes to its THEN part. For the third IF statement to be true, at least one of the conditions, i.e. either K > I or I = J, or both must be true. This is the case, so write1n (I) is executed, outputting 1. Then control passes to the CASE statement. Since COUNT = 1, the statement corresponding to 1 is executed, and J becomes equal to 0. Count is then incremented and becomes equal to 2, going back to the begin-ning of the loop. Count is less than 3, so we go through the loop again. The first IF statement is false this time, and there is no ELSE part corresponding to it. Note that an ELSE always corresponds to the last 'open1 IF before it. Thus the first ELSE statement corresponds to the third IF and the second ELSE to the second IF, and there is no ELSE corresponding to the first IF. Therefore control now passes to the CASE statement, without printing out anything. This time count = 2, so the group of statements corresponding to 2 is executed, setting K to 2, and J to 2 (it had value 0 be-fore). Count is then incremented to 3, which is <=3, so we go through the loop again, with I = 1, J = 2, K = 2, count = 3.The first IF statement is true, the second is not, so the second ELSE is executed, printing out the value of k - 2. Control then passes to the case statement, and the ex-pression corresponding to 3 (the current value of count) is executed setting I to 2. Count then becomes 4, and the loop terminates. The total output of the program is: 1 2"}, "question": "task_1"}}, {"data": {"text": "Question:\nWhat are the basic differences between acomputer designed for scientific use and the one designed for business use? Also give examples of computer languages designed for scientific use and business use, and compare them .\n\nOptions:\nA. Scientific computers are designed for speed and accuracy and typically use languages like FORTRAN, while business computers are designed for managing large amounts of data and typically use languages like COBOL. Languages like Pascal or C can be used for both.\nB. Business computers are designed for accuracy and minimal data transfer\nC.             Business computers are faster than scientific computers\nD. Scientific computers typically use languages like COBOL\n\nAnswer: A\n\nReference Solution:\nThe scientific computer is designed to be extremely fast and accurate . It will be a number-cruncher where the compu-tations within CPU are very fast, and the I/O to external de-vices is minimal (or none). For example , the embedded systems used in robotics or space applications may not even have any disk or data transfers to disks. These systems generally use the real-time executives that need not carry out file management functions. Supercomputers and high-performance multiple- processor systems are used for scientific applications. A business computer is designed to move vast amounts of data amongst primary memory, secondary storage, I/O peripherals, and communication devices. There may not be too much number crunching, and hence no need for a very fast CPU or multiple processors. In such systems , the disk access is fast, and the secondary storage capacities are high . FORTRAN (derived fromFORmulaTRANslation) is a well-known example of scientific language. It can support various types of numbers (integer, real, complex) in single or double precision. It can accurately and efficiently evaluate complex arithmetic expressions. COBOL (derived fromCOmmonBusiness Oriented Language) is a good example of business language. It can create and access many different types of files, and support complex structured data (records with fields and subfields up to the depth of 49). It has statements for moving large chunks of data, searching through tables and files, sorting, and merging . In short, it has powerful I/O facilities. Language such as Pascal or C may be used for both scien-tific and business applications. These languages can process the mathematical expressions efficiently and also support complex data structures. These languages have some additional features that are desirable for clarity and reliability . Such features include structured programming constructs, strong typing of variables (e.g. as characters, numbers, etc.), block structure with notions of local and global variables.", "ref_id": 4759, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "What are the basic differences between acomputer designed for scientific use and the one designed for business use? Also give examples of computer languages designed for scientific use and business use, and compare them .", "options": ["Scientific computers are designed for speed and accuracy and typically use languages like FORTRAN, while business computers are designed for managing large amounts of data and typically use languages like COBOL. Languages like Pascal or C can be used for both.", "Business computers are designed for accuracy and minimal data transfer", "Business computers are faster than scientific computers", "Scientific computers typically use languages like COBOL"], "answer": "A", "solution": "The scientific computer is designed to be extremely fast and accurate . It will be a number-cruncher where the compu-tations within CPU are very fast, and the I/O to external de-vices is minimal (or none). For example , the embedded systems used in robotics or space applications may not even have any disk or data transfers to disks. These systems generally use the real-time executives that need not carry out file management functions. Supercomputers and high-performance multiple- processor systems are used for scientific applications. A business computer is designed to move vast amounts of data amongst primary memory, secondary storage, I/O peripherals, and communication devices. There may not be too much number crunching, and hence no need for a very fast CPU or multiple processors. In such systems , the disk access is fast, and the secondary storage capacities are high . FORTRAN (derived fromFORmulaTRANslation) is a well-known example of scientific language. It can support various types of numbers (integer, real, complex) in single or double precision. It can accurately and efficiently evaluate complex arithmetic expressions. COBOL (derived fromCOmmonBusiness Oriented Language) is a good example of business language. It can create and access many different types of files, and support complex structured data (records with fields and subfields up to the depth of 49). It has statements for moving large chunks of data, searching through tables and files, sorting, and merging . In short, it has powerful I/O facilities. Language such as Pascal or C may be used for both scien-tific and business applications. These languages can process the mathematical expressions efficiently and also support complex data structures. These languages have some additional features that are desirable for clarity and reliability . Such features include structured programming constructs, strong typing of variables (e.g. as characters, numbers, etc.), block structure with notions of local and global variables."}, "question": "task_1"}}, {"data": {"text": "Question:\nGiven the following program segment, evaluate which elementsof the array A(I) will be a part of the product. PRODUCT = 1; J = 1; N = 12; DOI = 1 BY J TO N; PRODUCT = PRODUCT\\textasteriskcenteredA(I); J = 3I - J; N = N - J; Assume, for purposes of the iteration head, either case a), b),c) or d). a) J and N are only evaluated once on initial entry into the loop, b) J is evaluated only once but N is re-evaluated at each entryinto the loop, c) J is re-evaluated at each entry into the loop, but N is evaluatedonly once, and, d) Both J and N are re-evaluated at each entry into the loop.\n\nOptions:\nA. The product = A(1) \u00d7A(3)\u00d7 A(10) and A(1)\u00d7A(3)\nB. The product = A(1) \u00d7A(2)\u00d7 A(3)\nC.             The product = A(1) \u00d7A(5)\u00d7 A(10)\nD. The product = A(2) \u00d7A(3)\u00d7 A(4)\n\nAnswer: A\n\nReference Solution:\nThe working of this program segment can be best illustrated by the followingtables. a) Values stored in the ITERATION HEAD Values obtained during execution of the program JN I = I+J PRODUCT J = 3I - J N = N - J 112 112 112 112 112 112 112 112 112 112 112 112 1 2 3 4 5 6 7 8 9 10 11 12 1 \u00d7 A (1) 1\u00d7A (1)\u00d7A(2) 1\u00d7A(1)\u00d7A(2)\u00d7(3) 1\u00d7A(1)\u00d7...\u00d7A(4) 1\u00d7A(1)\u00d7...\u00d7A(5) 1\u00d7A(1)\u00d7...\u00d7A(6) 1\u00d7A(1)\u00d7...\u00d7A(7) 1\u00d7A(1)\u00d7...\u00d7A(8) 1\u00d7A(1)\u00d7...\u00d7A(9) 1\u00d7A(1)\u00d7...\u00d7A(10) 1\u00d7A(1)\u00d7...\u00d7A(11) 1\u00d7A(1)\u00d7...\u00d7A(12) 3\u00d71 - 1 = 2 3\u00d72 - 1 = 5 3\u00d73 - 1 = 8 3\u00d74 - 1 = 11 3\u00d75 - 1 = 14 3\u00d76 - 1 =17 3\u00d77 -1 = 20 3\u00d78 - 1 = 23 3\u00d79 - 1 = 26 3\u00d710-1= 29 3\u00d711-1= 32 3\u00d712 -1= 35 12 - 2 =10 10 - 5 = 5 5 - 8 = - 3 - 3 - 11 = -14 -14- 14 = -28 - 28 - 17 = - 45 - 45 - 20 = - 65 - 65 - 23 = - 88 - 88 - 28 = - 116 - 116 - 29 = - 145 - 145 - 32 = - 177 - 177 -35 = - 212 Note that a new value of J and N is computed on each pass through the loop, however these computed values are not entered in the Iteration head whichalways keeps the values J = l and N = 12 which were obtained on thefirst initial entry into the loop. Thus the Product = 1 \u00d7A(l) \u00d7... \u00d7A(12) ,i.e., all the 12 ele-ments of thearray are multiplied out. Thus here, J is entered in the Iteration Head only the first time. Therefore J is always equal to 1. But N is re-evaluated each time in the Head.The looping ends when I>N. Therefore the first three elements of the array are multiplied out. b) Values stored in the ITERATION HEAD Values obtained during execution of the program J N I = I + J PRODUCT = PRODUCT_XA(I) J = 3I - J N = N - J 1 1 1 1 12 10 5 - 3 1 2 3 4 1_XA(1) 1_XA(1)_XA(2) 1_XA(1)_XA(2)_XA(3) 3_X1 - 1 = 2 3_X2 - 1 = 5 3_X3 - 1 = 8 12 - 2 =10 10 - 5 = 5 5 - 8 = - 3 c) Values stored in the ITERATION HEAD Values obtained during execution of the program J N I = I + J PRODUCT = PRODUCT_XA(I) J = 3I - J N = N - J 1 2 7 29 12 12 12 12 1 3 10 39 1_XA(1) 1_XA(1)_XA(3) 1_XA(1)_XA(3)_XA(10) 3_X1 - 1 = 2 3_X3 - 1 = 7 3_X10 - 1 = 29 12 - 2 =10 10 - 7 = 3 3 - 29 = - 26 d) Values stored in the ITERATION HEAD Values obtained during execution of the program J N I = I + J PRODUCT = PRODUCT_XA(I) J = 3I - J N = N - J 1 2 5 12 10 5 1 3 8 1_XA(1) 1_XA(1)_XA(3) 3_X1 - 1 = 2 3_X2 - 1 = 5 12 - 2 =10 10 - 5 = 5 Here, J is re-evaluated in the iteration head after each loop. The product= A(1) \u00d7A(3)\u00d7 A(10) . Both J and N are re-evaluated in the Iteration Head after each loop. The product includes only two terms A(1)\u00d7A(3).", "ref_id": 4760, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Given the following program segment, evaluate which elementsof the array A(I) will be a part of the product. PRODUCT = 1; J = 1; N = 12; DOI = 1 BY J TO N; PRODUCT = PRODUCT\\textasteriskcenteredA(I); J = 3I - J; N = N - J; Assume, for purposes of the iteration head, either case a), b),c) or d). a) J and N are only evaluated once on initial entry into the loop, b) J is evaluated only once but N is re-evaluated at each entryinto the loop, c) J is re-evaluated at each entry into the loop, but N is evaluatedonly once, and, d) Both J and N are re-evaluated at each entry into the loop.", "options": ["The product = A(1) \u00d7A(3)\u00d7 A(10) and A(1)\u00d7A(3)", "The product = A(1) \u00d7A(2)\u00d7 A(3)", "The product = A(1) \u00d7A(5)\u00d7 A(10)", "The product = A(2) \u00d7A(3)\u00d7 A(4)"], "answer": "A", "solution": "The working of this program segment can be best illustrated by the followingtables. a) Values stored in the ITERATION HEAD Values obtained during execution of the program JN I = I+J PRODUCT J = 3I - J N = N - J 112 112 112 112 112 112 112 112 112 112 112 112 1 2 3 4 5 6 7 8 9 10 11 12 1 \u00d7 A (1) 1\u00d7A (1)\u00d7A(2) 1\u00d7A(1)\u00d7A(2)\u00d7(3) 1\u00d7A(1)\u00d7...\u00d7A(4) 1\u00d7A(1)\u00d7...\u00d7A(5) 1\u00d7A(1)\u00d7...\u00d7A(6) 1\u00d7A(1)\u00d7...\u00d7A(7) 1\u00d7A(1)\u00d7...\u00d7A(8) 1\u00d7A(1)\u00d7...\u00d7A(9) 1\u00d7A(1)\u00d7...\u00d7A(10) 1\u00d7A(1)\u00d7...\u00d7A(11) 1\u00d7A(1)\u00d7...\u00d7A(12) 3\u00d71 - 1 = 2 3\u00d72 - 1 = 5 3\u00d73 - 1 = 8 3\u00d74 - 1 = 11 3\u00d75 - 1 = 14 3\u00d76 - 1 =17 3\u00d77 -1 = 20 3\u00d78 - 1 = 23 3\u00d79 - 1 = 26 3\u00d710-1= 29 3\u00d711-1= 32 3\u00d712 -1= 35 12 - 2 =10 10 - 5 = 5 5 - 8 = - 3 - 3 - 11 = -14 -14- 14 = -28 - 28 - 17 = - 45 - 45 - 20 = - 65 - 65 - 23 = - 88 - 88 - 28 = - 116 - 116 - 29 = - 145 - 145 - 32 = - 177 - 177 -35 = - 212 Note that a new value of J and N is computed on each pass through the loop, however these computed values are not entered in the Iteration head whichalways keeps the values J = l and N = 12 which were obtained on thefirst initial entry into the loop. Thus the Product = 1 \u00d7A(l) \u00d7... \u00d7A(12) ,i.e., all the 12 ele-ments of thearray are multiplied out. Thus here, J is entered in the Iteration Head only the first time. Therefore J is always equal to 1. But N is re-evaluated each time in the Head.The looping ends when I>N. Therefore the first three elements of the array are multiplied out. b) Values stored in the ITERATION HEAD Values obtained during execution of the program J N I = I + J PRODUCT = PRODUCT_XA(I) J = 3I - J N = N - J 1 1 1 1 12 10 5 - 3 1 2 3 4 1_XA(1) 1_XA(1)_XA(2) 1_XA(1)_XA(2)_XA(3) 3_X1 - 1 = 2 3_X2 - 1 = 5 3_X3 - 1 = 8 12 - 2 =10 10 - 5 = 5 5 - 8 = - 3 c) Values stored in the ITERATION HEAD Values obtained during execution of the program J N I = I + J PRODUCT = PRODUCT_XA(I) J = 3I - J N = N - J 1 2 7 29 12 12 12 12 1 3 10 39 1_XA(1) 1_XA(1)_XA(3) 1_XA(1)_XA(3)_XA(10) 3_X1 - 1 = 2 3_X3 - 1 = 7 3_X10 - 1 = 29 12 - 2 =10 10 - 7 = 3 3 - 29 = - 26 d) Values stored in the ITERATION HEAD Values obtained during execution of the program J N I = I + J PRODUCT = PRODUCT_XA(I) J = 3I - J N = N - J 1 2 5 12 10 5 1 3 8 1_XA(1) 1_XA(1)_XA(3) 3_X1 - 1 = 2 3_X2 - 1 = 5 12 - 2 =10 10 - 5 = 5 Here, J is re-evaluated in the iteration head after each loop. The product= A(1) \u00d7A(3)\u00d7 A(10) . Both J and N are re-evaluated in the Iteration Head after each loop. The product includes only two terms A(1)\u00d7A(3)."}, "question": "task_1"}}, {"data": {"text": "Question:\nSometimes there is more than one way to write a program. Maybe one method is more efficient than another. Demonstrate this by rewriting the program which uses a characterstring of up to 200 parentheses as input. The programis to deter-mine whether the input string is 'well formed', has too many right parentheses, or, too many left parentheses.\n\nOptions:\nA. A program that does not handle parentheses at all\nB. A program that only calculates the number of parentheses\nC.             STRING:PROCOPTIONS(MAIN); DCL (R,L,T,M) FIXED (3) ,INIT(0), PAR CHAR (200) VAR; /\textasteriskcentered R IS THE COUNT OF THE NUMBER OF RIGHT PARENTHESES, L IS THE COUNT OF THE NUMBER OF LEFT PARENTHESES, T REPRESENTS THE LENGTH OF THE CHARACTER STRING PAR, M IS A VARIABLE TO BE USED IN THE PROGRAM \textasteriskcentered/ PUTLIST('STRING','MESSAGE'); PUT LIST (' ----' ,'-------') SKIP (0) ; PUTSKIP(2); DOWHILE(1 = 1); GETLIST(PAR); PUTLIST(PAR); DO WHILE(R\\lnot>L&T\\lnot = 1) ; T =LENGTH(PAR) ; IFINDEX(PAR,')1) = 1 THEN R = R + 1; ELSE L = L + 1; IF T\\lnot = 1 THEN PAR=SUBSTR(PAR,2) ; END; M = L-R IF M<0 THEN PUT LIST ('UNMATCHED RIGHT PARENTHESES'); ELSE IF M>0 THEN PUT LI ST (M, ' TOO MANY LEFT PARENTHESES'); ELSE PUTLIST('WELL FORMED'); END; PUTSKIP(2); END STRING;\nD. A program that ignores the parentheses order\n\nAnswer: C\n\nReference Solution:\nThe program can be written as follows: STRING:PROCOPTIONS(MAIN); DCL (R,L,T,M) FIXED (3) ,INIT(0), PAR CHAR (200) VAR; /\\textasteriskcentered R IS THE COUNT OF THE NUMBER OF RIGHT PARENTHESES, L IS THE COUNT OF THE NUMBER OF LEFT PARENTHESES, T REPRESENTS THE LENGTH OF THE CHARACTER STRING PAR, M IS A VARIABLE TO BE USED IN THE PROGRAM \\textasteriskcentered/ PUTLIST('STRING','MESSAGE'); PUT LIST (' ----' ,'-------') SKIP (0) ; PUTSKIP(2); DOWHILE(1 = 1); GETLIST(PAR); PUTLIST(PAR); DO WHILE(R\\lnot>L&T\\lnot = 1) ; T =LENGTH(PAR) ; IFINDEX(PAR,')1) = 1 THEN R = R + 1; ELSE L = L + 1; IF T\\lnot = 1 THEN PAR=SUBSTR(PAR,2) ; END; M = L-R IF M<0 THEN PUT LIST ('UNMATCHED RIGHT PARENTHESES'); ELSE IF M>0 THEN PUT LI ST (M, ' TOO MANY LEFT PARENTHESES'); ELSE PUTLIST('WELL FORMED'); END; PUTSKIP(2); END STRING;", "ref_id": 4761, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Sometimes there is more than one way to write a program. Maybe one method is more efficient than another. Demonstrate this by rewriting the program which uses a characterstring of up to 200 parentheses as input. The programis to deter-mine whether the input string is 'well formed', has too many right parentheses, or, too many left parentheses.", "options": ["A program that does not handle parentheses at all", "A program that only calculates the number of parentheses", "STRING:PROCOPTIONS(MAIN); DCL (R,L,T,M) FIXED (3) ,INIT(0), PAR CHAR (200) VAR; /\textasteriskcentered R IS THE COUNT OF THE NUMBER OF RIGHT PARENTHESES, L IS THE COUNT OF THE NUMBER OF LEFT PARENTHESES, T REPRESENTS THE LENGTH OF THE CHARACTER STRING PAR, M IS A VARIABLE TO BE USED IN THE PROGRAM \textasteriskcentered/ PUTLIST('STRING','MESSAGE'); PUT LIST (' ----' ,'-------') SKIP (0) ; PUTSKIP(2); DOWHILE(1 = 1); GETLIST(PAR); PUTLIST(PAR); DO WHILE(R\\lnot>L&T\\lnot = 1) ; T =LENGTH(PAR) ; IFINDEX(PAR,')1) = 1 THEN R = R + 1; ELSE L = L + 1; IF T\\lnot = 1 THEN PAR=SUBSTR(PAR,2) ; END; M = L-R IF M<0 THEN PUT LIST ('UNMATCHED RIGHT PARENTHESES'); ELSE IF M>0 THEN PUT LI ST (M, ' TOO MANY LEFT PARENTHESES'); ELSE PUTLIST('WELL FORMED'); END; PUTSKIP(2); END STRING;", "A program that ignores the parentheses order"], "answer": "C", "solution": "The program can be written as follows: STRING:PROCOPTIONS(MAIN); DCL (R,L,T,M) FIXED (3) ,INIT(0), PAR CHAR (200) VAR; /\\textasteriskcentered R IS THE COUNT OF THE NUMBER OF RIGHT PARENTHESES, L IS THE COUNT OF THE NUMBER OF LEFT PARENTHESES, T REPRESENTS THE LENGTH OF THE CHARACTER STRING PAR, M IS A VARIABLE TO BE USED IN THE PROGRAM \\textasteriskcentered/ PUTLIST('STRING','MESSAGE'); PUT LIST (' ----' ,'-------') SKIP (0) ; PUTSKIP(2); DOWHILE(1 = 1); GETLIST(PAR); PUTLIST(PAR); DO WHILE(R\\lnot>L&T\\lnot = 1) ; T =LENGTH(PAR) ; IFINDEX(PAR,')1) = 1 THEN R = R + 1; ELSE L = L + 1; IF T\\lnot = 1 THEN PAR=SUBSTR(PAR,2) ; END; M = L-R IF M<0 THEN PUT LIST ('UNMATCHED RIGHT PARENTHESES'); ELSE IF M>0 THEN PUT LI ST (M, ' TOO MANY LEFT PARENTHESES'); ELSE PUTLIST('WELL FORMED'); END; PUTSKIP(2); END STRING;"}, "question": "task_1"}}, {"data": {"text": "Question:\nList and briefly describe the steps of program development.\n\nOptions:\nA. Problem identification, Solution design, Implementation, Verification, Maintenance\nB. Analysis, Design, Implementation, Testing, Maintenance\nC.             Definition, Design, Coding, Compiling, Linking, Testing, Documenting\nD. Planning, Analysis, Design, Deployment, Monitoring\n\nAnswer: C\n\nReference Solution:\nA program is developed in a larger context of a soft-ware system. The program development process and the resulting program must fit into the overall scheme of things (analogous to assembly line operations in manufacturing cars) . Above all, the program must function correctly and reliably, and should have clearly defined interfaces to other programs. In the larger context, development of a program (a \"unit\" in software develop-ment jargon) requires the following steps: Definition : This is normally done by the systems analyst who talks to the user (or customer) about requirements, and supplies the programmer with input and output data layouts (specs). Design : With specifications on hand, the programmer designs the program using tools such as flowcharts, hierarchy charts, andpseudocode. Coding : The programmer then enters the program into a file called the source program file, according to the syntax rules of the computer language. Compiling : The programmer verifies the syntax to make sure the compiler produces the object program file without serious diag-nostics (error messages). Linking : The object program file is then linked to other object files and references to symbols not defined locally by the pro-gram are resolved. The linker or link editor used for this pur-pose produces an executable load module in the machine's lan-guage. The \"load module\" is ready to be loaded into the memory and run. Testing : The programmer runs the executable load module using test data that represents application. He checks to make sure the specifications are met with correct outputs. This phase unmasks faults in the design and logic of the program that are referred to as \"bugs.\" The debugging tools are used to identify the source of faults so that they can be fixed (directly or through modification of the source program) . Note that, after testing phase is over, and the program is operational on the field (say, processing cash machine transactions), new faults or bugs may be found. Thus debugging is a continuous process of keeping a program up-to-date and correct in regards to expected results. Documenting : Unless self-documenting, the program must be de-scribed (narrated) so that it can be understood and modified if necessary by other people. However, it is more important to document subsystems that consist of numerous interrelated pro-grams because of greater complexity.", "ref_id": 4762, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "List and briefly describe the steps of program development.", "options": ["Problem identification, Solution design, Implementation, Verification, Maintenance", "Analysis, Design, Implementation, Testing, Maintenance", "Definition, Design, Coding, Compiling, Linking, Testing, Documenting", "Planning, Analysis, Design, Deployment, Monitoring"], "answer": "C", "solution": "A program is developed in a larger context of a soft-ware system. The program development process and the resulting program must fit into the overall scheme of things (analogous to assembly line operations in manufacturing cars) . Above all, the program must function correctly and reliably, and should have clearly defined interfaces to other programs. In the larger context, development of a program (a \"unit\" in software develop-ment jargon) requires the following steps: Definition : This is normally done by the systems analyst who talks to the user (or customer) about requirements, and supplies the programmer with input and output data layouts (specs). Design : With specifications on hand, the programmer designs the program using tools such as flowcharts, hierarchy charts, andpseudocode. Coding : The programmer then enters the program into a file called the source program file, according to the syntax rules of the computer language. Compiling : The programmer verifies the syntax to make sure the compiler produces the object program file without serious diag-nostics (error messages). Linking : The object program file is then linked to other object files and references to symbols not defined locally by the pro-gram are resolved. The linker or link editor used for this pur-pose produces an executable load module in the machine's lan-guage. The \"load module\" is ready to be loaded into the memory and run. Testing : The programmer runs the executable load module using test data that represents application. He checks to make sure the specifications are met with correct outputs. This phase unmasks faults in the design and logic of the program that are referred to as \"bugs.\" The debugging tools are used to identify the source of faults so that they can be fixed (directly or through modification of the source program) . Note that, after testing phase is over, and the program is operational on the field (say, processing cash machine transactions), new faults or bugs may be found. Thus debugging is a continuous process of keeping a program up-to-date and correct in regards to expected results. Documenting : Unless self-documenting, the program must be de-scribed (narrated) so that it can be understood and modified if necessary by other people. However, it is more important to document subsystems that consist of numerous interrelated pro-grams because of greater complexity."}, "question": "task_1"}}, {"data": {"text": "Question:\nExplain why the following statements or expressions are illegal in Pascal.\n\nOptions:\nA. Statements are illegal due to runtime errors\nB. Statements are illegal due to incorrect identifiers, invalid labels, improper assignments, misuse of reserved words, incorrect index types, incorrect subrange, missing END statement, illegal assignment, and type mismatch\nC.             Statements are illegal due to syntax errors\nD. Statements are illegal due to logical errors\n\nAnswer: B\n\nReference Solution:\na) Program name is an identifier. It must start with a letter and continue with letters or digits only. No hyphen is allowed. b) 2.5 is an invalid label. A label must be an integer. c) Constants are defined, not assigned. The correct form is CONST K = 10.5; d) 'New' is a reserved word in Pascal. e) Theindextypeof an array must be a finitesubrange. 'Integer' is not a subrange. f)Anindextypemay not be asubrangeof real numbers. There are infinitelymany real numbers between 3.5 and 8.5. g)Each record definition must end with 'END' statement. h)illegalassignment. Should be y: =7.5; i )Function odd(x) returns abooleanvalue, while p is declared as an integer. Its type must be changed tobooleanfor the statement to be correct.", "ref_id": 4763, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Explain why the following statements or expressions are illegal in Pascal.", "options": ["Statements are illegal due to runtime errors", "Statements are illegal due to incorrect identifiers, invalid labels, improper assignments, misuse of reserved words, incorrect index types, incorrect subrange, missing END statement, illegal assignment, and type mismatch", "Statements are illegal due to syntax errors", "Statements are illegal due to logical errors"], "answer": "B", "solution": "a) Program name is an identifier. It must start with a letter and continue with letters or digits only. No hyphen is allowed. b) 2.5 is an invalid label. A label must be an integer. c) Constants are defined, not assigned. The correct form is CONST K = 10.5; d) 'New' is a reserved word in Pascal. e) Theindextypeof an array must be a finitesubrange. 'Integer' is not a subrange. f)Anindextypemay not be asubrangeof real numbers. There are infinitelymany real numbers between 3.5 and 8.5. g)Each record definition must end with 'END' statement. h)illegalassignment. Should be y: =7.5; i )Function odd(x) returns abooleanvalue, while p is declared as an integer. Its type must be changed tobooleanfor the statement to be correct."}, "question": "task_1"}}, {"data": {"text": "Question:\nA is any 20 \u00d7 20 array. Write a FUNCTION subprogram to compute PD (A, I, J) = [ A(I-1,J) + A(I+1,J) + A(I,J-1) + A(I,J+1)] / 4 Then use it to compute B_ij = (1-\\alpha)B_ij+ \\alpha [{Bi-1, j+Bi+1, j+ Bi, j-1+ Bi, j+1} / 4].\n\nOptions:\nA. FUNCTION PD (A, I, J) DIMENSION A (20, 20) PD = (A (I-2, J) + A (I+2, J) + A (I, J-2) + A (I, J+2)) / 4.0 RETURN END; B(I, J) = [(1.-ALPHA)*B(I, J) + ALPHA*PD(B, I, J)].\nB. FUNCTION PD (A, I, J) DIMENSION A (20, 20) PD = (A (I+1, J) + A (I-1, J) + A (I, J+1) + A (I, J-1)) / 4.0 RETURN END; B(I, J) = [(1.-ALPHA)*B(I, J) + ALPHA*PD(B, I, J)].\nC.             FUNCTION PD (A, I, J) DIMENSION A (20, 20) PD = (A (I-1, J) + A (I+1, J) + A (I, J-1) + A (I, J+1)) / 2.0 RETURN END; B(I, J) = [(1.-ALPHA)*B(I, J) + ALPHA*PD(B, I, J)].\nD. FUNCTION PD (A, I, J) DIMENSION A (20, 20) PD = (A (I-1, J) + A (I+1, J) + A (I, J-1) + A (I, J+1)) / 4.0 RETURN END; B(I, J) = [(1.-ALPHA)*B(I, J) + ALPHA*PD(B, I, J)].\n\nAnswer: D\n\nReference Solution:\nThere are no special tricks involved here. The function looks as follows: FUNCTION PD (A, I, J) DIMENSION A (20, 20) PD = (A (I-1, J) + A (I+1, J) + A (I, J-1) + A (I, J+1)) / 4.0] RETURN END To computeB_ijthe following statement will appear in the main program. Note, that ALPHA has to be defined before this statement occurs. B(I, J) = [(1.-ALPHA)\\textasteriskcenteredB(I, J) + ALPHA\\textasteriskcenteredPD(B, I, J)].", "ref_id": 4764, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "A is any 20 \u00d7 20 array. Write a FUNCTION subprogram to compute PD (A, I, J) = [ A(I-1,J) + A(I+1,J) + A(I,J-1) + A(I,J+1)] / 4 Then use it to compute B_ij = (1-\\alpha)B_ij+ \\alpha [{Bi-1, j+Bi+1, j+ Bi, j-1+ Bi, j+1} / 4].", "options": ["FUNCTION PD (A, I, J) DIMENSION A (20, 20) PD = (A (I-2, J) + A (I+2, J) + A (I, J-2) + A (I, J+2)) / 4.0 RETURN END; B(I, J) = [(1.-ALPHA)*B(I, J) + ALPHA*PD(B, I, J)].", "FUNCTION PD (A, I, J) DIMENSION A (20, 20) PD = (A (I+1, J) + A (I-1, J) + A (I, J+1) + A (I, J-1)) / 4.0 RETURN END; B(I, J) = [(1.-ALPHA)*B(I, J) + ALPHA*PD(B, I, J)].", "FUNCTION PD (A, I, J) DIMENSION A (20, 20) PD = (A (I-1, J) + A (I+1, J) + A (I, J-1) + A (I, J+1)) / 2.0 RETURN END; B(I, J) = [(1.-ALPHA)*B(I, J) + ALPHA*PD(B, I, J)].", "FUNCTION PD (A, I, J) DIMENSION A (20, 20) PD = (A (I-1, J) + A (I+1, J) + A (I, J-1) + A (I, J+1)) / 4.0 RETURN END; B(I, J) = [(1.-ALPHA)*B(I, J) + ALPHA*PD(B, I, J)]."], "answer": "D", "solution": "There are no special tricks involved here. The function looks as follows: FUNCTION PD (A, I, J) DIMENSION A (20, 20) PD = (A (I-1, J) + A (I+1, J) + A (I, J-1) + A (I, J+1)) / 4.0] RETURN END To computeB_ijthe following statement will appear in the main program. Note, that ALPHA has to be defined before this statement occurs. B(I, J) = [(1.-ALPHA)\\textasteriskcenteredB(I, J) + ALPHA\\textasteriskcenteredPD(B, I, J)]."}, "question": "task_1"}}, {"data": {"text": "Question:\nWrite a program, incorporating the function TAN, to compute tangents of angles 0,10,20,....,360 degrees.\n\nOptions:\nA. PROGRAM TABLEOFTANS (OUTPUT); CONST PI = 3.1415926536; VAR DEGREES: INTEGER; FUNCTION TAN (x:REAL):REAL; BEGIN TAN:=sin(x) /cos( x) END; BEGIN( DEGREES: = o; WHILE DEGREES < = 360 DO BEGIN WRITE (DEGREES); IF DEGREES MOD 180 = 90 THEN WRITELN ('INFINITY') ELSE WRITELN (TAN (DEGREES*PI/180)); DEGREES: DEGREES + 10 END END.\nB. PROGRAM TABLEOFTANS (OUTPUT); CONST PI = 3.1415926536; VAR DEGREES: INTEGER; FUNCTION TAN (x:REAL):REAL; BEGIN TAN:=sin(x) /cos( x) END; BEGIN( DEGREES: = o; WHILE DEGREES < = 360 DO BEGIN WRITE (DEGREES); IF DEGREES MOD 180 = 180 THEN WRITELN ('INFINITY') ELSE WRITELN (TAN (DEGREES*PI/180)); DEGREES: DEGREES + 10 END END.\nC.             PROGRAM TABLEOFTANS (OUTPUT); CONST PI = 3.1415926536; VAR DEGREES: INTEGER; FUNCTION TAN (x:REAL):REAL; BEGIN TAN:=sin(x) /cos( x) END; BEGIN( DEGREES: = o; WHILE DEGREES < = 360 DO BEGIN WRITE (DEGREES); IF DEGREES MOD 180 = 90 THEN WRITELN ('INFINITY') ELSE WRITELN (TAN (DEGREES*PI/180)); DEGREES: DEGREES + 5 END END.\nD. PROGRAM TABLEOFTANS (OUTPUT); CONST PI = 3.14; VAR DEGREES: INTEGER; FUNCTION TAN (x:REAL):REAL; BEGIN TAN:=sin(x) /cos( x) END; BEGIN( DEGREES: = o; WHILE DEGREES < = 360 DO BEGIN WRITE (DEGREES); IF DEGREES MOD 180 = 90 THEN WRITELN ('INFINITY') ELSE WRITELN (TAN (DEGREES*PI/180)); DEGREES: DEGREES + 10 END END.\n\nAnswer: A\n\nReference Solution:\nPROGRAM TABLEOFTANS (OUTPUT); CONST PI = 3.1415926536; VAR DEGREES: INTEGER; FUNCTION TAN (x:REAL):REAL; BEGIN TAN:=sin(x) /cos( x) END; (\\textasteriskcenteredTAN\\textasteriskcentered) BEGIN( \\textasteriskcenteredTABLEOFTANS\\textasteriskcentered) DEGREES: = o; WHILE DEGREES < = 360 DO BEGIN WRITE (DEGREES); IF DEGREES MOD 180 = 90 THEN WRITELN ('INFINITY') ELSE WRITELN (TAN (DEGREES\\textasteriskcenteredPI/180)); DEGREES: DEGREES + 10 END END.(\\textasteriskcenteredTABLEOFTANS\\textasteriskcentered).", "ref_id": 4765, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Write a program, incorporating the function TAN, to compute tangents of angles 0,10,20,....,360 degrees.", "options": ["PROGRAM TABLEOFTANS (OUTPUT); CONST PI = 3.1415926536; VAR DEGREES: INTEGER; FUNCTION TAN (x:REAL):REAL; BEGIN TAN:=sin(x) /cos( x) END; BEGIN( DEGREES: = o; WHILE DEGREES < = 360 DO BEGIN WRITE (DEGREES); IF DEGREES MOD 180 = 90 THEN WRITELN ('INFINITY') ELSE WRITELN (TAN (DEGREES*PI/180)); DEGREES: DEGREES + 10 END END.", "PROGRAM TABLEOFTANS (OUTPUT); CONST PI = 3.1415926536; VAR DEGREES: INTEGER; FUNCTION TAN (x:REAL):REAL; BEGIN TAN:=sin(x) /cos( x) END; BEGIN( DEGREES: = o; WHILE DEGREES < = 360 DO BEGIN WRITE (DEGREES); IF DEGREES MOD 180 = 180 THEN WRITELN ('INFINITY') ELSE WRITELN (TAN (DEGREES*PI/180)); DEGREES: DEGREES + 10 END END.", "PROGRAM TABLEOFTANS (OUTPUT); CONST PI = 3.1415926536; VAR DEGREES: INTEGER; FUNCTION TAN (x:REAL):REAL; BEGIN TAN:=sin(x) /cos( x) END; BEGIN( DEGREES: = o; WHILE DEGREES < = 360 DO BEGIN WRITE (DEGREES); IF DEGREES MOD 180 = 90 THEN WRITELN ('INFINITY') ELSE WRITELN (TAN (DEGREES*PI/180)); DEGREES: DEGREES + 5 END END.", "PROGRAM TABLEOFTANS (OUTPUT); CONST PI = 3.14; VAR DEGREES: INTEGER; FUNCTION TAN (x:REAL):REAL; BEGIN TAN:=sin(x) /cos( x) END; BEGIN( DEGREES: = o; WHILE DEGREES < = 360 DO BEGIN WRITE (DEGREES); IF DEGREES MOD 180 = 90 THEN WRITELN ('INFINITY') ELSE WRITELN (TAN (DEGREES*PI/180)); DEGREES: DEGREES + 10 END END."], "answer": "A", "solution": "PROGRAM TABLEOFTANS (OUTPUT); CONST PI = 3.1415926536; VAR DEGREES: INTEGER; FUNCTION TAN (x:REAL):REAL; BEGIN TAN:=sin(x) /cos( x) END; (\\textasteriskcenteredTAN\\textasteriskcentered) BEGIN( \\textasteriskcenteredTABLEOFTANS\\textasteriskcentered) DEGREES: = o; WHILE DEGREES < = 360 DO BEGIN WRITE (DEGREES); IF DEGREES MOD 180 = 90 THEN WRITELN ('INFINITY') ELSE WRITELN (TAN (DEGREES\\textasteriskcenteredPI/180)); DEGREES: DEGREES + 10 END END.(\\textasteriskcenteredTABLEOFTANS\\textasteriskcentered)."}, "question": "task_1"}}, {"data": {"text": "Question:\nFibbonacci.numbersare a sequence of numbers such that the first number is 0, the second number is 1, and each subsequent number is the sum of two preceding numbers, e.g. F_1 = 0 Fn- 1 + Fn - 2, n \\geq 2 F_2 = 1 Write a Pascal program to print out the first 40Fibbonacci numbers and their sum.\n\nOptions:\nA. A C++ program\nB. A Pascal program\nC.             A Python program\nD. A Java program\n\nAnswer: B\n\nReference Solution:\nWe will need five variables for this program: I - to count the number ofiterations .We want only 40 iterations. SUM - to keep the current sum ofnumbers . A, B - the initial two numbers (0 and 1), they will also re-present the two predecessorsof the current number. X - stores the current number, the sum of the above two. PROGRAMFibbonacci(output); VAR A, B, X, I,SUM :integer; BEGIN A : = 0; B : =1; SUM: = 0; {initialize the sum and the 2 initial numbers} FOR I:=1 to 40 DO {Repeat 40 times} BEGIN WRITELN (A); {A is the current number} SUM: = SUM + A; {Update SUM} X: = A + B; {get the next number} A: = B; {A becomes the next predecessor} B: = X {transfer the current number to B} END;{all 40 numbers printed out} WRITEIN ('Thesum of 40Fibbonaccinumbers is', SUM) END.", "ref_id": 4766, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Fibbonacci.numbersare a sequence of numbers such that the first number is 0, the second number is 1, and each subsequent number is the sum of two preceding numbers, e.g. F_1 = 0 Fn- 1 + Fn - 2, n \\geq 2 F_2 = 1 Write a Pascal program to print out the first 40Fibbonacci numbers and their sum.", "options": ["A C++ program", "A Pascal program", "A Python program", "A Java program"], "answer": "B", "solution": "We will need five variables for this program: I - to count the number ofiterations .We want only 40 iterations. SUM - to keep the current sum ofnumbers . A, B - the initial two numbers (0 and 1), they will also re-present the two predecessorsof the current number. X - stores the current number, the sum of the above two. PROGRAMFibbonacci(output); VAR A, B, X, I,SUM :integer; BEGIN A : = 0; B : =1; SUM: = 0; {initialize the sum and the 2 initial numbers} FOR I:=1 to 40 DO {Repeat 40 times} BEGIN WRITELN (A); {A is the current number} SUM: = SUM + A; {Update SUM} X: = A + B; {get the next number} A: = B; {A becomes the next predecessor} B: = X {transfer the current number to B} END;{all 40 numbers printed out} WRITEIN ('Thesum of 40Fibbonaccinumbers is', SUM) END."}, "question": "task_1"}}, {"data": {"text": "Question:\nCompute the sin(x) function, using the notion of the power seriessin(x) = x - (x3/3!)+ (x5/5!)- (x7/7!)+ ...\n\nOptions:\nA. 0.7853980E 00\nB. 0.7071429E 00\nC.             0.7046525E 00\nD. 0.7071069E00\n\nAnswer: D\n\nReference Solution:\nPower series may also be evaluated via Horner's method. When it is decided how many terms are to be evaluated, the series may betreated as a polynomial. However, this illustration will be useful to introducethe idea of precision. Since the computer performs its own roundingoperations, we want to be able to control the degree of precision. First, let us look at what can happen if we do not specify precision: CCOMPUTE EIGHT TERMS OF THE POWER SERIESSIN(Pl/4) CAND PRINT OUT SIN(X), EACH TERM, ANDSIN(Pl/4) REAL PI, XSQ, SINE, TERM, REALI INTEGER I PI = 3.141592 X = PI/4.0 XSQ = X\\textasteriskcentered\\textasteriskcentered2 WRITE (5,100) 100FORMAT (1X, 'SIN(X)', 'TERM') TERM = X SINE = TERM. CDO LOOP IS INDENTED FOR CLARITY DO 20 I = 2, 16, 2 WRITE (5,101) SINE, TERM 101FORMAT (1X, E10.9, 14X, E10.9) REALI = I\\textasteriskcentered(I+1) TERM = -1.0\\textasteriskcentered(TERM\\textasteriskcenteredXSQ)/REALI SINE = SINE + TERM 20CONTINUE WRITE (5,102) X 102FORMAT (1X,'VALUE OFSIN(PI/4) EQUALS ',E10.9) STOP END Sample output: SIN(X)TERM 0.7853980E 000.7853980E 00 0.7046525E 00-0.8074546E-01 0.7071429E 000.2490392E-02 0.7071063E 00-0.3657614E-04 0.7071066E 000.3133609E-06 0.7071066E 00-0.1757242E-08 0.7071066E 000.6948429E-11 0.7071066E 00-0.2041018E-13 VALUE OFSIN(PI/4) EQUALS 0.7071069E00 Notice that after the fifth term, the value of sin(x) does not change. We choose the number of terms to be evaluated, but the computer will roundoff each term, thereby creating an accumulation of errors. The conventionchosen here to avoid this error propagation is the DOUBLE PRECISION statement.Let us declare DOUBLE PRECISION SINE, TERM at the beginning of the program.Now, SINE and TERM will be representedinternally by a bit string which is twice as long as in single preci-sion. The round-off error will accumulate in the least significant bits of thedouble precision number. Finally, when the result is re-turned to single precisionat the end of the computation, only one round-off operation is performed. The other modification needed in double precision is in the FORMAT statement: the letter D must re-place the exponential notation E.", "ref_id": 4767, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Compute the sin(x) function, using the notion of the power seriessin(x) = x - (x3/3!)+ (x5/5!)- (x7/7!)+ ...", "options": ["0.7853980E 00", "0.7071429E 00", "0.7046525E 00", "0.7071069E00"], "answer": "D", "solution": "Power series may also be evaluated via Horner's method. When it is decided how many terms are to be evaluated, the series may betreated as a polynomial. However, this illustration will be useful to introducethe idea of precision. Since the computer performs its own roundingoperations, we want to be able to control the degree of precision. First, let us look at what can happen if we do not specify precision: CCOMPUTE EIGHT TERMS OF THE POWER SERIESSIN(Pl/4) CAND PRINT OUT SIN(X), EACH TERM, ANDSIN(Pl/4) REAL PI, XSQ, SINE, TERM, REALI INTEGER I PI = 3.141592 X = PI/4.0 XSQ = X\\textasteriskcentered\\textasteriskcentered2 WRITE (5,100) 100FORMAT (1X, 'SIN(X)', 'TERM') TERM = X SINE = TERM. CDO LOOP IS INDENTED FOR CLARITY DO 20 I = 2, 16, 2 WRITE (5,101) SINE, TERM 101FORMAT (1X, E10.9, 14X, E10.9) REALI = I\\textasteriskcentered(I+1) TERM = -1.0\\textasteriskcentered(TERM\\textasteriskcenteredXSQ)/REALI SINE = SINE + TERM 20CONTINUE WRITE (5,102) X 102FORMAT (1X,'VALUE OFSIN(PI/4) EQUALS ',E10.9) STOP END Sample output: SIN(X)TERM 0.7853980E 000.7853980E 00 0.7046525E 00-0.8074546E-01 0.7071429E 000.2490392E-02 0.7071063E 00-0.3657614E-04 0.7071066E 000.3133609E-06 0.7071066E 00-0.1757242E-08 0.7071066E 000.6948429E-11 0.7071066E 00-0.2041018E-13 VALUE OFSIN(PI/4) EQUALS 0.7071069E00 Notice that after the fifth term, the value of sin(x) does not change. We choose the number of terms to be evaluated, but the computer will roundoff each term, thereby creating an accumulation of errors. The conventionchosen here to avoid this error propagation is the DOUBLE PRECISION statement.Let us declare DOUBLE PRECISION SINE, TERM at the beginning of the program.Now, SINE and TERM will be representedinternally by a bit string which is twice as long as in single preci-sion. The round-off error will accumulate in the least significant bits of thedouble precision number. Finally, when the result is re-turned to single precisionat the end of the computation, only one round-off operation is performed. The other modification needed in double precision is in the FORMAT statement: the letter D must re-place the exponential notation E."}, "question": "task_1"}}, {"data": {"text": "Question:\nUse the Euler method to solve the equation of motion of a dampedhar-monic oscillator. Let the initial conditions be that att = 0, x(0) = 10 cm anddx/dt= v = 0.\n\nOptions:\nA. 10\nB. -2.96507\nC.             0\nD. -2.5807\n\nAnswer: B\n\nReference Solution:\nThe equation of motion is given by (md2x / dt2) = - ( cdx cdx /dt) -kx /dt) -kx where(-cdx/dt) is the damping force and -kxis the restoring force. Since Euler's method is based on first order differential equations, we rewrite the equationof motion as two first order equations: dx/dt= v(1) dv/dt= -(c/m) v - (k/m)x(2) According to Euler's method, the solution is given by dx\\approx \u2206x =x_new-x_old;dx=vdt) x_new=x_old+v_old\u2206t(1') v_new=v_old+ [(-c/m)v_old-(k/m)x_old)\u2206t(2') Here we have used the general result that ifdy/dx= f(x,y), then y_i+_1 =y_i+y'_i\u2206x, wherey'_i_-= f(x_i ,y_i). For the sake of concreteness we use the following data: m = k = 10, c = 2, x_0 = 10, v_0 =0, D \\equiv \u2206t = 0.1 andwe follow the motion for 2 seconds. 1\\O\\O REM DAMPED HARMONIC OSCILLATOR 1\\O1 REM EULER'S METHOD 1\\O5 PRINT \"TIME\\textquotedblright, \"VELOCITY\", \"POSITION\" 1\\O6 PRINT 11\\O READ M, 1 K, C, X\\O, V\\O, D 12\\O LET X1 = X\\O 121 LET V1 = V\\O 13\\O FOR T = \\O TO 2 STEP D 14\\O PRINT T, V1, X1 15\\O LET X2 =X1 + V1 \\textasteriskcenteredD 151 LET V2 = V1 + (-C\\textasteriskcenteredV1/M - K\\textasteriskcenteredX1/M)\\textasteriskcenteredD 16\\O LET X1 = X2 161 LET V1 =V2 162 NEXT T 8\\O\\O DATA 1\\O,1\\O, 2, 1\\O, \\O, 0.1 999 END Note that the exact solution of t = 2 gives x = -2.5807, compared with the Euler method result of -2.96507. More sophisticated numeri-cal methods (suchas the improved Euler method orRunge-Kuttatype methods) are necessaryfor better accuracy. Finally,v_newcan also be solved with the quadratic equation. If you rearrangethe equation of motion, you can obtain m(d2x / dt2) + c (dx/dt)kx= 0, whichis the quadratic form. This equation has a solution of the form x =e^\\alphat.If we substitute x into the first equation and divide bye^\\alphat,we get thesimpler form m\\alpha2 +c\\alpha+ k = 0. By using thediscrim-inantc2 - 4mk, we candetermine what type of motion is present: If c2 - 4mk is the motion is positive over-damped zero critically-damped negative oscillatory-damped", "ref_id": 4768, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Use the Euler method to solve the equation of motion of a dampedhar-monic oscillator. Let the initial conditions be that att = 0, x(0) = 10 cm anddx/dt= v = 0.", "options": ["10", "-2.96507", "0", "-2.5807"], "answer": "B", "solution": "The equation of motion is given by (md2x / dt2) = - ( cdx cdx /dt) -kx /dt) -kx where(-cdx/dt) is the damping force and -kxis the restoring force. Since Euler's method is based on first order differential equations, we rewrite the equationof motion as two first order equations: dx/dt= v(1) dv/dt= -(c/m) v - (k/m)x(2) According to Euler's method, the solution is given by dx\\approx \u2206x =x_new-x_old;dx=vdt) x_new=x_old+v_old\u2206t(1') v_new=v_old+ [(-c/m)v_old-(k/m)x_old)\u2206t(2') Here we have used the general result that ifdy/dx= f(x,y), then y_i+_1 =y_i+y'_i\u2206x, wherey'_i_-= f(x_i ,y_i). For the sake of concreteness we use the following data: m = k = 10, c = 2, x_0 = 10, v_0 =0, D \\equiv \u2206t = 0.1 andwe follow the motion for 2 seconds. 1\\O\\O REM DAMPED HARMONIC OSCILLATOR 1\\O1 REM EULER'S METHOD 1\\O5 PRINT \"TIME\\textquotedblright, \"VELOCITY\", \"POSITION\" 1\\O6 PRINT 11\\O READ M, 1 K, C, X\\O, V\\O, D 12\\O LET X1 = X\\O 121 LET V1 = V\\O 13\\O FOR T = \\O TO 2 STEP D 14\\O PRINT T, V1, X1 15\\O LET X2 =X1 + V1 \\textasteriskcenteredD 151 LET V2 = V1 + (-C\\textasteriskcenteredV1/M - K\\textasteriskcenteredX1/M)\\textasteriskcenteredD 16\\O LET X1 = X2 161 LET V1 =V2 162 NEXT T 8\\O\\O DATA 1\\O,1\\O, 2, 1\\O, \\O, 0.1 999 END Note that the exact solution of t = 2 gives x = -2.5807, compared with the Euler method result of -2.96507. More sophisticated numeri-cal methods (suchas the improved Euler method orRunge-Kuttatype methods) are necessaryfor better accuracy. Finally,v_newcan also be solved with the quadratic equation. If you rearrangethe equation of motion, you can obtain m(d2x / dt2) + c (dx/dt)kx= 0, whichis the quadratic form. This equation has a solution of the form x =e^\\alphat.If we substitute x into the first equation and divide bye^\\alphat,we get thesimpler form m\\alpha2 +c\\alpha+ k = 0. By using thediscrim-inantc2 - 4mk, we candetermine what type of motion is present: If c2 - 4mk is the motion is positive over-damped zero critically-damped negative oscillatory-damped"}, "question": "task_1"}}, {"data": {"text": "Question:\nConsider the following differential equation with the initial condition y(0) = 1: (dy/dx) = y2 - x2 Develop a FORTRAN program to get a solution for y = y(x) in the in-terval 0 \\leq x \\leq .5 applying the increment method. Let dx = \u2206x = 0.05, and output a table containing the following quantities: x, y, y2, x2, y2 - x2, dy .\n\nOptions:\nA. Java program\nB. C++ program\nC.             FORTRAN program\nD. Python program\n\nAnswer: C\n\nReference Solution:\nLet us first develop the problem from a mathematical view-point. Before we begin solving the equation we must know that a solu-tion exists. Furthermore, this solution should be unique. The exist-ence and uniqueness conditions for the solution of a given differential equation are contained in the following theorems: 1) Existence: Let y' = \\varphi(x, y). 0 \\leq x \\leq 1, - \\infty < y < \\infty, y(0) = c If \\varphi is continuous and bounded, then y = y(x) is a solution of (dy/dx) = \\varphi(x, y). 2) Uniqueness: If there exists a constant A (Lipschitz number) such that \\vert\\varphi(x,y2) - \\varphi(x, y1)\\vert \\leq A \\verty2 - y1\\vert (where (x, y1), (x,y2) are in the domain), then y = y(x) is a unique solution to y' = \\varphi(x, y). The given differential equation is \\varphi(x,y) = (dy/dx) = y2 - x20 \\leq x \\leq 0.5, y(0) = 1 \\varphi(x,y) is a difference of continuous functions; hence it is contin-uous. Clearly\\vert y2 - x2 \\vert is bounded (i.e., less than some constant K) in [0,0.5]. Thus a solution exists. Let A = .3. Then\\vert\\varphi(x, y2) - \\varphi(x, y1)\\vert\\leq .3(y2 - y1) for all (x, y1), (x, y2) in the domain. Thus the solution is unique. We can rewrite equation (1) in the differential form dy = (y2 - x2)dx(2) The increment method entails the use of differentials to find approxi-mate values of y. Thus, let \u2206x = dx, \u2206y = dy. Since the initial condition is y(0) = 1, we can substitute into equation (2) and obtain \u2206y = (12 - 02)(0.05) \u2206y = 0.05 thus, at x = 0.05, y = y0 + \u2206y becomes 1 + 0.05 = 1.05. This means that now y(1.00) becomes 1.05. The next value of \u2206y becomes, there-fore \u2206y = ((1.05)2 - (0.05)2)(0.05) \u2206y = 0.055 As you can see, the method readily lends itself to computer implemen-tation. We can use a FORTRAN main program to print the values in tab-ular form. A subroutine, INCR, can do each calculation and pass the values back to the main program for output. Y = 1.000 DX = 0.05 CWRITE TABLE HEADINGS WRITE (5,100) 100FORMAT (2X, 'X', 5X, 'Y', 6X, 'Y\\textasteriskcentered\\textasteriskcentered2', 3X, 1'X\\textasteriskcentered\\textasteriskcentered2', 3X, 'Y\\textasteriskcentered\\textasteriskcentered2-X\\textasteriskcentered\\textasteriskcentered2', 3X, 'DY') CDO FOR X FROM 1 TO 10 BY 0.05 DO 10 I = 1,10 X = (FLOAT (I) - 1.0)\\textasteriskcentered0.05 CALL INCR (DX, DY, X, Y) XX - X\\textasteriskcentered\\textasteriskcentered2 YY = Y\\textasteriskcentered\\textasteriskcentered2 DYDX = YY - XX WRITE (5,101) X, Y, YY, XX, DYDX, DY 101FORMAT (1X, F4.2,3(2X,F5.3), 4X, F5.3, 5X, F5.3) 10CONTINUE CEND DO - FOR STOP END CSUBROUTINE INCR TO PERFORM CALCULATIONS SUBROUTINE INCR (DX, DY, X, Y) Y = Y + DY DY = ((Y\\textasteriskcentered\\textasteriskcentered2) - (X\\textasteriskcentered\\textasteriskcentered2))\\textasteriskcenteredDX RETURN END", "ref_id": 4769, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Consider the following differential equation with the initial condition y(0) = 1: (dy/dx) = y2 - x2 Develop a FORTRAN program to get a solution for y = y(x) in the in-terval 0 \\leq x \\leq .5 applying the increment method. Let dx = \u2206x = 0.05, and output a table containing the following quantities: x, y, y2, x2, y2 - x2, dy .", "options": ["Java program", "C++ program", "FORTRAN program", "Python program"], "answer": "C", "solution": "Let us first develop the problem from a mathematical view-point. Before we begin solving the equation we must know that a solu-tion exists. Furthermore, this solution should be unique. The exist-ence and uniqueness conditions for the solution of a given differential equation are contained in the following theorems: 1) Existence: Let y' = \\varphi(x, y). 0 \\leq x \\leq 1, - \\infty < y < \\infty, y(0) = c If \\varphi is continuous and bounded, then y = y(x) is a solution of (dy/dx) = \\varphi(x, y). 2) Uniqueness: If there exists a constant A (Lipschitz number) such that \\vert\\varphi(x,y2) - \\varphi(x, y1)\\vert \\leq A \\verty2 - y1\\vert (where (x, y1), (x,y2) are in the domain), then y = y(x) is a unique solution to y' = \\varphi(x, y). The given differential equation is \\varphi(x,y) = (dy/dx) = y2 - x20 \\leq x \\leq 0.5, y(0) = 1 \\varphi(x,y) is a difference of continuous functions; hence it is contin-uous. Clearly\\vert y2 - x2 \\vert is bounded (i.e., less than some constant K) in [0,0.5]. Thus a solution exists. Let A = .3. Then\\vert\\varphi(x, y2) - \\varphi(x, y1)\\vert\\leq .3(y2 - y1) for all (x, y1), (x, y2) in the domain. Thus the solution is unique. We can rewrite equation (1) in the differential form dy = (y2 - x2)dx(2) The increment method entails the use of differentials to find approxi-mate values of y. Thus, let \u2206x = dx, \u2206y = dy. Since the initial condition is y(0) = 1, we can substitute into equation (2) and obtain \u2206y = (12 - 02)(0.05) \u2206y = 0.05 thus, at x = 0.05, y = y0 + \u2206y becomes 1 + 0.05 = 1.05. This means that now y(1.00) becomes 1.05. The next value of \u2206y becomes, there-fore \u2206y = ((1.05)2 - (0.05)2)(0.05) \u2206y = 0.055 As you can see, the method readily lends itself to computer implemen-tation. We can use a FORTRAN main program to print the values in tab-ular form. A subroutine, INCR, can do each calculation and pass the values back to the main program for output. Y = 1.000 DX = 0.05 CWRITE TABLE HEADINGS WRITE (5,100) 100FORMAT (2X, 'X', 5X, 'Y', 6X, 'Y\\textasteriskcentered\\textasteriskcentered2', 3X, 1'X\\textasteriskcentered\\textasteriskcentered2', 3X, 'Y\\textasteriskcentered\\textasteriskcentered2-X\\textasteriskcentered\\textasteriskcentered2', 3X, 'DY') CDO FOR X FROM 1 TO 10 BY 0.05 DO 10 I = 1,10 X = (FLOAT (I) - 1.0)\\textasteriskcentered0.05 CALL INCR (DX, DY, X, Y) XX - X\\textasteriskcentered\\textasteriskcentered2 YY = Y\\textasteriskcentered\\textasteriskcentered2 DYDX = YY - XX WRITE (5,101) X, Y, YY, XX, DYDX, DY 101FORMAT (1X, F4.2,3(2X,F5.3), 4X, F5.3, 5X, F5.3) 10CONTINUE CEND DO - FOR STOP END CSUBROUTINE INCR TO PERFORM CALCULATIONS SUBROUTINE INCR (DX, DY, X, Y) Y = Y + DY DY = ((Y\\textasteriskcentered\\textasteriskcentered2) - (X\\textasteriskcentered\\textasteriskcentered2))\\textasteriskcenteredDX RETURN END"}, "question": "task_1"}}, {"data": {"text": "Question:\nUsing power series, find an approximate solution to the definitein-tegral 1\\int0 sin xdx. Write a FORTRAN program segment.\n\nOptions:\nA. SINDX = (X**3)/2.0 I=1 2 OIF (ABS (TERM) .LT.ERROR) GO TO 5 O N = FLOAT (I) SINDX = SINDX + TERM TERM = -1.0*(X**(2*N + 2)/(2*N+2)*(FACT(2*N+1))) C\nB. SINDX = (X**2)/2.0 I=1 2 OIF (ABS (TERM) .LT.ERROR) GO TO 5 O N = FLOAT (I) SINDX = SINDX + TERM TERM = -1.0*(X**(2*N + 2)/(2*N+2)*(FACT(2*N+1))) C\nC.             SINDX = (X**2)/2.0 I=1 2 OIF (ABS (TERM) .LT.ERROR) GO TO 5 O N = FLOAT (I) SINDX = SINDX + TERM TERM = 1.0*(X**(2*N + 2)/(2*N+2)*(FACT(2*N+1))) C\nD. SINDX = (X**2)/3.0 I=1 2 OIF (ABS (TERM) .LT.ERROR) GO TO 5 O N = FLOAT (I) SINDX = SINDX + TERM TERM = -1.0*(X**(2*N + 2)/(2*N+2)*(FACT(2*N+1))) C\n\nAnswer: B\n\nReference Solution:\nFirst, we must remember that sinx = x - (x3/3!)+ (x5/5!)- (x7/7!)\\bullet\\bullet\\bullet We may then write the integral like this: 1\\int0 sin xdx\\approx1\\int0 [x - (x3/3!)+ (x5/5!)- (x7/7!)]dx assumingwe want to compute only 4 terms. The generalized expansion wouldbe 1\\int0 [x - (x3/3!) + (x5/5!) - (x7/7!)\\bullet\\bullet\\bullet - {(x^2x+1) / (2n + 1)!} + \\bullet\\bullet\\bullet] dx. When integration is performed, we get the generalized primitives as [(x2/2!) - {x4/4(3!)} + {x6/6(5!)} -{x8/8(7!)} \\bullet\\bullet\\bullet {(x^2n+1) / (2n + 2)((2n + 1)!)}]10 We can make use of theFACT(N) function to calculate the integral. Notice thatwe have not defined the accuracy parameter ERROR. You may choosethat value and insert it at the start of the program. Since the lower boundaryof this integral is zero, you need only compute the terms for x = 1. SINDX = (X\\textasteriskcentered\\textasteriskcentered2)/2.0 I=1 2\\OIF (ABS (TERM) .LT.ERROR) GO TO 5\\O N = FLOAT (I) SINDX = SINDX + TERM TERM = -1.0\\textasteriskcentered(X\\textasteriskcentered\\textasteriskcentered(2\\textasteriskcenteredN + 2)/(2\\textasteriskcenteredN+2)\\textasteriskcentered(FACT(2\\textasteriskcenteredN+1))) CIF I IS ODD, TERM IS NEGATIVE. IF I IS CEVEN, TERM IS POSITIVE. IF (2\\textasteriskcentered(I/2).EQ.I) ABS (TERM) = TERM I=1+1 GO TO 2\\O 5\\OWRITE (S,\\textasteriskcentered) SINDX", "ref_id": 4770, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Using power series, find an approximate solution to the definitein-tegral 1\\int0 sin xdx. Write a FORTRAN program segment.", "options": ["SINDX = (X**3)/2.0 I=1 2 OIF (ABS (TERM) .LT.ERROR) GO TO 5 O N = FLOAT (I) SINDX = SINDX + TERM TERM = -1.0*(X**(2*N + 2)/(2*N+2)*(FACT(2*N+1))) C", "SINDX = (X**2)/2.0 I=1 2 OIF (ABS (TERM) .LT.ERROR) GO TO 5 O N = FLOAT (I) SINDX = SINDX + TERM TERM = -1.0*(X**(2*N + 2)/(2*N+2)*(FACT(2*N+1))) C", "SINDX = (X**2)/2.0 I=1 2 OIF (ABS (TERM) .LT.ERROR) GO TO 5 O N = FLOAT (I) SINDX = SINDX + TERM TERM = 1.0*(X**(2*N + 2)/(2*N+2)*(FACT(2*N+1))) C", "SINDX = (X**2)/3.0 I=1 2 OIF (ABS (TERM) .LT.ERROR) GO TO 5 O N = FLOAT (I) SINDX = SINDX + TERM TERM = -1.0*(X**(2*N + 2)/(2*N+2)*(FACT(2*N+1))) C"], "answer": "B", "solution": "First, we must remember that sinx = x - (x3/3!)+ (x5/5!)- (x7/7!)\\bullet\\bullet\\bullet We may then write the integral like this: 1\\int0 sin xdx\\approx1\\int0 [x - (x3/3!)+ (x5/5!)- (x7/7!)]dx assumingwe want to compute only 4 terms. The generalized expansion wouldbe 1\\int0 [x - (x3/3!) + (x5/5!) - (x7/7!)\\bullet\\bullet\\bullet - {(x^2x+1) / (2n + 1)!} + \\bullet\\bullet\\bullet] dx. When integration is performed, we get the generalized primitives as [(x2/2!) - {x4/4(3!)} + {x6/6(5!)} -{x8/8(7!)} \\bullet\\bullet\\bullet {(x^2n+1) / (2n + 2)((2n + 1)!)}]10 We can make use of theFACT(N) function to calculate the integral. Notice thatwe have not defined the accuracy parameter ERROR. You may choosethat value and insert it at the start of the program. Since the lower boundaryof this integral is zero, you need only compute the terms for x = 1. SINDX = (X\\textasteriskcentered\\textasteriskcentered2)/2.0 I=1 2\\OIF (ABS (TERM) .LT.ERROR) GO TO 5\\O N = FLOAT (I) SINDX = SINDX + TERM TERM = -1.0\\textasteriskcentered(X\\textasteriskcentered\\textasteriskcentered(2\\textasteriskcenteredN + 2)/(2\\textasteriskcenteredN+2)\\textasteriskcentered(FACT(2\\textasteriskcenteredN+1))) CIF I IS ODD, TERM IS NEGATIVE. IF I IS CEVEN, TERM IS POSITIVE. IF (2\\textasteriskcentered(I/2).EQ.I) ABS (TERM) = TERM I=1+1 GO TO 2\\O 5\\OWRITE (S,\\textasteriskcentered) SINDX"}, "question": "task_1"}}, {"data": {"text": "Question:\nWrite a program that performs matrix multiplication on a) array matrix [2] [4] and array vector [4], b) Result of multiplication is to be stored in array result [ ]. c) Print the result of multiplication i.e. print each row of result [ ]. d) Assume column vector contains {12 3 4} and matrix contains values [0 1 2 3] and [1 2 3 4].\n\nOptions:\nA. The program performs addition on the given arrays.\nB. The program checks if the given arrays are equals.\nC.             The program calculates the determinant of the given matrix.\nD. The program performs matrix multiplication on the given arrays and prints the result.\n\nAnswer: D\n\nReference Solution:\n# include < stdio. h > # define NUM _ C0L 4 /\\textasteriskcenteredno. of columns\\textasteriskcentered/ # define NUM _ R0WS 2 /\\textasteriskcenteredno. of rows\\textasteriskcentered/ main ( ) { int matrix [NUM _ R0WS][NUM _ COL]; /\\textasteriskcenteredcreates a 2 \u00d7 4.array of type integer\\textasteriskcentered/ int vector [NUM _ COL]; int result [NUM _ ROWS]; /\\textasteriskcenteredTo store the result of multiplication \\textasteriskcentered/ int i, j; /\\textasteriskcenteredsubscripts or counters \\textasteriskcentered/ /\\textasteriskcentered1. Initialize the matrix, vector and result\\textasteriskcentered/ for (i = 0; i < NUM _ ROWS; i++) /\\textasteriskcenteredSet result to zero\\textasteriskcentered/ result [i] = 0; for (i = 0; i < NUM _ C0L; i++) /\\textasteriskcenteredset vector to 1 2 3 and 4 \\textasteriskcentered/ vector [i] = i + 1; for (i = 0; i < NUM _ R0WS; i++) for ( j = 0; j < NUM _ COL; j++) /\\textasteriskcenteredset matrix to 0 1 2 3\\textasteriskcentered/ /\\textasteriskcentered1 2 3 4\\textasteriskcentered/ matrix [i] [ j] = i + j; /\\textasteriskcentered2. Perform matrix multiplication \\textasteriskcentered/ for (i = 0; i < NUM_R0WS; i++) for ( j = 0; j < NUM_COL; j++) result [i] = result [i] + matrix [i] [ j] \\textasteriskcentered vector [ j]; printf (\"The result of matrix multiplication = \"); /\\textasteriskcenteredPrint each row of result [ ]\\textasteriskcentered/ for ( j = 0; j < NUM _ ROWS; j++) printf (\"%d\", result [ j]); /\\textasteriskcenteredput newline character\\textasteriskcentered/ put char ('\\textbackslashn'); }", "ref_id": 4771, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Write a program that performs matrix multiplication on a) array matrix [2] [4] and array vector [4], b) Result of multiplication is to be stored in array result [ ]. c) Print the result of multiplication i.e. print each row of result [ ]. d) Assume column vector contains {12 3 4} and matrix contains values [0 1 2 3] and [1 2 3 4].", "options": ["The program performs addition on the given arrays.", "The program checks if the given arrays are equals.", "The program calculates the determinant of the given matrix.", "The program performs matrix multiplication on the given arrays and prints the result."], "answer": "D", "solution": "# include < stdio. h > # define NUM _ C0L 4 /\\textasteriskcenteredno. of columns\\textasteriskcentered/ # define NUM _ R0WS 2 /\\textasteriskcenteredno. of rows\\textasteriskcentered/ main ( ) { int matrix [NUM _ R0WS][NUM _ COL]; /\\textasteriskcenteredcreates a 2 \u00d7 4.array of type integer\\textasteriskcentered/ int vector [NUM _ COL]; int result [NUM _ ROWS]; /\\textasteriskcenteredTo store the result of multiplication \\textasteriskcentered/ int i, j; /\\textasteriskcenteredsubscripts or counters \\textasteriskcentered/ /\\textasteriskcentered1. Initialize the matrix, vector and result\\textasteriskcentered/ for (i = 0; i < NUM _ ROWS; i++) /\\textasteriskcenteredSet result to zero\\textasteriskcentered/ result [i] = 0; for (i = 0; i < NUM _ C0L; i++) /\\textasteriskcenteredset vector to 1 2 3 and 4 \\textasteriskcentered/ vector [i] = i + 1; for (i = 0; i < NUM _ R0WS; i++) for ( j = 0; j < NUM _ COL; j++) /\\textasteriskcenteredset matrix to 0 1 2 3\\textasteriskcentered/ /\\textasteriskcentered1 2 3 4\\textasteriskcentered/ matrix [i] [ j] = i + j; /\\textasteriskcentered2. Perform matrix multiplication \\textasteriskcentered/ for (i = 0; i < NUM_R0WS; i++) for ( j = 0; j < NUM_COL; j++) result [i] = result [i] + matrix [i] [ j] \\textasteriskcentered vector [ j]; printf (\"The result of matrix multiplication = \"); /\\textasteriskcenteredPrint each row of result [ ]\\textasteriskcentered/ for ( j = 0; j < NUM _ ROWS; j++) printf (\"%d\", result [ j]); /\\textasteriskcenteredput newline character\\textasteriskcentered/ put char ('\\textbackslashn'); }"}, "question": "task_1"}}, {"data": {"text": "Question:\nPROGRAM EXAMPLE (output); VAR A, B, C, D: integer; PROCEDURE PI (a, b, c,d :integer); BEGIN A: = A + B + C; B: = C + A END; PROCEDURE P2 (a, b: integer; VAR C:integer); BEGIN A: = A + B \\textasteriskcentered C; B: = B - A; C: = A; END; PROCEDURE P3 (VAR a, b: integer); VARC :integer; BEGIN C: = 10; A: = A + C; B: = B + D; C: = A - B; END; BEGIN{main part of the program} A: = 1; B: = 2; C: = 3; D: = 4; P1 (a, b, c, d); write1n (a ,b , c ,d); P2 (a,b ,c); write1n(a , b , c ,d); P3 (a, b);write1n(a , b ,c ,d) END.\n\nOptions:\nA. The output of the final write1n statement is 1 2 3 4.\nB. The output of the final write1n statement is 11 6 7 4.\nC.             The output of the final write1n statement is 7 5 7 4.\nD. The output of the final write1n statement is 10 11 6 4.\n\nAnswer: B\n\nReference Solution:\nThe key to understanding what this program doesis understanding the difference between calls by reference and calls by value. When procedure P1 is invoked, param-eters A,B,C and D are passed to it. Since these param-eters are not preceded byVARin the procedure declaration, these are not variable parameters. This is known as call by value - i.e. only values of these parameters are passed, to the procedure, and if their values are changed during the execution of that procedure, these changes do not become permanent. Therefore, executing procedure P1 doesn't really change the values of A, B, C, and D, and the first write1n statement prints 1 2 3 4. In the second procedure P2, C is variable parameter- meaning that its memory location is passed to the procedure, and consequently, any changes in its value become permanent. This is an example of a call by reference . During the execution of the procedure, A becomes equal to 7, B to -5, and C to 7. Since C is variable parameter, it passes this value back to the variable C in the main program. The output after second WRITELN statement is then 1274. In the third procedure P3, C is declared as a local variable, and in all subsequent references to it within that procedure it is treated as such, having nothing to do with the C in the main program. Executing the statements of the procedure, we get: C:=10; A:= 11, B:= 6; C:= +5. A and B are variable parameters, their values are passed back to the calling variables. C is a local variable, which is \"lost\" after the procedure is executed , the value of C in the main program remains 7, and D retains its original value of 4. So the output of the final write1n statement is 11 6 7 4.", "ref_id": 4772, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "PROGRAM EXAMPLE (output); VAR A, B, C, D: integer; PROCEDURE PI (a, b, c,d :integer); BEGIN A: = A + B + C; B: = C + A END; PROCEDURE P2 (a, b: integer; VAR C:integer); BEGIN A: = A + B \\textasteriskcentered C; B: = B - A; C: = A; END; PROCEDURE P3 (VAR a, b: integer); VARC :integer; BEGIN C: = 10; A: = A + C; B: = B + D; C: = A - B; END; BEGIN{main part of the program} A: = 1; B: = 2; C: = 3; D: = 4; P1 (a, b, c, d); write1n (a ,b , c ,d); P2 (a,b ,c); write1n(a , b , c ,d); P3 (a, b);write1n(a , b ,c ,d) END.", "options": ["The output of the final write1n statement is 1 2 3 4.", "The output of the final write1n statement is 11 6 7 4.", "The output of the final write1n statement is 7 5 7 4.", "The output of the final write1n statement is 10 11 6 4."], "answer": "B", "solution": "The key to understanding what this program doesis understanding the difference between calls by reference and calls by value. When procedure P1 is invoked, param-eters A,B,C and D are passed to it. Since these param-eters are not preceded byVARin the procedure declaration, these are not variable parameters. This is known as call by value - i.e. only values of these parameters are passed, to the procedure, and if their values are changed during the execution of that procedure, these changes do not become permanent. Therefore, executing procedure P1 doesn't really change the values of A, B, C, and D, and the first write1n statement prints 1 2 3 4. In the second procedure P2, C is variable parameter- meaning that its memory location is passed to the procedure, and consequently, any changes in its value become permanent. This is an example of a call by reference . During the execution of the procedure, A becomes equal to 7, B to -5, and C to 7. Since C is variable parameter, it passes this value back to the variable C in the main program. The output after second WRITELN statement is then 1274. In the third procedure P3, C is declared as a local variable, and in all subsequent references to it within that procedure it is treated as such, having nothing to do with the C in the main program. Executing the statements of the procedure, we get: C:=10; A:= 11, B:= 6; C:= +5. A and B are variable parameters, their values are passed back to the calling variables. C is a local variable, which is \"lost\" after the procedure is executed , the value of C in the main program remains 7, and D retains its original value of 4. So the output of the final write1n statement is 11 6 7 4."}, "question": "task_1"}}, {"data": {"text": "Question:\nA two-dimensional array named RST has twenty rows and twenty columns. Use FORTRAN to compute the product of the main diagonal elements of RST and store it in BPROD. A main diagonal element is the one that has the same row and column number, so that DPROD = 20\\prod_i= 1RST(I, I).\n\nOptions:\nA. Initialize DPROD =1.0 and set up a loop which computes DPROD by dividing its previous value by RST(I,I)\nB. Initialize DPROD =1.0 and set up a loop which computes DPROD by adding its previous value to RST(I,I)\nC.             Initialize DPROD = 0 and set up a loop which computes DPROD by multiplying its previous value by RST(I,I)\nD. Initialize DPROD =1.0 and set up a loop which computes DPROD by multiplying its previous value by RST(I,I)\n\nAnswer: D\n\nReference Solution:\nThe essential trick is to initialize DPROD =1.0 and then set up a loop which computes DPROD by multiplying its previous value by RST(I,I). DIMENSION RST (20, 20) DPROD =1.0 DO 30 I = 1,20 DPROD = DPROD\\textasteriskcenteredRST(I,I) 30CONTINUE STOP END", "ref_id": 4773, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "A two-dimensional array named RST has twenty rows and twenty columns. Use FORTRAN to compute the product of the main diagonal elements of RST and store it in BPROD. A main diagonal element is the one that has the same row and column number, so that DPROD = 20\\prod_i= 1RST(I, I).", "options": ["Initialize DPROD =1.0 and set up a loop which computes DPROD by dividing its previous value by RST(I,I)", "Initialize DPROD =1.0 and set up a loop which computes DPROD by adding its previous value to RST(I,I)", "Initialize DPROD = 0 and set up a loop which computes DPROD by multiplying its previous value by RST(I,I)", "Initialize DPROD =1.0 and set up a loop which computes DPROD by multiplying its previous value by RST(I,I)"], "answer": "D", "solution": "The essential trick is to initialize DPROD =1.0 and then set up a loop which computes DPROD by multiplying its previous value by RST(I,I). DIMENSION RST (20, 20) DPROD =1.0 DO 30 I = 1,20 DPROD = DPROD\\textasteriskcenteredRST(I,I) 30CONTINUE STOP END"}, "question": "task_1"}}, {"data": {"text": "Question:\nDefine the term \"debugging.\"\n\nOptions:\nA. Debugging means deploying a program.\nB. Debugging a program means the modification of programs, throughout its lifetime, in order to fix the faults that produce unacceptable or unexpected results.\nC.             Debugging is the process of creating bugs.\nD. Debugging is the process of testing a program.\n\nAnswer: B\n\nReference Solution:\nThe program, even after being tested and accepted as valid, may still have faults that will manifest themselves for certain input sequences. Such hidden faults that are not readily detectable are called \"bugs.\" Debugging a program means the modification of programs, throughout its lifetime , in order to fix the faults that produce unacceptable or unexpected results . Thus, as opposed to \"unit testing\" that simply makes the program \"acceptable\" for the specified input-output sequences, the de-bugging process involves the entire life cycle of a computer program.", "ref_id": 4774, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Define the term \"debugging.\"", "options": ["Debugging means deploying a program.", "Debugging a program means the modification of programs, throughout its lifetime, in order to fix the faults that produce unacceptable or unexpected results.", "Debugging is the process of creating bugs.", "Debugging is the process of testing a program."], "answer": "B", "solution": "The program, even after being tested and accepted as valid, may still have faults that will manifest themselves for certain input sequences. Such hidden faults that are not readily detectable are called \"bugs.\" Debugging a program means the modification of programs, throughout its lifetime , in order to fix the faults that produce unacceptable or unexpected results . Thus, as opposed to \"unit testing\" that simply makes the program \"acceptable\" for the specified input-output sequences, the de-bugging process involves the entire life cycle of a computer program."}, "question": "task_1"}}, {"data": {"text": "Question:\nDefine and draw a contrast between compilers and interpreters .\n\nOptions:\nA. Both compilers and interpreters translate the entire program into machine language.\nB. A compiler interprets the statements one by one, while an interpreter translates the entire program into machine language.\nC.             A compiler translates the entire program into the machine language equivalent, while an interpreter interprets the statements one by one and directs the computer to do what the high-level statement intends.\nD. Compilers and interpreters are the same in how they process high-level languages.\n\nAnswer: C\n\nReference Solution:\nA compiler is a translator program that converts the entire program into the machine language equivalent. Once translated, the program can be run over and over unless logi-cally modified. Compilers treat the program written in a high- level language as data, and may use several passes (processing of the entire program) to produce the correct and efficient machine language equivalent. Therefore, if frequent modifica-tions of the program source code is required, the compiler is not very efficient. An interpreter is a translator program that interprets the statements one by one (on the fly so to speak) and directs the computer to do what the high-level statement intends. The trans-lation takes place every time the program is run. The interpret-ers slow down the execution of a program , but tend to be highly interactive, where frequent modifications and reruns of a source language program is easy. Thus, during the development phase that we can regard as the experimental phase, it is best to interpret a high-level language (HLL) program. After the program is thoroughly tested and debugged, it may then be compiled into an object code ready to be executed. Note that some languages, such as C, allow both interpreta-tion and compilation . In some cases, it is possible to have both an interpreter and a compiler for a language such as BASIC or Lisp on the same computer system . Therefore, whether a high level language program should be interpreted or compiled becomes a matter of convenience.", "ref_id": 4775, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Define and draw a contrast between compilers and interpreters .", "options": ["Both compilers and interpreters translate the entire program into machine language.", "A compiler interprets the statements one by one, while an interpreter translates the entire program into machine language.", "A compiler translates the entire program into the machine language equivalent, while an interpreter interprets the statements one by one and directs the computer to do what the high-level statement intends.", "Compilers and interpreters are the same in how they process high-level languages."], "answer": "C", "solution": "A compiler is a translator program that converts the entire program into the machine language equivalent. Once translated, the program can be run over and over unless logi-cally modified. Compilers treat the program written in a high- level language as data, and may use several passes (processing of the entire program) to produce the correct and efficient machine language equivalent. Therefore, if frequent modifica-tions of the program source code is required, the compiler is not very efficient. An interpreter is a translator program that interprets the statements one by one (on the fly so to speak) and directs the computer to do what the high-level statement intends. The trans-lation takes place every time the program is run. The interpret-ers slow down the execution of a program , but tend to be highly interactive, where frequent modifications and reruns of a source language program is easy. Thus, during the development phase that we can regard as the experimental phase, it is best to interpret a high-level language (HLL) program. After the program is thoroughly tested and debugged, it may then be compiled into an object code ready to be executed. Note that some languages, such as C, allow both interpreta-tion and compilation . In some cases, it is possible to have both an interpreter and a compiler for a language such as BASIC or Lisp on the same computer system . Therefore, whether a high level language program should be interpreted or compiled becomes a matter of convenience."}, "question": "task_1"}}, {"data": {"text": "Question:\nFor the following PL/I program, a) Explain how a condition called ENDFILE CONDITION' arises. b) Show what will be printed out if the program is run. c) Write out a corrected program to avoid errors due to this condition . d) Show what the printout from the corrected program will be . EXAMPLE:PROCOPTIONS(MAIN); DCL(X,Y,Z) FIXED(3) INIT(0); GETLIST(Z); DO I = 1 TO Z; GET LIST(X); Y = Y + X; PUTLIST(I,Y); END; PUTLIST(21,Y); END EXAMPLE; The DATA CARD contains the following data: 8, 0, 1, 2, 3, 4, 5, 6\n\nOptions:\nA. STARTFILE CONDITION\nB. ENDFILE CONDITION\nC.             OVERFLOW CONDITION\nD. UNDERFLOW CONDITION\n\nAnswer: B\n\nReference Solution:\na) The purpose of the above program is to illus-trate a condition knownas ENDFILE CONDITION. In this program, the GETLIST(Z) statement reads a value for Z fromthe DATA CARD. Hence, Z = 8. This value of Z be-comes the upper limitfor the loop of the next statement. Hence, the loop statement becomes: DO I = 1 TO 8. During each loop, a value of X is read from the card and the sum Y = Y + x is calculated. Now, observe that there are only 7 values of X (0 to 6) punched on theDATA CARD. Hence, when the program enters the eighth loop, the computerfinds that the data have run out and terminates the program. This condition of data running out is known as an ENDFILE CONDITION, b) The printout of the computer is as follows: 10 21 33 46 510 615 721 After the seventh loop, Igetsa value of 8. Now the program tries to executeGET LIST(X). But since there is no 8th value ofX,the program haltsgiving out an error message. So there is no chance for executing the otherPUT LIST statement which follows outside the loop. c) The program can be corrected by inserting an ON statement of the generalform ON ENDPILE (FILE NAME) ACTION; The above statement prevents termination of the program abrupt-ly on the occurrenceof the ENDFILE CONDITION. Inside the parentheses, the name of the file,which is to be used, shouldbe specified. For example, if punched cards are being used for input, the name of the input file is (SYSIN). 'ACTION' in the above statement means some sort of in-struction to thecomputer telling it what to do if the data on the file run out. The correctedprogram can therefore be written as follows: EXAMPLE:PROCOPTIONS(MAIN); DCL (X,Y,Z) FIXED(3), INIT(O) ; ONENDFILE(SYSIN) GOTO A ; GETLIST(Z); DO I = 1 TO Z; GET LIST(X) ; Y = Y +X ; PUTLIST(I,Y) ; END ; A:PUTLIST(21,Y); END EXAMPLE; d) The printout from the corrected program will be: 10 21 33 46 510 615 721 1621 Note that after the seventh loop is completed, the computer goes back to theloop head, viz., DO I = 1 TO Z. As Z = 8, therefore I is incremented by 1 from 7 to 8. Now, on trying to executethe next statement, viz., GET LIST(X), the computer finds that an ENDFILE CONDITION has occurred on the SYSIN file. Hence, the programgoes to the statementlabelled'A'. This statement is PUT LIST(2I,Y);. The lat-est values of I and Y lying in the program are 7 and 22 re-spectively; therefore 16 and 22 are printed out. The pro-gram now goes tothe next statement END EXAMPLE which is a normal end of the program.", "ref_id": 4776, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "For the following PL/I program, a) Explain how a condition called ENDFILE CONDITION' arises. b) Show what will be printed out if the program is run. c) Write out a corrected program to avoid errors due to this condition . d) Show what the printout from the corrected program will be . EXAMPLE:PROCOPTIONS(MAIN); DCL(X,Y,Z) FIXED(3) INIT(0); GETLIST(Z); DO I = 1 TO Z; GET LIST(X); Y = Y + X; PUTLIST(I,Y); END; PUTLIST(21,Y); END EXAMPLE; The DATA CARD contains the following data: 8, 0, 1, 2, 3, 4, 5, 6", "options": ["STARTFILE CONDITION", "ENDFILE CONDITION", "OVERFLOW CONDITION", "UNDERFLOW CONDITION"], "answer": "B", "solution": "a) The purpose of the above program is to illus-trate a condition knownas ENDFILE CONDITION. In this program, the GETLIST(Z) statement reads a value for Z fromthe DATA CARD. Hence, Z = 8. This value of Z be-comes the upper limitfor the loop of the next statement. Hence, the loop statement becomes: DO I = 1 TO 8. During each loop, a value of X is read from the card and the sum Y = Y + x is calculated. Now, observe that there are only 7 values of X (0 to 6) punched on theDATA CARD. Hence, when the program enters the eighth loop, the computerfinds that the data have run out and terminates the program. This condition of data running out is known as an ENDFILE CONDITION, b) The printout of the computer is as follows: 10 21 33 46 510 615 721 After the seventh loop, Igetsa value of 8. Now the program tries to executeGET LIST(X). But since there is no 8th value ofX,the program haltsgiving out an error message. So there is no chance for executing the otherPUT LIST statement which follows outside the loop. c) The program can be corrected by inserting an ON statement of the generalform ON ENDPILE (FILE NAME) ACTION; The above statement prevents termination of the program abrupt-ly on the occurrenceof the ENDFILE CONDITION. Inside the parentheses, the name of the file,which is to be used, shouldbe specified. For example, if punched cards are being used for input, the name of the input file is (SYSIN). 'ACTION' in the above statement means some sort of in-struction to thecomputer telling it what to do if the data on the file run out. The correctedprogram can therefore be written as follows: EXAMPLE:PROCOPTIONS(MAIN); DCL (X,Y,Z) FIXED(3), INIT(O) ; ONENDFILE(SYSIN) GOTO A ; GETLIST(Z); DO I = 1 TO Z; GET LIST(X) ; Y = Y +X ; PUTLIST(I,Y) ; END ; A:PUTLIST(21,Y); END EXAMPLE; d) The printout from the corrected program will be: 10 21 33 46 510 615 721 1621 Note that after the seventh loop is completed, the computer goes back to theloop head, viz., DO I = 1 TO Z. As Z = 8, therefore I is incremented by 1 from 7 to 8. Now, on trying to executethe next statement, viz., GET LIST(X), the computer finds that an ENDFILE CONDITION has occurred on the SYSIN file. Hence, the programgoes to the statementlabelled'A'. This statement is PUT LIST(2I,Y);. The lat-est values of I and Y lying in the program are 7 and 22 re-spectively; therefore 16 and 22 are printed out. The pro-gram now goes tothe next statement END EXAMPLE which is a normal end of the program."}, "question": "task_1"}}, {"data": {"text": "Question:\nConvert the following logical expressions to reverse Polish string notation: (a) (Z \\downarrow ((((X) \\odot Y) / (X \\odot (Z))) > ((Y) \\equiv X))) (b) (X / Y) / ((X / X) / (Y / Y))\n\nOptions:\nA. ZX\nceilY \\odot XZ\nceil \\odot / Y\nceilX\\equiv> \\downarrow, XX / XY / YY / / /\nB. ZX\nceilY \\odot XZ\nceil \\odot / Y\nceilX\\equiv> \\downarrow, XY / XX / YY / / /\nC.             Z\nceilXY \\odot XZ\nceil \\odot / Y\nceilX\\equiv> \\downarrow, XY / XX / YY / / /\nD. ZX\nceilX \\odot YZ\nceil \\odot / Y\nceilX\\equiv> \\downarrow, XY / XX / YY / / /\n\nAnswer: B\n\nReference Solution:\nPolish notation is a way of representing logical and algebraic expressions without using parentheses, unless parentheses represent some variables or operators in the particular expression. If you think about it, the purpose of parentheses is to override the natural hierarchy of the operators. Polish notation does away with that notion. All operators have the same precedence: their position in the string determines their order of evaluation. With reverse Polish notation, also called Polish post-fix, the operator is written after its two operands. For example, the usual logical equation A \\oplus B would be written AB \\oplus in postfix notation. It is possible to use trees to evaluate Polish strings, but we will not do so here. a) As we can see in this example, the abundance of parentheses makes this expression look formidable. We will proceed step-by-step, enclosing in brackets each portion of the expression that has been converted. Step 1. First, we will take care of the negations. We use the symbol \\rceil for this operator. (Z \\downarrow ((([X\\rceil] \\odot Y) / (X \\odot [Z\\rceil])) > ([Y\\rceil] \\equiv X))) (Z \\downarrow ((([X\\rceil] \\odot Y) / (X \\odot [Z\\rceil])) > ([Y\\rceil] \\equiv X))) Step 2. We consider next the innermost partial expressions and convert them. (Z \\downarrow (([X\\rceilY \\odot] / (X Z\\rceil \\odot]) > ([Y\\rceilX\\equiv])) Step 3. Now we include the NAND operator / to complete the innermost partial expression. (Z \\downarrow ([X\\rceilY \\odot XZ\\rceil \\odot / ] > [Y\\rceilX\\equiv])) Step 4. We evaluate the operator >, inserting it at the end of the string. (Z \\downarrow [X\\rceilY \\odot XZ\\rceil \\odot / Y\\rceilX \\equiv >]) (Z \\downarrow [X\\rceilY \\odot XZ\\rceil \\odot / Y\\rceilX \\equiv >]) Step 5. Finally, we add the NOR operator \\downarrow to the end of the string. The final reverse Polish string is ZX\\rceilY \\odot XZ\\rceil \\odot / Y\\rceilX\\equiv> ZX\\rceilY \\odot XZ\\rceil \\odot / Y\\rceilX\\equiv> \\downarrow b) This problem uses solely the NAND operator/and several parentheses. We will proceed as before, evaluating the innermost parentheses first. Step 1. The two inner expressions on the right side get translated and bracketed first. (X / Y) / ([XX / ] / [YY / ]) (X / Y) / ([XX / ] / [YY / ]) Step 2. Next we merge the two bracketed expressions together over the NAND operator. (X / Y) / [XX / YY / / ] (X / Y) / [XX / YY / / ] Step 3. Now we convert the right side. [XY / ] / [XX / YY / / ] [XY / ] / [XX / YY / / ] Step 4. Finally, the entire expression, translated into a reverse Polish string looks like this. XY / XX / YY / / /", "ref_id": 4777, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Convert the following logical expressions to reverse Polish string notation: (a) (Z \\downarrow ((((X) \\odot Y) / (X \\odot (Z))) > ((Y) \\equiv X))) (b) (X / Y) / ((X / X) / (Y / Y))", "options": ["ZX\nceilY \\odot XZ\nceil \\odot / Y\nceilX\\equiv> \\downarrow, XX / XY / YY / / /", "ZX\nceilY \\odot XZ\nceil \\odot / Y\nceilX\\equiv> \\downarrow, XY / XX / YY / / /", "Z\nceilXY \\odot XZ\nceil \\odot / Y\nceilX\\equiv> \\downarrow, XY / XX / YY / / /", "ZX\nceilX \\odot YZ\nceil \\odot / Y\nceilX\\equiv> \\downarrow, XY / XX / YY / / /"], "answer": "B", "solution": "Polish notation is a way of representing logical and algebraic expressions without using parentheses, unless parentheses represent some variables or operators in the particular expression. If you think about it, the purpose of parentheses is to override the natural hierarchy of the operators. Polish notation does away with that notion. All operators have the same precedence: their position in the string determines their order of evaluation. With reverse Polish notation, also called Polish post-fix, the operator is written after its two operands. For example, the usual logical equation A \\oplus B would be written AB \\oplus in postfix notation. It is possible to use trees to evaluate Polish strings, but we will not do so here. a) As we can see in this example, the abundance of parentheses makes this expression look formidable. We will proceed step-by-step, enclosing in brackets each portion of the expression that has been converted. Step 1. First, we will take care of the negations. We use the symbol \\rceil for this operator. (Z \\downarrow ((([X\\rceil] \\odot Y) / (X \\odot [Z\\rceil])) > ([Y\\rceil] \\equiv X))) (Z \\downarrow ((([X\\rceil] \\odot Y) / (X \\odot [Z\\rceil])) > ([Y\\rceil] \\equiv X))) Step 2. We consider next the innermost partial expressions and convert them. (Z \\downarrow (([X\\rceilY \\odot] / (X Z\\rceil \\odot]) > ([Y\\rceilX\\equiv])) Step 3. Now we include the NAND operator / to complete the innermost partial expression. (Z \\downarrow ([X\\rceilY \\odot XZ\\rceil \\odot / ] > [Y\\rceilX\\equiv])) Step 4. We evaluate the operator >, inserting it at the end of the string. (Z \\downarrow [X\\rceilY \\odot XZ\\rceil \\odot / Y\\rceilX \\equiv >]) (Z \\downarrow [X\\rceilY \\odot XZ\\rceil \\odot / Y\\rceilX \\equiv >]) Step 5. Finally, we add the NOR operator \\downarrow to the end of the string. The final reverse Polish string is ZX\\rceilY \\odot XZ\\rceil \\odot / Y\\rceilX\\equiv> ZX\\rceilY \\odot XZ\\rceil \\odot / Y\\rceilX\\equiv> \\downarrow b) This problem uses solely the NAND operator/and several parentheses. We will proceed as before, evaluating the innermost parentheses first. Step 1. The two inner expressions on the right side get translated and bracketed first. (X / Y) / ([XX / ] / [YY / ]) (X / Y) / ([XX / ] / [YY / ]) Step 2. Next we merge the two bracketed expressions together over the NAND operator. (X / Y) / [XX / YY / / ] (X / Y) / [XX / YY / / ] Step 3. Now we convert the right side. [XY / ] / [XX / YY / / ] [XY / ] / [XX / YY / / ] Step 4. Finally, the entire expression, translated into a reverse Polish string looks like this. XY / XX / YY / / /"}, "question": "task_1"}}, {"data": {"text": "Question:\nWrite a FORTRAN program which reads 100 data cards, each consisting of four letters, and stores them in a vector WORD. Then sort these words into alphabetical order.\n\nOptions:\nA. N = 99 DO 3 I = 1,99 SWT = .FALSE. DO 4 J = 1, N\nB. IF (WORD (J).LE.WORD (J + 1)) GO TO 4 ITEMP = WORD (J)\nC.             DO 1 I = 1, 1\\O\\O 1 READ2, WORD (I)\nD. INTEGER WORD (1\\O\\O) LOGICAL SWT DO 1 I = 1, 1\\O\\O 1 READ2, WORD (I) 2 FORMAT (A4) N = 99 DO 3 I = 1,99 SWT = .FALSE. DO 4 J = 1, N IF (WORD (J).LE.WORD (J + 1)) GO TO 4 ITEMP = WORD (J) WORD (J) = WORD (J + l) WORD (J + l) = ITEMP SWT = .TRUE. 4 CONTINUE IF (.NOT. SWT) GO TO 5 3 N = N - 1 5 PRINT7, WORD 7 FORMAT ('\\cyrchar\\CYRF' ,1\\cyrchar\\CYRFA6) STOP END\n\nAnswer: D\n\nReference Solution:\nCharacters are represented internally by a numeric code whose ordering preserves alphabetic precedence. Thus if the integer variables X and Y each contain character data, the expression X.LT.Y will have the value .TRUE, if and only if the character string stored in X precedes in alphabetical order the character string stored in Y. The basic method of the program is to compare successive pairs of four-letter words. Two successive words are inter-changed in the vector if they are not in alphabetical order, i.e., the first is not \"less than\" the second. After the en-tire vector has been processed, the last word in alphabetical order has been pushed to the end of the vector. The vector is then processed again, and as a result the \"second-largest\" word appears in the second to last position. After (at most) passes over the data in the vector, the words are arranged in alphabetic order. Note that the logical variable SWT is used to measure whether or not any words are interchanged. If after a given pass an interchange occurs, the sort is not finished and SWT is true. Otherwise, SWT is False, no inter-change occurs, and the sort is complete. INTEGER WORD (1\\O\\O) LOGICAL SWT DO 1 I = 1, 1\\O\\O 1 READ2, WORD (I) 2 FORMAT (A4) N = 99 DO 3 I = 1,99 SWT = .FALSE. DO 4 J = 1, N IF (WORD (J).LE.WORD (J + 1)) GO TO 4 ITEMP = WORD (J) WORD (J) = WORD (J + l) WORD (J + l) = ITEMP SWT = .TRUE. 4 CONTINUE IF (.NOT. SWT) GO TO 5 3 N = N - 1 5 PRINT7, WORD 7 FORMAT ('\\cyrchar\\CYRF' ,1\\cyrchar\\CYRFA6) STOP END", "ref_id": 4778, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Write a FORTRAN program which reads 100 data cards, each consisting of four letters, and stores them in a vector WORD. Then sort these words into alphabetical order.", "options": ["N = 99 DO 3 I = 1,99 SWT = .FALSE. DO 4 J = 1, N", "IF (WORD (J).LE.WORD (J + 1)) GO TO 4 ITEMP = WORD (J)", "DO 1 I = 1, 1\\O\\O 1 READ2, WORD (I)", "INTEGER WORD (1\\O\\O) LOGICAL SWT DO 1 I = 1, 1\\O\\O 1 READ2, WORD (I) 2 FORMAT (A4) N = 99 DO 3 I = 1,99 SWT = .FALSE. DO 4 J = 1, N IF (WORD (J).LE.WORD (J + 1)) GO TO 4 ITEMP = WORD (J) WORD (J) = WORD (J + l) WORD (J + l) = ITEMP SWT = .TRUE. 4 CONTINUE IF (.NOT. SWT) GO TO 5 3 N = N - 1 5 PRINT7, WORD 7 FORMAT ('\\cyrchar\\CYRF' ,1\\cyrchar\\CYRFA6) STOP END"], "answer": "D", "solution": "Characters are represented internally by a numeric code whose ordering preserves alphabetic precedence. Thus if the integer variables X and Y each contain character data, the expression X.LT.Y will have the value .TRUE, if and only if the character string stored in X precedes in alphabetical order the character string stored in Y. The basic method of the program is to compare successive pairs of four-letter words. Two successive words are inter-changed in the vector if they are not in alphabetical order, i.e., the first is not \"less than\" the second. After the en-tire vector has been processed, the last word in alphabetical order has been pushed to the end of the vector. The vector is then processed again, and as a result the \"second-largest\" word appears in the second to last position. After (at most) passes over the data in the vector, the words are arranged in alphabetic order. Note that the logical variable SWT is used to measure whether or not any words are interchanged. If after a given pass an interchange occurs, the sort is not finished and SWT is true. Otherwise, SWT is False, no inter-change occurs, and the sort is complete. INTEGER WORD (1\\O\\O) LOGICAL SWT DO 1 I = 1, 1\\O\\O 1 READ2, WORD (I) 2 FORMAT (A4) N = 99 DO 3 I = 1,99 SWT = .FALSE. DO 4 J = 1, N IF (WORD (J).LE.WORD (J + 1)) GO TO 4 ITEMP = WORD (J) WORD (J) = WORD (J + l) WORD (J + l) = ITEMP SWT = .TRUE. 4 CONTINUE IF (.NOT. SWT) GO TO 5 3 N = N - 1 5 PRINT7, WORD 7 FORMAT ('\\cyrchar\\CYRF' ,1\\cyrchar\\CYRFA6) STOP END"}, "question": "task_1"}}, {"data": {"text": "Question:\nWrite a program in APL to compute the gross pay of any num-ber of employees.\n\nOptions:\nA. The APL program given in the solution calculates the gross pay of any number of employees by continuously taking the input of employee names, hours worked and rate of pay, and then computing the gross pay.\nB. The program calculates the net pay of employees\nC.             The program keeps track of employees' attendance\nD. The program calculates the tax of employees\n\nAnswer: A\n\nReference Solution:\nAlthough APL is slanted towards mathematical problems, it may also be used in clerical functions that involve repetition. The program below lists the name of each employee and his/her gross pay. Hours worked and rate of pay are input but do not form part of output . \\nablaPAYDAY [1]NAME\\leftarrow'' [2]GRS \\leftarrow '' [3]'ENTER THE NUMBER OF EMPLOYEES' [4]N \\leftarrow [] [5]I \\leftarrow 0 [6]REPEAT: 'ENTER NAME' [7]NAME \\leftarrow NAME, 20\\uparrow[] [8]'ENTER HOURS AND RATE' [9]GRS \\leftarrow GRS, \u00d7/[] [10]I \\leftarrow I + 1 [11]\\rightarrow REPEAT \u00d7\u0285(I < N) [12]NAME \\leftarrow (N,20) \\rho NAME [13]GRS \\leftarrow (N,1) \\rho GRS [14]'' [15]'NAME -------------------- GROSS PAY' [16]NAME, 7 2 DEF GRS [17]\\nabla Note the following points about the program: Statements [6] and [7] ensure that all names are entered. Statement [11] corresponds to the CONTINUE statement in FORTRAN. Names will continue to be entered and gross pay computed while (I < N) . When I = N,\u0285(I < N) is 0. But since there is no statement numbered 0, the program comes to a halt. Statement [14] produces a line of blank spaces between the input and output phases of the program.", "ref_id": 4779, "meta_info": {"subject": "computer science.csv", "src": "stemez-ComputerScience", "question": "Write a program in APL to compute the gross pay of any num-ber of employees.", "options": ["The APL program given in the solution calculates the gross pay of any number of employees by continuously taking the input of employee names, hours worked and rate of pay, and then computing the gross pay.", "The program calculates the net pay of employees", "The program keeps track of employees' attendance", "The program calculates the tax of employees"], "answer": "A", "solution": "Although APL is slanted towards mathematical problems, it may also be used in clerical functions that involve repetition. The program below lists the name of each employee and his/her gross pay. Hours worked and rate of pay are input but do not form part of output . \\nablaPAYDAY [1]NAME\\leftarrow'' [2]GRS \\leftarrow '' [3]'ENTER THE NUMBER OF EMPLOYEES' [4]N \\leftarrow [] [5]I \\leftarrow 0 [6]REPEAT: 'ENTER NAME' [7]NAME \\leftarrow NAME, 20\\uparrow[] [8]'ENTER HOURS AND RATE' [9]GRS \\leftarrow GRS, \u00d7/[] [10]I \\leftarrow I + 1 [11]\\rightarrow REPEAT \u00d7\u0285(I < N) [12]NAME \\leftarrow (N,20) \\rho NAME [13]GRS \\leftarrow (N,1) \\rho GRS [14]'' [15]'NAME -------------------- GROSS PAY' [16]NAME, 7 2 DEF GRS [17]\\nabla Note the following points about the program: Statements [6] and [7] ensure that all names are entered. Statement [11] corresponds to the CONTINUE statement in FORTRAN. Names will continue to be entered and gross pay computed while (I < N) . When I = N,\u0285(I < N) is 0. But since there is no statement numbered 0, the program comes to a halt. Statement [14] produces a line of blank spaces between the input and output phases of the program."}, "question": "task_1"}}, {"data": {"text": "Question:\nAn electric heater takes 4 amperes from a 120-volt line. What is its power rating?\n\nOptions:\nA. 360 watts\nB. 480 watts\nC.             240 watts\nD. 600 watts\n\nAnswer: B\n\nReference Solution:\nE = 120 volts,I = 4 amp P = E \u00d7 I = 120 volts \u00d7 4 amp = 480 watts.", "ref_id": 4780, "meta_info": {"subject": "physics.csv", "src": "stemez-Physics", "question": "An electric heater takes 4 amperes from a 120-volt line. What is its power rating?", "options": ["360 watts", "480 watts", "240 watts", "600 watts"], "answer": "B", "solution": "E = 120 volts,I = 4 amp P = E \u00d7 I = 120 volts \u00d7 4 amp = 480 watts."}, "question": "task_1"}}, {"data": {"text": "Question:\nAn electric motor is used to lift a 1600-lb block at a rate of An electric motor is used to lift a 1600-lb block at a rate of 10 fpm. How much electric power (watts) must be supplied to the motor, if the motor lifting the block is 60 percent efficient? The weight W is 1600 lb.\n\nOptions:\nA. 0.81 watts\nB. 1600 watts\nC.             267 watts\nD. 605 watts\n\nAnswer: D\n\nReference Solution:\nThe power requirement of the motor is the power exerted in lifting the block. The power exerted by the motor is the same as the power exerted by the force F in lifting the block. This is P = Fv. Since the block is moving at a constant velocity, F = 1600 lb so that the power exerted by the motor is P = Fv = (1600) (10/60) = 267 ft-lb/sec or, in terms of horsepower, P = (267/550) = 0.485 hp . This is the power required to lift the block at the velocity required, and this is the power that the motor has to pro-duce. However, since the motor is only 60 percent efficient, the power input to the motor must be greater. Thus, P_in = [(P_out) / (\\varepsilon)] orP_in =0.485 / 0.60= 0.81 hp and the power input in terms of the electric power supplied to the motor is P_in = 0.81 \u00d7 746 = 605 watts.", "ref_id": 4781, "meta_info": {"subject": "physics.csv", "src": "stemez-Mechanics", "question": "An electric motor is used to lift a 1600-lb block at a rate of An electric motor is used to lift a 1600-lb block at a rate of 10 fpm. How much electric power (watts) must be supplied to the motor, if the motor lifting the block is 60 percent efficient? The weight W is 1600 lb.", "options": ["0.81 watts", "1600 watts", "267 watts", "605 watts"], "answer": "D", "solution": "The power requirement of the motor is the power exerted in lifting the block. The power exerted by the motor is the same as the power exerted by the force F in lifting the block. This is P = Fv. Since the block is moving at a constant velocity, F = 1600 lb so that the power exerted by the motor is P = Fv = (1600) (10/60) = 267 ft-lb/sec or, in terms of horsepower, P = (267/550) = 0.485 hp . This is the power required to lift the block at the velocity required, and this is the power that the motor has to pro-duce. However, since the motor is only 60 percent efficient, the power input to the motor must be greater. Thus, P_in = [(P_out) / (\\varepsilon)] orP_in =0.485 / 0.60= 0.81 hp and the power input in terms of the electric power supplied to the motor is P_in = 0.81 \u00d7 746 = 605 watts."}, "question": "task_1"}}, {"data": {"text": "Question:\nDetermine the root-mean-square (rms) values of displacement, velocity, and acceleration for a damped forced harmonic oscillator operating at steady state.\n\nOptions:\nA. x_rms= (\\omega^2x_max / \\surd2), v_rms= (\\omegax_max/ \\surd2), a_rms= (x_max/ \\surd2)\nB. x_rms= (\\omegax_max/ \\surd2), v_rms= (x_max/ \\surd2), a_rms= (x_max / \\surd2)\nC.             x_rms= (x_max/ \\surd2), v_rms= (\\omegax_max/ \\surd2), a_rms= (\\omega^2x_max / \\surd2)\nD. x_rms= (x_max/ \\surd2), v_rms= (x_max/ \\surd2), a_rms= (\\omega^2x_max / \\surd2)\n\nAnswer: C\n\nReference Solution:\nThe general expression for the displacement is x =x_maxcos(\\omegat+ \\texttheta) ,(a) for the velocity v = \u1e8b = -\\omegax_maxsin (\\omegat+ \\texttheta),(b) and for the amplitude a = v\u0307 = - \\omega^2x_maxcos(\\omegat+ \\texttheta).(c) \\omega is the circular frequency, and the period T = 2\\pi/\\omega. The defining expression forrmsvalues is g_rms= [(^T\\int_0 g^2dt) / (^T\\int_0dt)]^1/2(d) where g is an arbitrary periodic function of time, with period T. Applying equation (d) to function (a) yields x_rms= [{^2\\pi/\\omega\\int_0 [x_maxcos(\\omegat+ \\texttheta)]^2dt} / (^2\\pi/\\omega\\int_0dt)]^1/2 = [x_max/ (2\\pi/\\omega)^1/2] [^2\\pi/\\omega\\int_0 cos^2 (\\omegat+ \\texttheta)dt]^1/2 . Shown here are some general trigonometric identities for reference: cos^2 \\alpha = (\\alpha/2) + (1/2)cos2\\alpha(e) sin^2 \\alpha = (\\alpha/2) - (1/2)cos2\\alpha .(f) Applying (a) to our expression forx_rms, x_rms= [x_max/ (2\\pi/\\omega)^1/2] [^2\\pi/\\omega\\int_0 [(1/2) + (1/2) cos^2 (\\omegat+ \\texttheta)]dt]^1/2 = (x_max/ \\surd2) . Following this procedure for function (b) yields v_rms= [ {^2\\pi/\\omega\\int_0 [-\\omegax_maxsin (\\omegat+ \\texttheta)]^2dt} / (^2\\pi/\\omega\\int_0dt)]^1/2 = [\\omegax_max/ (2\\pi/\\omega)^1/2] [^2\\pi/\\omega\\int_0 sin^2 (\\omegat+ \\texttheta)dt]^1/2 Using identity (f) = [\\omegax_max/ (2\\pi/\\omega)^1/2] [^2\\pi/\\omega\\int_0 [(1/2) - (1/2) cos^2 (\\omegat+ \\texttheta)]dt] = (\\omegax_max/ \\surd2) . Finally, using function (c) , a_rms= [{^2\\pi/\\omega\\int_0 [ - \\omega^2x_maxcos(\\omegat+ \\texttheta)]^2dt} / (^2\\pi/\\omega\\int_0dt)] we can write down the answer immediately as follows: a_rms= (\\omega^2x_max / \\surd2) .", "ref_id": 4782, "meta_info": {"subject": "physics.csv", "src": "stemez-Mechanics", "question": "Determine the root-mean-square (rms) values of displacement, velocity, and acceleration for a damped forced harmonic oscillator operating at steady state.", "options": ["x_rms= (\\omega^2x_max / \\surd2), v_rms= (\\omegax_max/ \\surd2), a_rms= (x_max/ \\surd2)", "x_rms= (\\omegax_max/ \\surd2), v_rms= (x_max/ \\surd2), a_rms= (x_max / \\surd2)", "x_rms= (x_max/ \\surd2), v_rms= (\\omegax_max/ \\surd2), a_rms= (\\omega^2x_max / \\surd2)", "x_rms= (x_max/ \\surd2), v_rms= (x_max/ \\surd2), a_rms= (\\omega^2x_max / \\surd2)"], "answer": "C", "solution": "The general expression for the displacement is x =x_maxcos(\\omegat+ \\texttheta) ,(a) for the velocity v = \u1e8b = -\\omegax_maxsin (\\omegat+ \\texttheta),(b) and for the amplitude a = v\u0307 = - \\omega^2x_maxcos(\\omegat+ \\texttheta).(c) \\omega is the circular frequency, and the period T = 2\\pi/\\omega. The defining expression forrmsvalues is g_rms= [(^T\\int_0 g^2dt) / (^T\\int_0dt)]^1/2(d) where g is an arbitrary periodic function of time, with period T. Applying equation (d) to function (a) yields x_rms= [{^2\\pi/\\omega\\int_0 [x_maxcos(\\omegat+ \\texttheta)]^2dt} / (^2\\pi/\\omega\\int_0dt)]^1/2 = [x_max/ (2\\pi/\\omega)^1/2] [^2\\pi/\\omega\\int_0 cos^2 (\\omegat+ \\texttheta)dt]^1/2 . Shown here are some general trigonometric identities for reference: cos^2 \\alpha = (\\alpha/2) + (1/2)cos2\\alpha(e) sin^2 \\alpha = (\\alpha/2) - (1/2)cos2\\alpha .(f) Applying (a) to our expression forx_rms, x_rms= [x_max/ (2\\pi/\\omega)^1/2] [^2\\pi/\\omega\\int_0 [(1/2) + (1/2) cos^2 (\\omegat+ \\texttheta)]dt]^1/2 = (x_max/ \\surd2) . Following this procedure for function (b) yields v_rms= [ {^2\\pi/\\omega\\int_0 [-\\omegax_maxsin (\\omegat+ \\texttheta)]^2dt} / (^2\\pi/\\omega\\int_0dt)]^1/2 = [\\omegax_max/ (2\\pi/\\omega)^1/2] [^2\\pi/\\omega\\int_0 sin^2 (\\omegat+ \\texttheta)dt]^1/2 Using identity (f) = [\\omegax_max/ (2\\pi/\\omega)^1/2] [^2\\pi/\\omega\\int_0 [(1/2) - (1/2) cos^2 (\\omegat+ \\texttheta)]dt] = (\\omegax_max/ \\surd2) . Finally, using function (c) , a_rms= [{^2\\pi/\\omega\\int_0 [ - \\omega^2x_maxcos(\\omegat+ \\texttheta)]^2dt} / (^2\\pi/\\omega\\int_0dt)] we can write down the answer immediately as follows: a_rms= (\\omega^2x_max / \\surd2) ."}, "question": "task_1"}}, {"data": {"text": "Question:\nA chairlift is designed to transport 90 skiers of average mass 75 kg from base A to summit B at an inclination of 30\\textdegree with an average speed of 80 m/min. Determine: a) the average power required; b) the required capacity of the motor if mechanical efficiency is 85% and a 300% overload is to be built in.\n\nOptions:\nA. 207.5 kW\nB. 176.4 kW\nC.             44.1 kW\nD. 90 kW\n\nAnswer: A\n\nReference Solution:\nPower is defined as rate of energy change. In this case, the motor is giving up mechanical and electrical energy to increase the gravitational potential energy of the skiers. Neglecting friction losses, the power from the motor equals the power gained by the skiers. Since gravitational potential energy is given by E =mgh, the power gained is P = \u2206 (mgh) / \u2206t = mg(\u2206h/\u2206t). Here, m = (75 kg) (90) s 6750 kg. With a forward velocity of 80 m/min. = 8/6 m/sec., the rate of height increase is: (\u2206h/\u2206t) = (8/6) m/sec. sin 30\\textdegree = (4/6) m/sec. Thus, the power required is Power = (6750 kg) (9.8 m/sec^2) [(4/6) m/sec] = 44.1 kW A 300% overload means that motor must be able to provide 4 times this figure or 176.4 kW. However, with an 85% effi-ciency, the actual power rating need is Power = [(176.4kW) / (.85)] = 207.5 kW.", "ref_id": 4783, "meta_info": {"subject": "physics.csv", "src": "stemez-Mechanics", "question": "A chairlift is designed to transport 90 skiers of average mass 75 kg from base A to summit B at an inclination of 30\\textdegree with an average speed of 80 m/min. Determine: a) the average power required; b) the required capacity of the motor if mechanical efficiency is 85% and a 300% overload is to be built in.", "options": ["207.5 kW", "176.4 kW", "44.1 kW", "90 kW"], "answer": "A", "solution": "Power is defined as rate of energy change. In this case, the motor is giving up mechanical and electrical energy to increase the gravitational potential energy of the skiers. Neglecting friction losses, the power from the motor equals the power gained by the skiers. Since gravitational potential energy is given by E =mgh, the power gained is P = \u2206 (mgh) / \u2206t = mg(\u2206h/\u2206t). Here, m = (75 kg) (90) s 6750 kg. With a forward velocity of 80 m/min. = 8/6 m/sec., the rate of height increase is: (\u2206h/\u2206t) = (8/6) m/sec. sin 30\\textdegree = (4/6) m/sec. Thus, the power required is Power = (6750 kg) (9.8 m/sec^2) [(4/6) m/sec] = 44.1 kW A 300% overload means that motor must be able to provide 4 times this figure or 176.4 kW. However, with an 85% effi-ciency, the actual power rating need is Power = [(176.4kW) / (.85)] = 207.5 kW."}, "question": "task_1"}}, {"data": {"text": "Question:\nA neutron with mass m_1 strikes an atomic nucleus with mass m_2 centrally. If the collision is elastic, deter-mine the ratio of the loss in the kinetic energy of the neutron to its original energy . Assume the laws of classical mechanics apply. Calculate the energy loss if the collision occurs with a hydrogen atom. What would be the loss if lead were usedas a target?\n\nOptions:\nA. 100% for hydrogen, 1.9% for lead\nB. 50% for hydrogen, 0.5% for lead\nC.             25% for hydrogen, 0.25% for lead\nD. 0% for hydrogen, 100% for lead\n\nAnswer: A\n\nReference Solution:\na) The ratio of energy lost by a neutron to its original energy is: E = [{(1/2) m_1 v_1^2 - (1/2) m_1 v_1'^2} / {(1/2) m_1 v_1^2}] E = [{v_1^2 - v_1'^2} / {v_1^2}] = 1 - (v_1' / v_1)^2.(1) Let primes indicate velocity after collision, and subscripts 1, 2 indicate neutron and atomic nucleus re-spectively. Assume target nucleus is initially at rest, i.e. v = 0. Since the collision is elastic, kinetic energy and linear momentum are both conserved during the collision: (1/2) m_1 v_1^2 + 0 = (1/2) m_1 v_1'^2 + (1/2) m_2 v_2'^2(2) m_1 v_1 + 0 = m_1 v_1' + m_2 v_2'(3) Solve Equation (3) for v_2' and substitute the result in Equation (2). First, v_2' = [{m_1(v_1 - v_1')} / {m_2}], substituting , (1/2) m_1 v_1^2 = (1/2) m_1 v_1'^2 + (1/2) m_2 (m_1^2 / m_2^2) (v_1 - v_1')^2 v_1^2 - v_1'^2 = (m_1 / m_2) (v_1 - v_1')^2 (v_1 - v_1') (v_1 - v_1') = (m_1 / m_2) (v_1 - v_1')^2 v_1 - v_1' = (m_1 / m_2) (v_1 - v_1') 1 + (v_1' / v_1) = (m_1 / m_2) [1 - (v_1' / v_1)]. From which, (v_1' / v_1) = [(m_1 - m_2) / (m_1 + m_2)].(4) Substitute Equation (4) in Equation (1) to get: E = 1 - [(m_1 - m_2) / (m_1 + m_2)]^2.(5) b) When the neutron strikes a hydrogen nucleus, a proton, m_1 = m_2 in Equation (5) and E = 100% energy transfer. c) For a lead target, m_2 = 207, m_1 = 1 and Equation (5) gives: E = 1 - [(1 - 207) / (1 + 207)] = 0.019 = 1.9%.", "ref_id": 4784, "meta_info": {"subject": "physics.csv", "src": "stemez-Mechanics", "question": "A neutron with mass m_1 strikes an atomic nucleus with mass m_2 centrally. If the collision is elastic, deter-mine the ratio of the loss in the kinetic energy of the neutron to its original energy . Assume the laws of classical mechanics apply. Calculate the energy loss if the collision occurs with a hydrogen atom. What would be the loss if lead were usedas a target?", "options": ["100% for hydrogen, 1.9% for lead", "50% for hydrogen, 0.5% for lead", "25% for hydrogen, 0.25% for lead", "0% for hydrogen, 100% for lead"], "answer": "A", "solution": "a) The ratio of energy lost by a neutron to its original energy is: E = [{(1/2) m_1 v_1^2 - (1/2) m_1 v_1'^2} / {(1/2) m_1 v_1^2}] E = [{v_1^2 - v_1'^2} / {v_1^2}] = 1 - (v_1' / v_1)^2.(1) Let primes indicate velocity after collision, and subscripts 1, 2 indicate neutron and atomic nucleus re-spectively. Assume target nucleus is initially at rest, i.e. v = 0. Since the collision is elastic, kinetic energy and linear momentum are both conserved during the collision: (1/2) m_1 v_1^2 + 0 = (1/2) m_1 v_1'^2 + (1/2) m_2 v_2'^2(2) m_1 v_1 + 0 = m_1 v_1' + m_2 v_2'(3) Solve Equation (3) for v_2' and substitute the result in Equation (2). First, v_2' = [{m_1(v_1 - v_1')} / {m_2}], substituting , (1/2) m_1 v_1^2 = (1/2) m_1 v_1'^2 + (1/2) m_2 (m_1^2 / m_2^2) (v_1 - v_1')^2 v_1^2 - v_1'^2 = (m_1 / m_2) (v_1 - v_1')^2 (v_1 - v_1') (v_1 - v_1') = (m_1 / m_2) (v_1 - v_1')^2 v_1 - v_1' = (m_1 / m_2) (v_1 - v_1') 1 + (v_1' / v_1) = (m_1 / m_2) [1 - (v_1' / v_1)]. From which, (v_1' / v_1) = [(m_1 - m_2) / (m_1 + m_2)].(4) Substitute Equation (4) in Equation (1) to get: E = 1 - [(m_1 - m_2) / (m_1 + m_2)]^2.(5) b) When the neutron strikes a hydrogen nucleus, a proton, m_1 = m_2 in Equation (5) and E = 100% energy transfer. c) For a lead target, m_2 = 207, m_1 = 1 and Equation (5) gives: E = 1 - [(1 - 207) / (1 + 207)] = 0.019 = 1.9%."}, "question": "task_1"}}, {"data": {"text": "Question:\nA tug of war is held between two teams of five men each. Each man weighs 160 lb. and each man's pull on the rope can be described as: F = (200 b.) e^-t/\\tau , where the mean tiring time \\tau is 10 sec for team A, and 20 sec for team B. If the mass of the rope is 50 lb., find the motion, that is, the final velocity of the teams. What assumption leads to this absurd result?\n\nOptions:\nA. -100 ft/sec\nB. -200 ft/sec\nC.             0 ft/sec\nD. 200 ft/sec\n\nAnswer: B\n\nReference Solution:\nSince we have the forces that act in this system and we have to find the motion, we can apply Newton's Second Law of motion as: \\sumF = F_A - F_B = M _rope (dv/dt) 50dv= (F_A - F_B)dt= [5(200)e^-t/10 - 5(200)e^-t/20]dt(1) Since we can assume that v = 0 when t = 0, v can be determined by in-tegrating equation (1): 50 ^v\\int_0dv= 1000 ^t\\int_0 (e^-t/10 - e^-t/20)dt 50v - 0 = 1000[ -10e^-t/10 - (-20e^-t/20) +10 - 20] v = 20[-10e^-t/10 + 20e^-t/20 - 10](2) Since v =dx/dt, the substitution can be made, and integrated again the equation becomes: ^x\\int_0dx= 200 ^t\\int_0 (-e^-t/10 + 2e^-t/20 - 1)dt x - 0 = 200[-(-10e^-t/10) + 2(-20e^-t/20) - t - 10 + 40 - 0] x = 200[10e^-t/10 - 40e^-t/20 - t + 30] x = -200t + 2000[e^-t/10 - 4e^-t/20 + 3] . Factoring the last term gives: x = -200t + 2000(1 - e^-t/20)(3 - e^-t/20)(3) As t\\rightarrow \\infty , the final velocity can be found from equation (2) as follows: v = 2-[-10e^-\\infty + 20e^-\\infty - 10] v = -200 ft/sec. Here the minus sign simply means that the motion is in the direction of team B, which one would expect since team B tires less easily than team A. Obviously, this large a final velocity is absurd. It comes about because we assumed a force which was independent of the velocity. Another reason for this result is that we neglected the mass of the teams. Obviously if one team didn't let go of the rope, (their feet slipped along the ground ) the system acceleration would be much different. This type of problem shown the importance of a good system model in obtaining meaningful re-sults.", "ref_id": 4785, "meta_info": {"subject": "physics.csv", "src": "stemez-Mechanics", "question": "A tug of war is held between two teams of five men each. Each man weighs 160 lb. and each man's pull on the rope can be described as: F = (200 b.) e^-t/\\tau , where the mean tiring time \\tau is 10 sec for team A, and 20 sec for team B. If the mass of the rope is 50 lb., find the motion, that is, the final velocity of the teams. What assumption leads to this absurd result?", "options": ["-100 ft/sec", "-200 ft/sec", "0 ft/sec", "200 ft/sec"], "answer": "B", "solution": "Since we have the forces that act in this system and we have to find the motion, we can apply Newton's Second Law of motion as: \\sumF = F_A - F_B = M _rope (dv/dt) 50dv= (F_A - F_B)dt= [5(200)e^-t/10 - 5(200)e^-t/20]dt(1) Since we can assume that v = 0 when t = 0, v can be determined by in-tegrating equation (1): 50 ^v\\int_0dv= 1000 ^t\\int_0 (e^-t/10 - e^-t/20)dt 50v - 0 = 1000[ -10e^-t/10 - (-20e^-t/20) +10 - 20] v = 20[-10e^-t/10 + 20e^-t/20 - 10](2) Since v =dx/dt, the substitution can be made, and integrated again the equation becomes: ^x\\int_0dx= 200 ^t\\int_0 (-e^-t/10 + 2e^-t/20 - 1)dt x - 0 = 200[-(-10e^-t/10) + 2(-20e^-t/20) - t - 10 + 40 - 0] x = 200[10e^-t/10 - 40e^-t/20 - t + 30] x = -200t + 2000[e^-t/10 - 4e^-t/20 + 3] . Factoring the last term gives: x = -200t + 2000(1 - e^-t/20)(3 - e^-t/20)(3) As t\\rightarrow \\infty , the final velocity can be found from equation (2) as follows: v = 2-[-10e^-\\infty + 20e^-\\infty - 10] v = -200 ft/sec. Here the minus sign simply means that the motion is in the direction of team B, which one would expect since team B tires less easily than team A. Obviously, this large a final velocity is absurd. It comes about because we assumed a force which was independent of the velocity. Another reason for this result is that we neglected the mass of the teams. Obviously if one team didn't let go of the rope, (their feet slipped along the ground ) the system acceleration would be much different. This type of problem shown the importance of a good system model in obtaining meaningful re-sults."}, "question": "task_1"}}, {"data": {"text": "Question:\nIt is known that the tides raised on a planet by its sun decreases the planets angular velocity of rotation. Find a formula relating \\omega, the angular velocity of rotation of the planet, to the orbit radius r for later or earlier times. Assume planet radius a, with orbit radius r_0 and \\omega_0 at pre-sent time. Apply the formula to the earth to find the change in the orbit distance when the length of day becomes equal to the present year. Ignore the moon's affect in this prob-lem.\n\nOptions:\nA. 48.2 miles\nB. 45.7 miles\nC.             49.3 miles\nD. 52.1 miles\n\nAnswer: C\n\nReference Solution:\nThe total angular momentum of the earth consists of the spin angular momentum (daily rotation) and the orbital angular momentum (revolution about the sun) . The total angu-lar momentum remains constant because the sun's gravitational force acting on the earth is a central force and therefore produces no torque. This conservation of total angular mo-mentum can be written as \u2206L_s = - \u2206L_0, L_s = spin angular momentum and L_0 = orbital angular momentum. The change in spin angular momentum is \u2206L_s = (2/5)m a^2 (\\omega - \\omega_0). We are making the approximation here that the moment of inertia of the earth is equal to (2/5)m a^2, the moment of inertia of a sphere of radius a. In reality, the earth's moment of inertia is less than (2/5)m a^2 because the earth's mass is concentrated near its center. The change in orbital angular momentum is \u2206L_0 = m v r = m v_0 r_0 = 2 \\pi m [(r^2 / Y) - (r_0^2 / Y_0)](1) where Y is the length of the year (period). Thus, 2 \\pi m [(r^2 / Y) - (r_0^2 / Y_0)] = (2/5) m a^2 (\\omega_0 - \\omega).(2) Now the variation of the length of the year Y as a function of r must be found. FromKepler'sLaws Y^2 \\propto r^3, setting up ratios (Y^2 / r^3) = (Y_0^2 / r_0^3) Y^2 = (Y_0^2 / r_0^3)r^3 Y = (Y_0^2 / r_0^3)^1/2 r^3/2. Substituting this into equation (2) gives 2 \\pi m [{(r^1/2) / (Y_0^2 / r_0^3)^1/2} - (r_0^2 / Y_0)] = (2/5)m a^2 (\\omega_0 - \\omega). Solving for r gives r= (Y_0^2 / r_0^3)[(a^2 / 5\\pi)(\\omega_0 - \\omega) + (r_0^2 / Y_0)]^2 = r_0 [1 + (1 / 5\\pi)(a / r_0)^2 (\\omega_0 - \\omega)Y_0]^2. Using the following data, a = 3.96 \u00d7 10^3 miles r_0 = 9.26 \u00d7 10^7 miles(a / r_0)^2 = 1.83 \u00d7 10^-9 Y_0 = 365 days\\omega_0 = (2\\pi / \u2206 day) = 365 (2\\pi / Y_0) When \\omega = (2\\pi / Y_0) = (2\\pi / 365 day) = 0.0172 radians / day r = r_0 [1 + (2/5)(1.83 \u00d7 10^-9)(365 - 1)]^2 = r0[1 + 2.66 \u00d7 10^-7]^2 Since the second term in parenthesis is much smallerthenone, we can use the binomial theorem approximation to evaluate the terms in parenthesis. The binomial approxima-tion is (1 + x)^n \\approx 1 +nxfor x < < 1. Using this theorem in the preceding equation yields r \\approx r_0 [1 + 2 (2.66 \u00d7 10^-7)]. So that r - r_0= 2 r_0 (2.66 \u00d7 10^-7) = 2(9.26 \u00d7 10^7)(2.66 \u00d7 10^-7) = 49.3 miles.", "ref_id": 4786, "meta_info": {"subject": "physics.csv", "src": "stemez-Mechanics", "question": "It is known that the tides raised on a planet by its sun decreases the planets angular velocity of rotation. Find a formula relating \\omega, the angular velocity of rotation of the planet, to the orbit radius r for later or earlier times. Assume planet radius a, with orbit radius r_0 and \\omega_0 at pre-sent time. Apply the formula to the earth to find the change in the orbit distance when the length of day becomes equal to the present year. Ignore the moon's affect in this prob-lem.", "options": ["48.2 miles", "45.7 miles", "49.3 miles", "52.1 miles"], "answer": "C", "solution": "The total angular momentum of the earth consists of the spin angular momentum (daily rotation) and the orbital angular momentum (revolution about the sun) . The total angu-lar momentum remains constant because the sun's gravitational force acting on the earth is a central force and therefore produces no torque. This conservation of total angular mo-mentum can be written as \u2206L_s = - \u2206L_0, L_s = spin angular momentum and L_0 = orbital angular momentum. The change in spin angular momentum is \u2206L_s = (2/5)m a^2 (\\omega - \\omega_0). We are making the approximation here that the moment of inertia of the earth is equal to (2/5)m a^2, the moment of inertia of a sphere of radius a. In reality, the earth's moment of inertia is less than (2/5)m a^2 because the earth's mass is concentrated near its center. The change in orbital angular momentum is \u2206L_0 = m v r = m v_0 r_0 = 2 \\pi m [(r^2 / Y) - (r_0^2 / Y_0)](1) where Y is the length of the year (period). Thus, 2 \\pi m [(r^2 / Y) - (r_0^2 / Y_0)] = (2/5) m a^2 (\\omega_0 - \\omega).(2) Now the variation of the length of the year Y as a function of r must be found. FromKepler'sLaws Y^2 \\propto r^3, setting up ratios (Y^2 / r^3) = (Y_0^2 / r_0^3) Y^2 = (Y_0^2 / r_0^3)r^3 Y = (Y_0^2 / r_0^3)^1/2 r^3/2. Substituting this into equation (2) gives 2 \\pi m [{(r^1/2) / (Y_0^2 / r_0^3)^1/2} - (r_0^2 / Y_0)] = (2/5)m a^2 (\\omega_0 - \\omega). Solving for r gives r= (Y_0^2 / r_0^3)[(a^2 / 5\\pi)(\\omega_0 - \\omega) + (r_0^2 / Y_0)]^2 = r_0 [1 + (1 / 5\\pi)(a / r_0)^2 (\\omega_0 - \\omega)Y_0]^2. Using the following data, a = 3.96 \u00d7 10^3 miles r_0 = 9.26 \u00d7 10^7 miles(a / r_0)^2 = 1.83 \u00d7 10^-9 Y_0 = 365 days\\omega_0 = (2\\pi / \u2206 day) = 365 (2\\pi / Y_0) When \\omega = (2\\pi / Y_0) = (2\\pi / 365 day) = 0.0172 radians / day r = r_0 [1 + (2/5)(1.83 \u00d7 10^-9)(365 - 1)]^2 = r0[1 + 2.66 \u00d7 10^-7]^2 Since the second term in parenthesis is much smallerthenone, we can use the binomial theorem approximation to evaluate the terms in parenthesis. The binomial approxima-tion is (1 + x)^n \\approx 1 +nxfor x < < 1. Using this theorem in the preceding equation yields r \\approx r_0 [1 + 2 (2.66 \u00d7 10^-7)]. So that r - r_0= 2 r_0 (2.66 \u00d7 10^-7) = 2(9.26 \u00d7 10^7)(2.66 \u00d7 10^-7) = 49.3 miles."}, "question": "task_1"}}, {"data": {"text": "Question:\nA particle of mass m is repelled from the origin by a force f = k/x^3 where x is the distance from the origin. Solve the equation of motion if the particle is initially at rest at a distance x_0 from the origin.\n\nOptions:\nA. x = [x^2_0 - (kt^2/mx^2_0)]^1/2\nB. x = [x^2_0 + (kt^2/mx^2_0)]^1/2\nC.             x = [x^2_0 - (kt^2/mx^2_0)]^-1/2\nD. x = [x^2_0 + (kt^2/mx^2_0)]^-1/2\n\nAnswer: B\n\nReference Solution:\nWe must use F^\\ding{217} = ma^\\ding{217} and solve the resulting differential equation, using the initial conditions: x(t = 0) = x_0 ; x(t = 0) = 0 .(1) Firstm\u1e8d= (k/x^3) from Newton's Second Law, or \u1e8d = (k/x^3) . This is a second order, nonlinear, homogeneous differential equation. Note that there are only terms in x and its time derivatives; there are no terms in t alone. A substitution which will reduce this equation to a first order equation is \u1e8b = p .(2) Then \u1e8d = (d^2x/dt^2) = (dp/dt) = p(dp/dx) .(3) The last expression comes from the realization that p(dp/dx) = (dx/dt) (d/dx) (dx/dt) = (d^2x/dt^2) . Now, the differential equation in reduced form is: p(dp/dx) = (k/mx^3) .(4) This equation is separable. Rearranging terms yields: pdp= (kdx/mx^3) . Integrating both sides yields: (p^2/2) = - (k / 2mx^2) + c_1 , c_1 = constant or p^2 = - (k/mx^2) + c_2 , c_2 = 2c_1 . Substituting from (2) \u1e8b^2 = - (k/mx^2) + c_2 .(5) Evaluating c_2 by using the boundary conditions, eq.(1) 0 = - (k/mx_0^2) + c_2 ; c_2 = (k/mx_0^2) . Substituting into (5) and solving for \u1e8b : \u1e8b = (dx/dt) = \\pm \\surd[(k/m){(1/x_0^2) - (1/x^2)}] = \\pm K{(1/x_0^2) - (1/x^2)}^1/2 where K = \\surd(k/m)(6) (dx/dt) = \\pm K[{(x^2 - x^2_0)^1/2} / x_0x] .(7) Separating variables in (7) dt= \\pm [dx/ {(K/x_0x)(x^2 - x^2_0)^1/2}] = \\pm (x_0/K) [(xdx) / {(x^2 - x^2_0)^1/2}] .(8) Integrating both sides yields t = \\pm (x_0/K) (x^2 - x^2_0)^1/2 + c_3 .(9) Evaluating the integration constant c_3 through substitution of (1) yields c_3 = 0 . Solving (9) for x and substituting (6) yields x = \\pm [x^2_0 + (kt^2/mx^2_0)]^1/2 . Since x = x_0 when t = 0 we choose the positive square root for our solution.", "ref_id": 4787, "meta_info": {"subject": "physics.csv", "src": "stemez-Mechanics", "question": "A particle of mass m is repelled from the origin by a force f = k/x^3 where x is the distance from the origin. Solve the equation of motion if the particle is initially at rest at a distance x_0 from the origin.", "options": ["x = [x^2_0 - (kt^2/mx^2_0)]^1/2", "x = [x^2_0 + (kt^2/mx^2_0)]^1/2", "x = [x^2_0 - (kt^2/mx^2_0)]^-1/2", "x = [x^2_0 + (kt^2/mx^2_0)]^-1/2"], "answer": "B", "solution": "We must use F^\\ding{217} = ma^\\ding{217} and solve the resulting differential equation, using the initial conditions: x(t = 0) = x_0 ; x(t = 0) = 0 .(1) Firstm\u1e8d= (k/x^3) from Newton's Second Law, or \u1e8d = (k/x^3) . This is a second order, nonlinear, homogeneous differential equation. Note that there are only terms in x and its time derivatives; there are no terms in t alone. A substitution which will reduce this equation to a first order equation is \u1e8b = p .(2) Then \u1e8d = (d^2x/dt^2) = (dp/dt) = p(dp/dx) .(3) The last expression comes from the realization that p(dp/dx) = (dx/dt) (d/dx) (dx/dt) = (d^2x/dt^2) . Now, the differential equation in reduced form is: p(dp/dx) = (k/mx^3) .(4) This equation is separable. Rearranging terms yields: pdp= (kdx/mx^3) . Integrating both sides yields: (p^2/2) = - (k / 2mx^2) + c_1 , c_1 = constant or p^2 = - (k/mx^2) + c_2 , c_2 = 2c_1 . Substituting from (2) \u1e8b^2 = - (k/mx^2) + c_2 .(5) Evaluating c_2 by using the boundary conditions, eq.(1) 0 = - (k/mx_0^2) + c_2 ; c_2 = (k/mx_0^2) . Substituting into (5) and solving for \u1e8b : \u1e8b = (dx/dt) = \\pm \\surd[(k/m){(1/x_0^2) - (1/x^2)}] = \\pm K{(1/x_0^2) - (1/x^2)}^1/2 where K = \\surd(k/m)(6) (dx/dt) = \\pm K[{(x^2 - x^2_0)^1/2} / x_0x] .(7) Separating variables in (7) dt= \\pm [dx/ {(K/x_0x)(x^2 - x^2_0)^1/2}] = \\pm (x_0/K) [(xdx) / {(x^2 - x^2_0)^1/2}] .(8) Integrating both sides yields t = \\pm (x_0/K) (x^2 - x^2_0)^1/2 + c_3 .(9) Evaluating the integration constant c_3 through substitution of (1) yields c_3 = 0 . Solving (9) for x and substituting (6) yields x = \\pm [x^2_0 + (kt^2/mx^2_0)]^1/2 . Since x = x_0 when t = 0 we choose the positive square root for our solution."}, "question": "task_1"}}, {"data": {"text": "Question:\nA bar pivoting about one end has an angular velocity of 8 rad/sec clockwise when it is subjected to a constant angular deceleration, which is to act for a time interval until the bar has an angular displacement of 10radcounterclockwise from its position at the instant at which the deceleration was first applied. The bar will have moved through a total angular distance of 26radin this same time interval. What will be the angular velocity at the end of the time interval?\n\nOptions:\nA. 12rad/sec counterclockwise\nB. 10rad/sec counterclockwise\nC.             14rad/sec counterclockwise\nD. 8rad/sec clockwise\n\nAnswer: A\n\nReference Solution:\nThe initial angular velocity is 8rad/sec clockwise. If clockwise is called negative, then \\cyrchar\\cyromega_0 = - 8rad/sec. Since the deceleration \\alpha must be counterclockwise, its magni-tude is called + C. The bar will continue to move clockwise through some angle \\texttheta until it comes to rest, and will then start to move counterclockwise. The bar will then return through the angle \\texttheta to its original position, and will con-tinue counterclockwise for an additional 10 rad. Hence, its total angular travel will be (2\\texttheta + 10) rad. Since this total angle is given as 26rad, the magnitude of \\texttheta must be 8 rad. We haved\\texttheta=\\cyrchar\\cyromegadt(1) d\\cyrchar\\cyromega=\\alphadt(2) Hence dividing (1) by (2) \\alphad\\texttheta=\\cyrchar\\cyromegad\\cyrchar\\cyromega(3) integrating ^\\texttheta\\int_(\\texttheta)0\\alphad\\texttheta' = ^\\cyrchar\\cyromega\\int_(\\cyrchar\\cyromega)0 \\cyrchar\\cyromega'd\\cyrchar\\cyromega(4) \\cyrchar\\cyromega^2 = \\cyrchar\\cyromega_0 ^2 + 2c (\\texttheta - \\texttheta_0) We are now in a position to find C or \\alpha. During the clockwise motion, the speed decreases to zero, and we have (0)^2 = (- 8)^2 + 2C (- 8) Hence, \\alpha = + 4rad/sec^2. The final angular velocity \\cyrchar\\cyromega can be found by considering the motion either from the initial position or from the position of reversal of motion. In the first case, the equation is \\cyrchar\\cyromega^2 = (- 8)^2 + 2 (+ 4) (+ 10) = 64 + 80 = 144 In the second case, the equation is \\cyrchar\\cyromega^2 = (0)^2 + 2 (+ 4) (18) = 144 Hence, \\cyrchar\\cyromega is 12rad/sec counterclockwise.", "ref_id": 4788, "meta_info": {"subject": "physics.csv", "src": "stemez-Mechanics", "question": "A bar pivoting about one end has an angular velocity of 8 rad/sec clockwise when it is subjected to a constant angular deceleration, which is to act for a time interval until the bar has an angular displacement of 10radcounterclockwise from its position at the instant at which the deceleration was first applied. The bar will have moved through a total angular distance of 26radin this same time interval. What will be the angular velocity at the end of the time interval?", "options": ["12rad/sec counterclockwise", "10rad/sec counterclockwise", "14rad/sec counterclockwise", "8rad/sec clockwise"], "answer": "A", "solution": "The initial angular velocity is 8rad/sec clockwise. If clockwise is called negative, then \\cyrchar\\cyromega_0 = - 8rad/sec. Since the deceleration \\alpha must be counterclockwise, its magni-tude is called + C. The bar will continue to move clockwise through some angle \\texttheta until it comes to rest, and will then start to move counterclockwise. The bar will then return through the angle \\texttheta to its original position, and will con-tinue counterclockwise for an additional 10 rad. Hence, its total angular travel will be (2\\texttheta + 10) rad. Since this total angle is given as 26rad, the magnitude of \\texttheta must be 8 rad. We haved\\texttheta=\\cyrchar\\cyromegadt(1) d\\cyrchar\\cyromega=\\alphadt(2) Hence dividing (1) by (2) \\alphad\\texttheta=\\cyrchar\\cyromegad\\cyrchar\\cyromega(3) integrating ^\\texttheta\\int_(\\texttheta)0\\alphad\\texttheta' = ^\\cyrchar\\cyromega\\int_(\\cyrchar\\cyromega)0 \\cyrchar\\cyromega'd\\cyrchar\\cyromega(4) \\cyrchar\\cyromega^2 = \\cyrchar\\cyromega_0 ^2 + 2c (\\texttheta - \\texttheta_0) We are now in a position to find C or \\alpha. During the clockwise motion, the speed decreases to zero, and we have (0)^2 = (- 8)^2 + 2C (- 8) Hence, \\alpha = + 4rad/sec^2. The final angular velocity \\cyrchar\\cyromega can be found by considering the motion either from the initial position or from the position of reversal of motion. In the first case, the equation is \\cyrchar\\cyromega^2 = (- 8)^2 + 2 (+ 4) (+ 10) = 64 + 80 = 144 In the second case, the equation is \\cyrchar\\cyromega^2 = (0)^2 + 2 (+ 4) (18) = 144 Hence, \\cyrchar\\cyromega is 12rad/sec counterclockwise."}, "question": "task_1"}}, {"data": {"text": "Question:\nFor a uniform sphere with moments of inertia I_1 = I_2 = I_3 , use the Euler equations to find the equation of motion of the sphere.\n\nOptions:\nA. \\omega = 0\nB. \\omega = N\nC.             \\omega = const\nD. I = const\n\nAnswer: C\n\nReference Solution:\nThe Euler Equations are I_1 (d\\omega_1/dt) + (I_3 - I_2) \\omega_3 \\omega_2 = N_1 I_2 (d\\omega_2/dt) + (I_1 - I_3) \\omega_1 \\omega_3 = N_2 I_3 (d\\omega_3/dt) + (I_2 - I_1) \\omega_2 \\omega_1 = N_3 where the subscript 1 refers to the first principal axis of the sphere. N and \\omega are the net external torque and angular velocity of the sphere. Noting that I_1 = I_2 = I_3 , we obtain I_1 (d\\omega_1/dt) = N_1 ;I_2 (d\\omega_2/dt) = N_2 ;I_3 = (d\\omega_2/dt) = N_3 Defining I_1 = I_2 = I_3 = I, we may write (d\\omega_1/dt) = (N_1/I) , (d\\omega_2/dt) = (N_2/I) , (d\\omega_1/dt) = (N_3/I)(1) In free motion N = 0, and (1) tells us that \\omega = const. The result \\omega = const is a special feature of the free rotating sphere.", "ref_id": 4789, "meta_info": {"subject": "physics.csv", "src": "stemez-Mechanics", "question": "For a uniform sphere with moments of inertia I_1 = I_2 = I_3 , use the Euler equations to find the equation of motion of the sphere.", "options": ["\\omega = 0", "\\omega = N", "\\omega = const", "I = const"], "answer": "C", "solution": "The Euler Equations are I_1 (d\\omega_1/dt) + (I_3 - I_2) \\omega_3 \\omega_2 = N_1 I_2 (d\\omega_2/dt) + (I_1 - I_3) \\omega_1 \\omega_3 = N_2 I_3 (d\\omega_3/dt) + (I_2 - I_1) \\omega_2 \\omega_1 = N_3 where the subscript 1 refers to the first principal axis of the sphere. N and \\omega are the net external torque and angular velocity of the sphere. Noting that I_1 = I_2 = I_3 , we obtain I_1 (d\\omega_1/dt) = N_1 ;I_2 (d\\omega_2/dt) = N_2 ;I_3 = (d\\omega_2/dt) = N_3 Defining I_1 = I_2 = I_3 = I, we may write (d\\omega_1/dt) = (N_1/I) , (d\\omega_2/dt) = (N_2/I) , (d\\omega_1/dt) = (N_3/I)(1) In free motion N = 0, and (1) tells us that \\omega = const. The result \\omega = const is a special feature of the free rotating sphere."}, "question": "task_1"}}, {"data": {"text": "Question:\nm_1 = 5 gv_1 = 3\\^{\\j} + 4k^ cm/sec m_2 = 6 gv_2 = 2\\^{\\j} + 5k^ cm/sec m_3 = 4 gv_3 = \\^{\\j} + 3k^ cm/sec m_4 = 4 gv_4 = - 4\\^{\\j} - 5k^ cm/sec m_5 = 1 gv_5 = -15\\^{\\j} - 2k^ cm/sec Determine the kinetic energy of the system by a) finding the sum of the individual kinetic energies of each particle and by b) finding the velocity of the mass center and using relative velocities of the particles with respect to the mass center.\n\nOptions:\nA. 366 ergs\nB. 380 ergs\nC.             400 ergs\nD. 350 ergs\n\nAnswer: A\n\nReference Solution:\na) The kinetic energy of each particle is given by (1/2)mv^2 where m is the mass of the particle and v is the magnitude of the velocity of the particle. The magnitude of a vector is given by the square root of the sum of the square of each component. Thus (v_1)^2 = 3^2 + 4^2 = 25 (v_2)^2 = 2^2 + 5^2 = 29 (v_3)^2 = 1^2 + 3^2 = 10 (v_4)^2 = (-4)^2 + (-5)^2 = 41 (v_5)^2 = (-15)^2 + (-2)^2 = 229 The total kinetic energy of the system, T, is just the sum of the individual kinetic energies of each particle. T = ^5\\sum_i=1 m_iv_i^2 = (1/2)m_1(v_1)^2 + (1/2)m_2(v_2)^2 + (1/2)m_3(v_3)^2 + (1/2)m_4(v_4)^2 + (1/2)m_5 (v_5)^2 Substituting in the given values yields T = (1/2)(5) 25 + (1/2)(6) 29 + (1/2)(4) 10 + (1/2)(4) 41 + (1/2)(1)229 T = 366 ergs b) Another way to find the total kinetic energy is to find the velocity of the mass center, and the velocity of the particles relative to the mass center. Then the total kinetic energy will be given by finding the kinetic energy value of the total mass traveling at this velocity, and add-ing this to the kinetic energy of each particle traveling at its relative velocity towards the mass center. If M equals the total mass of the system,v_cmequals the velocity of the mass center and u_1, u_2, u_3, u_4, u_5 represent the re-present the relative velocities of each particle with respect to the mass center, then the total kinetic energy will be given by T = (1/2)M (V_cm)^2 + (1/2)m_1 (u_1)^2 + (1/2)m_2 (u_2)^2 + (1/2)m_3 (u_3)^2 + (1/2)m_4 (u_4)^2 + (1/2)m5(u_5)^2(1) The position,r_cm, of the mass center is given by r_cm \\ding{217} = [(m_1 r_1^\\ding{217} + m2r_2^\\ding{217} + m3r_3^\\ding{217} + m4r_4^\\ding{217}_ + m5r_5^\\ding{217}) / (m_1 + m_2 + m_3 + m_4 + m_5)](2) where r_1^\\ding{217}, r_2^\\ding{217}, r_3^\\ding{217}, r_4^\\ding{217}, r_5^\\ding{217} are the position vectors of the particles and the denominator is equal to M. Differentiating with respect to time yields the velo-city of the mass center. (dr_cm^\\ding{217} /dt) =v_cm^\\ding{217} = [(m1v_1^\\ding{217} + m2v_2^\\ding{217} + m3v_3^\\ding{217} + m4v_4^\\ding{217} + m5v_5^\\ding{217}) / (m_1 + m_2 + m_3 + m_4 + m_5)](3) Equation (3) represents a vector equation and there-fore it means there are three scalar equations, one for each component of velocity. Since in this system there are only y and z components of velocity, only 2 equations can be used, In the y direction v_(cm)y \\^{\\j} = [{(5)(3)\\^{\\j} + 6(2)\\^{\\j} + 4(1)\\^{\\j} + 4(-4)\\^{\\j} + (1)(-15)\\^{\\j}} / (5 + 6 + 4 + 4 + 1)] v_(cm)y \\^{\\j} =O\\^{\\j} In the z direction v_(cm)z k^ = [{(5)(4)k^ + 6(5)k^ + 4(3)k^ + 4(-5)k^ + (1)(-2)k^} / 20] v_cm k^ = 2k^ The total velocity of the mass center is then v_cm^\\ding{217} = v_(cm)y \\^{\\j} + v_(cm)z k^ = 2k^ The relative velocity of each component with respect to the mass center is u^\\ding{217} = v^\\ding{217} -v_cm^\\ding{217} Therefore u_1^\\ding{217} = 3\\^{\\j} + 4k^ - 2k^ = 3\\^{\\j} + 2k^ u_2^\\ding{217} = 2\\^{\\j} + 5k^ - 2k^ = 2\\^{\\j} + 3k^ u_3^\\ding{217} = 1\\^{\\j} + 3k^ - 2k^ = 1\\^{\\j} + 1k^ u_4^\\ding{217} = -4\\^{\\j} - 5k^ - 2k^ = - 4\\^{\\j} - 7k^ u_5^\\ding{217} = -15\\^{\\j} - 2k^ - 2k^ = -15\\^{\\j} - 4k^ Also,(u_1)^2 = 3^2 + 2^2 = 13 (u_2)^2 = 2^2 + 3^2 = 13 (u_3)^2 = 1^2 + 1^2 = 2 (u_4)^2 = (-4)^2 + (-7)^2 = 65 (u_5)^2 = (-15)^2 + (-4)^2 = 241 (v_cm)^2 = 0^2 + 2^2 = 4 Since M = 20, we can substitute in equation (1). T = (1/2)(20)(4) + (1/2)(5)(13) + (1/2)(6)(13) + (1/2)(4)(2) + (1/2)(4)(65) + (1/2)(1) (241) T = 366 ergs, which is the same value we obtained before.", "ref_id": 4790, "meta_info": {"subject": "physics.csv", "src": "stemez-Mechanics", "question": "m_1 = 5 gv_1 = 3\\^{\\j} + 4k^ cm/sec m_2 = 6 gv_2 = 2\\^{\\j} + 5k^ cm/sec m_3 = 4 gv_3 = \\^{\\j} + 3k^ cm/sec m_4 = 4 gv_4 = - 4\\^{\\j} - 5k^ cm/sec m_5 = 1 gv_5 = -15\\^{\\j} - 2k^ cm/sec Determine the kinetic energy of the system by a) finding the sum of the individual kinetic energies of each particle and by b) finding the velocity of the mass center and using relative velocities of the particles with respect to the mass center.", "options": ["366 ergs", "380 ergs", "400 ergs", "350 ergs"], "answer": "A", "solution": "a) The kinetic energy of each particle is given by (1/2)mv^2 where m is the mass of the particle and v is the magnitude of the velocity of the particle. The magnitude of a vector is given by the square root of the sum of the square of each component. Thus (v_1)^2 = 3^2 + 4^2 = 25 (v_2)^2 = 2^2 + 5^2 = 29 (v_3)^2 = 1^2 + 3^2 = 10 (v_4)^2 = (-4)^2 + (-5)^2 = 41 (v_5)^2 = (-15)^2 + (-2)^2 = 229 The total kinetic energy of the system, T, is just the sum of the individual kinetic energies of each particle. T = ^5\\sum_i=1 m_iv_i^2 = (1/2)m_1(v_1)^2 + (1/2)m_2(v_2)^2 + (1/2)m_3(v_3)^2 + (1/2)m_4(v_4)^2 + (1/2)m_5 (v_5)^2 Substituting in the given values yields T = (1/2)(5) 25 + (1/2)(6) 29 + (1/2)(4) 10 + (1/2)(4) 41 + (1/2)(1)229 T = 366 ergs b) Another way to find the total kinetic energy is to find the velocity of the mass center, and the velocity of the particles relative to the mass center. Then the total kinetic energy will be given by finding the kinetic energy value of the total mass traveling at this velocity, and add-ing this to the kinetic energy of each particle traveling at its relative velocity towards the mass center. If M equals the total mass of the system,v_cmequals the velocity of the mass center and u_1, u_2, u_3, u_4, u_5 represent the re-present the relative velocities of each particle with respect to the mass center, then the total kinetic energy will be given by T = (1/2)M (V_cm)^2 + (1/2)m_1 (u_1)^2 + (1/2)m_2 (u_2)^2 + (1/2)m_3 (u_3)^2 + (1/2)m_4 (u_4)^2 + (1/2)m5(u_5)^2(1) The position,r_cm, of the mass center is given by r_cm \\ding{217} = [(m_1 r_1^\\ding{217} + m2r_2^\\ding{217} + m3r_3^\\ding{217} + m4r_4^\\ding{217}_ + m5r_5^\\ding{217}) / (m_1 + m_2 + m_3 + m_4 + m_5)](2) where r_1^\\ding{217}, r_2^\\ding{217}, r_3^\\ding{217}, r_4^\\ding{217}, r_5^\\ding{217} are the position vectors of the particles and the denominator is equal to M. Differentiating with respect to time yields the velo-city of the mass center. (dr_cm^\\ding{217} /dt) =v_cm^\\ding{217} = [(m1v_1^\\ding{217} + m2v_2^\\ding{217} + m3v_3^\\ding{217} + m4v_4^\\ding{217} + m5v_5^\\ding{217}) / (m_1 + m_2 + m_3 + m_4 + m_5)](3) Equation (3) represents a vector equation and there-fore it means there are three scalar equations, one for each component of velocity. Since in this system there are only y and z components of velocity, only 2 equations can be used, In the y direction v_(cm)y \\^{\\j} = [{(5)(3)\\^{\\j} + 6(2)\\^{\\j} + 4(1)\\^{\\j} + 4(-4)\\^{\\j} + (1)(-15)\\^{\\j}} / (5 + 6 + 4 + 4 + 1)] v_(cm)y \\^{\\j} =O\\^{\\j} In the z direction v_(cm)z k^ = [{(5)(4)k^ + 6(5)k^ + 4(3)k^ + 4(-5)k^ + (1)(-2)k^} / 20] v_cm k^ = 2k^ The total velocity of the mass center is then v_cm^\\ding{217} = v_(cm)y \\^{\\j} + v_(cm)z k^ = 2k^ The relative velocity of each component with respect to the mass center is u^\\ding{217} = v^\\ding{217} -v_cm^\\ding{217} Therefore u_1^\\ding{217} = 3\\^{\\j} + 4k^ - 2k^ = 3\\^{\\j} + 2k^ u_2^\\ding{217} = 2\\^{\\j} + 5k^ - 2k^ = 2\\^{\\j} + 3k^ u_3^\\ding{217} = 1\\^{\\j} + 3k^ - 2k^ = 1\\^{\\j} + 1k^ u_4^\\ding{217} = -4\\^{\\j} - 5k^ - 2k^ = - 4\\^{\\j} - 7k^ u_5^\\ding{217} = -15\\^{\\j} - 2k^ - 2k^ = -15\\^{\\j} - 4k^ Also,(u_1)^2 = 3^2 + 2^2 = 13 (u_2)^2 = 2^2 + 3^2 = 13 (u_3)^2 = 1^2 + 1^2 = 2 (u_4)^2 = (-4)^2 + (-7)^2 = 65 (u_5)^2 = (-15)^2 + (-4)^2 = 241 (v_cm)^2 = 0^2 + 2^2 = 4 Since M = 20, we can substitute in equation (1). T = (1/2)(20)(4) + (1/2)(5)(13) + (1/2)(6)(13) + (1/2)(4)(2) + (1/2)(4)(65) + (1/2)(1) (241) T = 366 ergs, which is the same value we obtained before."}, "question": "task_1"}}, {"data": {"text": "Question:\nShow that the velocity which a particle must have in order to escape to infinity from a distance r is equal to \\surd2 times the velocity for a stable circular orbit at a distance r.\n\nOptions:\nA. v = \u221a(2GM/r)\nB. v = \u221a2 \u221a(GM/r)\nC.             v = \u221a(GM/2r)\nD. v = 2 \u221a(GM/r)\n\nAnswer: B\n\nReference Solution:\nThe conservation of mechanical energy states that the sum of the potential and kinetic energies of a particle at any point in a conservative field, like gravity, is the same as at any other point in the field. This fact enables us to set up an equation relating a point in the stable circular orbit to a point at infinity: (PE)_r + (KE)_r = (PE)_\\infty + (KE)_\\infty(1) At infinity, \\infty, we define the potential energy, (PE), to be zero. The minimum escape velocity is one which will result in a zero velocity of the particle at infinity. That is, the pull of gravity on the satellite due to the earth brings it to rest at infinity. Therefore the right side of equation (1) is zero, and when we substitute for the left side we get: {(- GmM) / (r)} + {(mv^2) / (2)} = 0(2) or{(GmM) / (r)} = {(mv^2) / (2)}.(3) If we divide the both sides of equation (3) by m and solve for v, we have: v = \\surd2 \\surd(GM/r).(4) (4) (4) The velocity for a stable circular orbit at a distance r is: v = \\surd(GM/r).(5) Hence, we see that if the speed of a satellite in circular orbit is multiplied by the \\surd2, we get the speed required to send the satellite to infinity.", "ref_id": 4791, "meta_info": {"subject": "physics.csv", "src": "stemez-Mechanics", "question": "Show that the velocity which a particle must have in order to escape to infinity from a distance r is equal to \\surd2 times the velocity for a stable circular orbit at a distance r.", "options": ["v = \u221a(2GM/r)", "v = \u221a2 \u221a(GM/r)", "v = \u221a(GM/2r)", "v = 2 \u221a(GM/r)"], "answer": "B", "solution": "The conservation of mechanical energy states that the sum of the potential and kinetic energies of a particle at any point in a conservative field, like gravity, is the same as at any other point in the field. This fact enables us to set up an equation relating a point in the stable circular orbit to a point at infinity: (PE)_r + (KE)_r = (PE)_\\infty + (KE)_\\infty(1) At infinity, \\infty, we define the potential energy, (PE), to be zero. The minimum escape velocity is one which will result in a zero velocity of the particle at infinity. That is, the pull of gravity on the satellite due to the earth brings it to rest at infinity. Therefore the right side of equation (1) is zero, and when we substitute for the left side we get: {(- GmM) / (r)} + {(mv^2) / (2)} = 0(2) or{(GmM) / (r)} = {(mv^2) / (2)}.(3) If we divide the both sides of equation (3) by m and solve for v, we have: v = \\surd2 \\surd(GM/r).(4) (4) (4) The velocity for a stable circular orbit at a distance r is: v = \\surd(GM/r).(5) Hence, we see that if the speed of a satellite in circular orbit is multiplied by the \\surd2, we get the speed required to send the satellite to infinity."}, "question": "task_1"}}, {"data": {"text": "Question:\nABordapendulum is made up of a spherical bob of radius R and a long wire of negligible weight. If the length of the wire from the point of suspension to the center of the bob is l, show that the period of the pendulum for small oscillations is p = 2\\pi \\surd[(l/g){1 + (2/5)(R^2 / l 2 )}]. If this pendulum is considered as a simple pendulum, show that the period calculated on this basis is in error by about 2% when R = (1/5)l.\n\nOptions:\nA. 1.6%\nB. 1.8%\nC.             2.0%\nD. 1.2%\n\nAnswer: A\n\nReference Solution:\nA pendulum is considered simple if the weight at the end of the wire is a point mass. If the shape or size of the weight is of importance then the pendulum is considered to be a compound pendulum. Thus,Borda's pendulum is analyzed as a compound pendulum. The theory of the compound pendulum indicates that the analysis developed for the simple pendulum may be used if l is replaced by k_0^2/h where k_0 is the radius of gyration about the support of the compound pendulum and h is the distance from the support to the center of gravity. The radius of gyration can be obtained by using its defin-ing equation, mk_0^2 = I.(1) The moment of inertia in this problem is obtained by using the parallel axis theorem. The center of mass is the center of the bob, a distance l from the point of suspension. Thus, I = ml^2 + (2/5)mR^2(2) since the moment of inertia of a sphere of radius R through its mass center is (2/5)mR^2. Combining equations (1) and (2) yields k_0^2 = l^2 + (2/5)R^2. As defined above, h is simply equal to l given in the problem. Thus, the simple pendulum equivalent to the given pen-dulum has length l' where l' = (k_0^2 / l) = [{l^2 + (2/5R^2)} / l] = l [1 + (2/5)(R^2 / l^2)].(3) For a simple pendulum, the period is P = 2\\pi \\surd(l/g).(4) Thus, the given pendulum has period P = 2\\pi \\surd[(l/g){1 + (2/5)(R^2 / l^2)}].(5) The period calculated if the pendulum is considered simple is given by equation (4) . The error in equation (4) may be cal-culated using error = [(P_C - P_s) / P_C] \u00d7 100% where P_C = Period of the compound pendulum and P_s = Period of the simple pendulum. Let P_s = 2\\pi\\surd(l/g) = 1 to simplify the calculation. Then, = [\\surd{1 + (2/5)(R^2 / l^2) - 1} / {1 + (2/5)(R^2 / l^2)}] Substituting (R/l) = (1/5) yields error = 1.6%.", "ref_id": 4792, "meta_info": {"subject": "physics.csv", "src": "stemez-Mechanics", "question": "ABordapendulum is made up of a spherical bob of radius R and a long wire of negligible weight. If the length of the wire from the point of suspension to the center of the bob is l, show that the period of the pendulum for small oscillations is p = 2\\pi \\surd[(l/g){1 + (2/5)(R^2 / l 2 )}]. If this pendulum is considered as a simple pendulum, show that the period calculated on this basis is in error by about 2% when R = (1/5)l.", "options": ["1.6%", "1.8%", "2.0%", "1.2%"], "answer": "A", "solution": "A pendulum is considered simple if the weight at the end of the wire is a point mass. If the shape or size of the weight is of importance then the pendulum is considered to be a compound pendulum. Thus,Borda's pendulum is analyzed as a compound pendulum. The theory of the compound pendulum indicates that the analysis developed for the simple pendulum may be used if l is replaced by k_0^2/h where k_0 is the radius of gyration about the support of the compound pendulum and h is the distance from the support to the center of gravity. The radius of gyration can be obtained by using its defin-ing equation, mk_0^2 = I.(1) The moment of inertia in this problem is obtained by using the parallel axis theorem. The center of mass is the center of the bob, a distance l from the point of suspension. Thus, I = ml^2 + (2/5)mR^2(2) since the moment of inertia of a sphere of radius R through its mass center is (2/5)mR^2. Combining equations (1) and (2) yields k_0^2 = l^2 + (2/5)R^2. As defined above, h is simply equal to l given in the problem. Thus, the simple pendulum equivalent to the given pen-dulum has length l' where l' = (k_0^2 / l) = [{l^2 + (2/5R^2)} / l] = l [1 + (2/5)(R^2 / l^2)].(3) For a simple pendulum, the period is P = 2\\pi \\surd(l/g).(4) Thus, the given pendulum has period P = 2\\pi \\surd[(l/g){1 + (2/5)(R^2 / l^2)}].(5) The period calculated if the pendulum is considered simple is given by equation (4) . The error in equation (4) may be cal-culated using error = [(P_C - P_s) / P_C] \u00d7 100% where P_C = Period of the compound pendulum and P_s = Period of the simple pendulum. Let P_s = 2\\pi\\surd(l/g) = 1 to simplify the calculation. Then, = [\\surd{1 + (2/5)(R^2 / l^2) - 1} / {1 + (2/5)(R^2 / l^2)}] Substituting (R/l) = (1/5) yields error = 1.6%."}, "question": "task_1"}}, {"data": {"text": "Question:\nThe moment of a couple is M = \\texttheta^2 + 2\\texttheta ft-lb., where \\texttheta is measuredin radians. If the couple rotates a shaft 60\\textdegree, what workdoes it do?\n\nOptions:\nA. 1.58 ft-lb\nB. 1.28 ft-lb\nC.             1.68 ft-lb\nD. 1.48 ft-lb\n\nAnswer: D\n\nReference Solution:\nThe work done by a torque is given by V =(\\texttheta)2\\int_(\\texttheta)1\u01aed\\texttheta, while the torque \u01ae causes a rotation from\\texttheta_1to \\texttheta_2 . In the given situation, V = ^\\pi/3\\int_0 (\\texttheta^2 + 2\\texttheta)d\\texttheta=\\vert(\\texttheta^3/3) + \\texttheta^2\\vert^\\pi/3_0 = (\\pi^3/81) + (\\pi^2/9) = 1.48 ft-lb.", "ref_id": 4793, "meta_info": {"subject": "physics.csv", "src": "stemez-Mechanics", "question": "The moment of a couple is M = \\texttheta^2 + 2\\texttheta ft-lb., where \\texttheta is measuredin radians. If the couple rotates a shaft 60\\textdegree, what workdoes it do?", "options": ["1.58 ft-lb", "1.28 ft-lb", "1.68 ft-lb", "1.48 ft-lb"], "answer": "D", "solution": "The work done by a torque is given by V =(\\texttheta)2\\int_(\\texttheta)1\u01aed\\texttheta, while the torque \u01ae causes a rotation from\\texttheta_1to \\texttheta_2 . In the given situation, V = ^\\pi/3\\int_0 (\\texttheta^2 + 2\\texttheta)d\\texttheta=\\vert(\\texttheta^3/3) + \\texttheta^2\\vert^\\pi/3_0 = (\\pi^3/81) + (\\pi^2/9) = 1.48 ft-lb."}, "question": "task_1"}}, {"data": {"text": "Question:\nA stone is dropped into a well and the splash is heard two seconds later. If sound travels 1100 ft/sec, what is the depth of the well?\n\nOptions:\nA. 60.6 ft\nB. 70.6 ft\nC.             50.6 ft\nD. 80.6 ft\n\nAnswer: A\n\nReference Solution:\nThe total time to hear the splash is made up of t_1, the time required for the stone to hit the water and t_2 the time required for the sound to travel back, t_1 satisfies: h = 1/2 gt_1 ^2(1) where g = 32.2 ft/sec^2 is the acceleration due to gravity and there is no initial velocity . t_2 satisfies h =v_st_2 wherev_sis the velocity of sound. In both cases the distance travelled is h, thus we may equate the two ex-pressions 1/2 gt_1 ^2 =v_st_2. Upon substitution of available numerical values we find that t_2= [(1/2 gt_1 ^2) / (v_s)] = [(16.1) / (1100)] t_1 ^2 = 0.0146 t_1 ^2. The total time required is 2 sec. Thus, t_1 + t_2 = 2 andt_1 + .0146 t_1 ^2 = 2 or0.146 t_1 ^2 + t_1 - 2 = 0. This equation is solved by means of the quadratic formula, which yields two values for t_1 t_1, _1 t_1, 2 = [(-1 \\pm \\surd{1 - 4 (.0146) (-2)}) / {2 (.0146)}]. The two values are t_1 = 1.94 sec, - 70.4 sec. Negative time has no meaning here therefore we reject it and keep the first of the above values. The depth of the well can now be found from Eq. (1) to be h = 1/2 (32.2) (1.944)^2 h = 60.6 ft.", "ref_id": 4794, "meta_info": {"subject": "physics.csv", "src": "stemez-Mechanics", "question": "A stone is dropped into a well and the splash is heard two seconds later. If sound travels 1100 ft/sec, what is the depth of the well?", "options": ["60.6 ft", "70.6 ft", "50.6 ft", "80.6 ft"], "answer": "A", "solution": "The total time to hear the splash is made up of t_1, the time required for the stone to hit the water and t_2 the time required for the sound to travel back, t_1 satisfies: h = 1/2 gt_1 ^2(1) where g = 32.2 ft/sec^2 is the acceleration due to gravity and there is no initial velocity . t_2 satisfies h =v_st_2 wherev_sis the velocity of sound. In both cases the distance travelled is h, thus we may equate the two ex-pressions 1/2 gt_1 ^2 =v_st_2. Upon substitution of available numerical values we find that t_2= [(1/2 gt_1 ^2) / (v_s)] = [(16.1) / (1100)] t_1 ^2 = 0.0146 t_1 ^2. The total time required is 2 sec. Thus, t_1 + t_2 = 2 andt_1 + .0146 t_1 ^2 = 2 or0.146 t_1 ^2 + t_1 - 2 = 0. This equation is solved by means of the quadratic formula, which yields two values for t_1 t_1, _1 t_1, 2 = [(-1 \\pm \\surd{1 - 4 (.0146) (-2)}) / {2 (.0146)}]. The two values are t_1 = 1.94 sec, - 70.4 sec. Negative time has no meaning here therefore we reject it and keep the first of the above values. The depth of the well can now be found from Eq. (1) to be h = 1/2 (32.2) (1.944)^2 h = 60.6 ft."}, "question": "task_1"}}, {"data": {"text": "Question:\nA rocket has an initial mass of 2 \u00d7 10^4 kg, a mass ratio of 3, a burning rate of 100 kg/sec, and an exhaust velo-city of 980 m/sec. The rocket is fired vertically from the surface of the earth. How long after ignition of the engines will the rocket leave the ground?\n\nOptions:\nA. 50 sec\nB. 150 sec\nC.             200 sec\nD. 100 sec\n\nAnswer: D\n\nReference Solution:\nThe impulsive force exerted on the rocket by the burning fuel is f = (d / dt dt ) (mv) = v(dm /dt ) (mv) = v(dm /dt ) When this exceeds the weight of the remaining mass of the rocket W = mg = [m_0 - (dm /dt)t]g, and the rocket will lift off. Setting (1) equal to (2) gives v(dm/dt) = [m_0 - (dm /dt)t]g Putting in the given quantities, 980(m/sec) (100kg / sec) = [2 \u00d7 10^4 kg - (100kg / sec)t] (9.8m / sec^2). Cancellingapproriateunits and numbers, 100 (100) sec = 2 \u00d7 10^4 sec - 100 t 100 t= (2 \u00d7 10^4 - 10^4) sec t = 100 sec.", "ref_id": 4795, "meta_info": {"subject": "physics.csv", "src": "stemez-Mechanics", "question": "A rocket has an initial mass of 2 \u00d7 10^4 kg, a mass ratio of 3, a burning rate of 100 kg/sec, and an exhaust velo-city of 980 m/sec. The rocket is fired vertically from the surface of the earth. How long after ignition of the engines will the rocket leave the ground?", "options": ["50 sec", "150 sec", "200 sec", "100 sec"], "answer": "D", "solution": "The impulsive force exerted on the rocket by the burning fuel is f = (d / dt dt ) (mv) = v(dm /dt ) (mv) = v(dm /dt ) When this exceeds the weight of the remaining mass of the rocket W = mg = [m_0 - (dm /dt)t]g, and the rocket will lift off. Setting (1) equal to (2) gives v(dm/dt) = [m_0 - (dm /dt)t]g Putting in the given quantities, 980(m/sec) (100kg / sec) = [2 \u00d7 10^4 kg - (100kg / sec)t] (9.8m / sec^2). Cancellingapproriateunits and numbers, 100 (100) sec = 2 \u00d7 10^4 sec - 100 t 100 t= (2 \u00d7 10^4 - 10^4) sec t = 100 sec."}, "question": "task_1"}}, {"data": {"text": "Question:\nThe eccentricity of a particle's orbit in a polar coordinate system can be written as e = [1 + {(2l^2E) / (G^2M^2m^3)}]^1/2 . Show that the energy of an orbit is given by the expression E = [(G^2M^2m^3) / (2l^2)](e^2 - 1) = (GMm/ 2\\mue)(e^2 -1) , where \\mu = [l^2 / (GMm^2e)] . For circular orbits, show that this reduces to E = - (1/2)mv^2.\n\nOptions:\nA. E = (1/2) mv^2\nB. E = mv^2\nC.             E = - (1/2) mv^2\nD. E = - mv^2\n\nAnswer: C\n\nReference Solution:\nStarting with the given expression for eccentricity, we can solve for the total energy, E. Squaring, e^2 = [1 + {(2l^2E) / (G^2M^2m^3)}] .(1) Transposing terms, [(2l^2) / (G^2M^2m^3)] E = e^2 - 1. Finally, dividing both sides by the coefficient of E, E = [{G^2M^2m^3 (e^2 - 1)} / 2l^2] .(2) Multiplying both numerator and denominator of (2) by e, and regrouping terms: E = (GMm^2e / l^2) \\textbullet [{GMm(e^2 - 1)} / 2e](3) This can be written as: E = [{GMm(e^2 - 1)} / 2\\mue](4) where(GMm^2e / l^2) = (1/\\mu) . For circular orbits, the eccentricity, e = 0. Thus, E = - [(G^2M^2m^3) / (2l^2)](5) and the angular momentum l =mvr, where v is the velocity of the particle and r is the radius of the orbit. Equation (5) then reduces to: E = - (1/2) [(G^2M^2m^3) / (m^2v^2r^2)] = - (1/2) [(G^2M^2m^3) / (v^2r^2)] .(6) But, for circular motion of a mass m about a fixed mass M, the force of gravitational attraction equals the centripetal force (equilibrium condition): (GMm/ r^2) = m (v^2/r)(7) orGN = rv^2.(8) Finally, substituting (8) into (6), we gets E = - (1/2) [(r^2v^2 m) / (v^2 r^2)] = - (1/2) mv^2 .", "ref_id": 4796, "meta_info": {"subject": "physics.csv", "src": "stemez-Mechanics", "question": "The eccentricity of a particle's orbit in a polar coordinate system can be written as e = [1 + {(2l^2E) / (G^2M^2m^3)}]^1/2 . Show that the energy of an orbit is given by the expression E = [(G^2M^2m^3) / (2l^2)](e^2 - 1) = (GMm/ 2\\mue)(e^2 -1) , where \\mu = [l^2 / (GMm^2e)] . For circular orbits, show that this reduces to E = - (1/2)mv^2.", "options": ["E = (1/2) mv^2", "E = mv^2", "E = - (1/2) mv^2", "E = - mv^2"], "answer": "C", "solution": "Starting with the given expression for eccentricity, we can solve for the total energy, E. Squaring, e^2 = [1 + {(2l^2E) / (G^2M^2m^3)}] .(1) Transposing terms, [(2l^2) / (G^2M^2m^3)] E = e^2 - 1. Finally, dividing both sides by the coefficient of E, E = [{G^2M^2m^3 (e^2 - 1)} / 2l^2] .(2) Multiplying both numerator and denominator of (2) by e, and regrouping terms: E = (GMm^2e / l^2) \\textbullet [{GMm(e^2 - 1)} / 2e](3) This can be written as: E = [{GMm(e^2 - 1)} / 2\\mue](4) where(GMm^2e / l^2) = (1/\\mu) . For circular orbits, the eccentricity, e = 0. Thus, E = - [(G^2M^2m^3) / (2l^2)](5) and the angular momentum l =mvr, where v is the velocity of the particle and r is the radius of the orbit. Equation (5) then reduces to: E = - (1/2) [(G^2M^2m^3) / (m^2v^2r^2)] = - (1/2) [(G^2M^2m^3) / (v^2r^2)] .(6) But, for circular motion of a mass m about a fixed mass M, the force of gravitational attraction equals the centripetal force (equilibrium condition): (GMm/ r^2) = m (v^2/r)(7) orGN = rv^2.(8) Finally, substituting (8) into (6), we gets E = - (1/2) [(r^2v^2 m) / (v^2 r^2)] = - (1/2) mv^2 ."}, "question": "task_1"}}, {"data": {"text": "Question:\nAt what velocity is the mass of a particle twice its rest mass?\n\nOptions:\nA. 2.664 \u00d7 10^10cm/sec\nB. 1.8 \u00d7 10^10cm/sec\nC.             1.5 \u00d7 10^10cm/sec\nD. 3.2 \u00d7 10^10cm/sec\n\nAnswer: A\n\nReference Solution:\nWhen the mass of an object that is travelling at a velocity approaching the speed of light, c, is measured, it is found to be larger than the mass measured when the object is at rest. The mass associated with an object travelling at any velocity v^\\ding{217} is called the particle's relativistic mass, and is given by the formula m(v) = [m_0 / \\surd{1 - (v^2 / c^2)}](1) where m_0 is the rest mass of the particle. We are asked to find the velocity at which the mass of a particle (meaning its relativistic mass) is equal to twice the particle's rest mass. Writing this as an equation, m(v) = 2m_0 Using (1), this may be written as [m_0 / \\surd{1 - (v^2 / c^2)}] = 2m_0 [1 / \\surd{1 - (v^2 / c^2)}] = 2 Multiplying both sides by (1/2) \\surd{1 - (v^2 / c^2)} , we obtain \\surd{1 - (v^2 / c^2)} = 1/2 1 - (v^2 / c^2) = 1/4 (v^2 / c^2) = 3/4 (v/c) = (\\surd3/2) (v/c) = 0.866 v = 0.866 \u00d7 3 \u00d7 1010cm/sec v = 2.664 \u00d7 1010cm/sec", "ref_id": 4797, "meta_info": {"subject": "physics.csv", "src": "stemez-Mechanics", "question": "At what velocity is the mass of a particle twice its rest mass?", "options": ["2.664 \u00d7 10^10cm/sec", "1.8 \u00d7 10^10cm/sec", "1.5 \u00d7 10^10cm/sec", "3.2 \u00d7 10^10cm/sec"], "answer": "A", "solution": "When the mass of an object that is travelling at a velocity approaching the speed of light, c, is measured, it is found to be larger than the mass measured when the object is at rest. The mass associated with an object travelling at any velocity v^\\ding{217} is called the particle's relativistic mass, and is given by the formula m(v) = [m_0 / \\surd{1 - (v^2 / c^2)}](1) where m_0 is the rest mass of the particle. We are asked to find the velocity at which the mass of a particle (meaning its relativistic mass) is equal to twice the particle's rest mass. Writing this as an equation, m(v) = 2m_0 Using (1), this may be written as [m_0 / \\surd{1 - (v^2 / c^2)}] = 2m_0 [1 / \\surd{1 - (v^2 / c^2)}] = 2 Multiplying both sides by (1/2) \\surd{1 - (v^2 / c^2)} , we obtain \\surd{1 - (v^2 / c^2)} = 1/2 1 - (v^2 / c^2) = 1/4 (v^2 / c^2) = 3/4 (v/c) = (\\surd3/2) (v/c) = 0.866 v = 0.866 \u00d7 3 \u00d7 1010cm/sec v = 2.664 \u00d7 1010cm/sec"}, "question": "task_1"}}, {"data": {"text": "Question:\nA photon rocket is being propelled through space. The pro-pellant consists of photons. The mass of the rocket is not constant throughout the motion, for it continually loses mass in the form of photons. Use the principles of conser-vation of momentum and conservation of energy to show that only about 5 per cent of the mass of the photon rocket re-mains after the rocket has reached a speed of 99.5 per cent of the speed of light.\n\nOptions:\nA. 20 per cent of the original mass\nB. 5 per cent of the original mass\nC.             50 per cent of the original mass\nD. 10 per cent of the original mass\n\nAnswer: B\n\nReference Solution:\nBefore takeoff, the total momentum of the photon-rocket system is zero as the rocket is at rest. Since no external force F acts on the system, then F = 0 =dP/dt where P is the total momentum of the system. Hence P remains constant in time. Consequently, after attaining final speed, the total momentum must still be zero; therefore, the momen-tum of the photons must equal the final spaceship momentum. (These momentum vectors are oppositely directed to give zero total momentum.) When the rocket has reached its final speed, its rest mass will be a fraction f of the original total rest mass m_0. The fraction (1 - f) of the original rest mass has been ejected in the form of photons. total ejected photon momentum = p final rocket momentum = [{(fm_0) v} / {1 - (v^2 / c^2)}] = \\Upsilon (fm_0) v where \\Upsilon = {1 - (v^2 / c^2)} is the relativistic correction of the rest mass due to the rocket velocity. Therefore, by conservation of momentum , p = \\Upsilonfm_0v Since the rocket speedsi99.5 per cent of the speed of light, v may be replaced by c with negligible error. p = \\Upsilonfm_0c The total mass-energy of the rocket system must remain constant in time, for no energy enters or leaves the closed ejected photons and rocket system. Then total initial energy = m_0 c^2 final rocket energy = \\Upsilon (fm_0)c^2 total ejected photon energy = pc since initial energy = final energy m_0c^2 = \\Upsilonfm_0c^2 + pc Substituting for p from the previous equation gives m_0c^2 = \\Upsilonfm_0c^2 + \\Upsilonfm_0c^2 = 2\\Upsilonfm_0c^2 Solving for f, f = 1/2\\Upsilon At a speed of 99.5 per cent c, the value of \\Upsilon is [1 / \\surd{1 - (.995 c / c)^2}] = 1.0 \u00d7 10^1 Therefore,f = [1 / {(2) (1 \u00d7 10^1)}] = 0.05 per cent Therefore, only 5 per cent of the original mass of the rocket remains when the rocket has achieved a speed of 99.5 per cent c.", "ref_id": 4798, "meta_info": {"subject": "physics.csv", "src": "stemez-Mechanics", "question": "A photon rocket is being propelled through space. The pro-pellant consists of photons. The mass of the rocket is not constant throughout the motion, for it continually loses mass in the form of photons. Use the principles of conser-vation of momentum and conservation of energy to show that only about 5 per cent of the mass of the photon rocket re-mains after the rocket has reached a speed of 99.5 per cent of the speed of light.", "options": ["20 per cent of the original mass", "5 per cent of the original mass", "50 per cent of the original mass", "10 per cent of the original mass"], "answer": "B", "solution": "Before takeoff, the total momentum of the photon-rocket system is zero as the rocket is at rest. Since no external force F acts on the system, then F = 0 =dP/dt where P is the total momentum of the system. Hence P remains constant in time. Consequently, after attaining final speed, the total momentum must still be zero; therefore, the momen-tum of the photons must equal the final spaceship momentum. (These momentum vectors are oppositely directed to give zero total momentum.) When the rocket has reached its final speed, its rest mass will be a fraction f of the original total rest mass m_0. The fraction (1 - f) of the original rest mass has been ejected in the form of photons. total ejected photon momentum = p final rocket momentum = [{(fm_0) v} / {1 - (v^2 / c^2)}] = \\Upsilon (fm_0) v where \\Upsilon = {1 - (v^2 / c^2)} is the relativistic correction of the rest mass due to the rocket velocity. Therefore, by conservation of momentum , p = \\Upsilonfm_0v Since the rocket speedsi99.5 per cent of the speed of light, v may be replaced by c with negligible error. p = \\Upsilonfm_0c The total mass-energy of the rocket system must remain constant in time, for no energy enters or leaves the closed ejected photons and rocket system. Then total initial energy = m_0 c^2 final rocket energy = \\Upsilon (fm_0)c^2 total ejected photon energy = pc since initial energy = final energy m_0c^2 = \\Upsilonfm_0c^2 + pc Substituting for p from the previous equation gives m_0c^2 = \\Upsilonfm_0c^2 + \\Upsilonfm_0c^2 = 2\\Upsilonfm_0c^2 Solving for f, f = 1/2\\Upsilon At a speed of 99.5 per cent c, the value of \\Upsilon is [1 / \\surd{1 - (.995 c / c)^2}] = 1.0 \u00d7 10^1 Therefore,f = [1 / {(2) (1 \u00d7 10^1)}] = 0.05 per cent Therefore, only 5 per cent of the original mass of the rocket remains when the rocket has achieved a speed of 99.5 per cent c."}, "question": "task_1"}}, {"data": {"text": "Question:\nAnalyze theBetatronoscillations in a Particle accelerator, by considering theLagrangianfor velocity dependent poten-tials.\n\nOptions:\nA. The motion is stable only if n < 0\nB. The motion is stable only if n = 0\nC.             The motion is stable only if 0 < n < 1\nD. The motion is stable only if n > 1\n\nAnswer: C\n\nReference Solution:\nIn abetatron(or any circular particle accelerator like Cyclotron or Synchrotron), the charged particles move in circular vacuum chambers. Their orbits are con-trolled by the magnetic fields. Since the particles re-volve many times while they are being accelerated, it is essential that the orbits be stable. We shall consider the stability of the orbit at constant energy neglecting the acceleration process. Let us use Cylindrical Polar Coordinates and assume that the magnetic field is symmetrical about the z-axis B^\\ding{217} (\\rho, \\textphi, z) =B_z(\\rho, z)z\u02c4 +B_\\rho(\\rho, z) \\rho\u02c4(1) Since the total energy E is constant, we assume B as con-stant. Let the field be entirely vertical in the median plane z = 0 B^\\ding{217} (\\rho, \\textphi, 0) = B_(z)O (\\rho) z\u02c4(2) The equilibrium orbit depends on the energy E and is given by \\rho = a(E). We are interested in the stability of this orbit and would like to know whether the charged particles execute small oscillations about this orbit. TheLagrangianfor the case of a charged particle moving in a magnetic field alone and no electric field is given by L = T - U whereU = -ev^\\ding{217} \\textbullet A^\\ding{217}(3) where v^\\ding{217} is the velocity of the particle and A^\\ding{217} is the vector potential. The vector potential is related to the magnetic field by B^\\ding{217} = \\nabla^\\ding{217} \u00d7 A^\\ding{217}(4) Where the magnetic field is symmetric about the z-axis, the vector potential is entirely in the \\textphi\u02c4 direction A^\\ding{217} =A_\\textphi(\\rho , z) \\textphi\u02c4(5) From equation (4) we have B_z(\\rho, z) z\u02c4 = (1/\\rho) [(\\partial/\\partial\\rho)\\rhoA_\\textphi] z\u02c4(6) andB\\rho(\\rho, z) \\rho\u02c4 = - (\\partialA_\\textphi/ \\partialz) \\rho\u02c4(7) Equation (6) can be solved forA_\\textphiin terms of the magnetic field. Since the particle is moving in a circular orbit v^\\ding{217} =\\rho\\textphi\u0307\\textphi\u02c4(8) andU = -e\\rho\\textphi\u0307A_\\textphi(\\rho, z)(9) HenceL = (1/2) m(\\rho \u0307^2 + \\rho^2\\textphi \u0307^2 + \\.{z}^2) +e\\rho\\textphi\u0307A_\\textphi(\\rho, z)(10) This expression for theLanrangianis non-relativistic and is useful only for particles whose velocities are much smaller than the velocity of light. (In the realBetatronproblems relativisticLagrangianmust be employed.) The generalizedmomentaare given by P_\\rho= (\\partialL/\\partial\\rho\u0307) =m\\rho\u0307(11) P_\\textphi= m\\rho^2\\textphi \u0307 +e\\rhoA_\\textphi(12) P_z=m\\.{z}(13) The Hamiltonian is given by H = \\sum_ip_iq\u0307_i- L = (p_e^2 / 2m) + (p_z^2 / 2m) + ({[p_\\textphi- (e/c)\\rhoA_\\textphi(\\rho, z)]^2} / 2m\\rho^2)(14) It is easily seen that \\textphi is an ignorable coordinate (not explicitly present in H), sop_\\textphimay be taken as a given constant. This Hamiltonian has the form H = 'T' + 'V' with'T' = (1/2) m(\\rho\u0307^2 + \\.{z}^2)(15) and'V' = [({p_\\textphi- (e/c)\\rhoA_\\textphi}^2) / (2m\\rho^2)](16) where we have used \\textphi \u0307 = [({p_\\textphi- (e/c)\\rhoA_\\textphi} / (2m\\rho^2)] from (12). Here 'T' can be considered to be an effective kinetic energy and ,V' an effective potential energy. The steady state solu-tion is obtained by (\\partial 'V' / \\partialz) = (e/c)\\rho\\textphi\u0307B_\\rho= 0using (7) and (8) and(\\partial 'V' / \\partial\\rho) = -\\rho\\textphi\u0307 [m\\textphi\u0307 + (e/c)B_z] = 0 using (6) and (8) The later equation gives \\textphi \u0307 = (e/cm) B_(z)O (\\rho)(17) We may solve this equation for \\rho given \\textphi \u0307, or alternatively, for \\textphi \u0307 with \\rho = a the radius of the equilibrium orbit. To study the small deviations from the equilibrium orbit, we set \\rho = a + n where a is the equilibrium orbit radius. We also define \\omega = \\textphi \u0307 = [{\\rhoB_z,O(a)} / cm](18) n = - [(a/B_z) (\\partialB_z/ \\partial\\rho)]z=0 , \\rho=a(19) Expanding 'V' and 'T' in powers of n, z \u1e45 and \\.{z}, and using (\\partialV/\\partial\\rho) = 0 and (\\partialV/\\partialz) = 0 at equilibrium, it is not difficult to show that T = (1/2) m(\u1e45^2 + \\.{z}^2)(20) 'V' = (1/2) m\\omega^2 (1 - n) n^2 + (1/2) m\\omega^2 nz^2(21) then deriving (21) it is necessary to use (\\partialB_z/ \\partial\\rho) = (\\partialB_\\rho/ \\partialz) which follows from \\nabla^\\ding{217} \u00d7 B^\\ding{217} = 0. The quantity n is called the field index. We see im-mediately that the motion is stable only if 0 < n < 1. In a cyclotron, the field is nearly constant at the center, so that n << 1, and then falls rapidly near the out-side edge of the magnet. In a betatronor synchrotron, the magnetic field has a constant value of n and B increases in magnitude as the particles are accelerated so as to keep a constant. We see from equation (19) that the value of n does not change asB_zis increased provided the shape of the magnetic field as a function of radius does not change, that is, provided \\partialB_z/\\partialz increases in proportion toB_z. Since the variables x, z are separated in 'T' and 'V', we can immediately write down thebetatronoscillation fre-quencies. It is convenient to express them in terms of the numbers ofbetatron oscillations per revolution,v_xandv_z: v_x= (\\omega_x/ \\omega) = (1 - n)^1/2 v_z= (\\omega_z/ \\omega) = n^1/2. If there are imperfections in the accelerator, so thatB_zis not independent of \\textphi, the difference betweenB_zand its average value gives rise to a periodic force acting on the coordinate x. The resulting perturbation of the orbit can be treated by solving the corresponding forced harmonic oscillator equations. IfB_\\rhois not zero everywhere in the median plane (z = 0), vertical forces act which drive the verticalbetatron oscillations. In general, such imper-fections also lead to variations in the field index n, so that n = n(\\textphi), and n for the steady motion becomes a periodic function of time. In alternating gradient ac-celerators, the field index n is deliberately made to vary periodically in azimuth \\textphi. The solution of this problem is too complex for inclusion here.", "ref_id": 4799, "meta_info": {"subject": "physics.csv", "src": "stemez-Mechanics", "question": "Analyze theBetatronoscillations in a Particle accelerator, by considering theLagrangianfor velocity dependent poten-tials.", "options": ["The motion is stable only if n < 0", "The motion is stable only if n = 0", "The motion is stable only if 0 < n < 1", "The motion is stable only if n > 1"], "answer": "C", "solution": "In abetatron(or any circular particle accelerator like Cyclotron or Synchrotron), the charged particles move in circular vacuum chambers. Their orbits are con-trolled by the magnetic fields. Since the particles re-volve many times while they are being accelerated, it is essential that the orbits be stable. We shall consider the stability of the orbit at constant energy neglecting the acceleration process. Let us use Cylindrical Polar Coordinates and assume that the magnetic field is symmetrical about the z-axis B^\\ding{217} (\\rho, \\textphi, z) =B_z(\\rho, z)z\u02c4 +B_\\rho(\\rho, z) \\rho\u02c4(1) Since the total energy E is constant, we assume B as con-stant. Let the field be entirely vertical in the median plane z = 0 B^\\ding{217} (\\rho, \\textphi, 0) = B_(z)O (\\rho) z\u02c4(2) The equilibrium orbit depends on the energy E and is given by \\rho = a(E). We are interested in the stability of this orbit and would like to know whether the charged particles execute small oscillations about this orbit. TheLagrangianfor the case of a charged particle moving in a magnetic field alone and no electric field is given by L = T - U whereU = -ev^\\ding{217} \\textbullet A^\\ding{217}(3) where v^\\ding{217} is the velocity of the particle and A^\\ding{217} is the vector potential. The vector potential is related to the magnetic field by B^\\ding{217} = \\nabla^\\ding{217} \u00d7 A^\\ding{217}(4) Where the magnetic field is symmetric about the z-axis, the vector potential is entirely in the \\textphi\u02c4 direction A^\\ding{217} =A_\\textphi(\\rho , z) \\textphi\u02c4(5) From equation (4) we have B_z(\\rho, z) z\u02c4 = (1/\\rho) [(\\partial/\\partial\\rho)\\rhoA_\\textphi] z\u02c4(6) andB\\rho(\\rho, z) \\rho\u02c4 = - (\\partialA_\\textphi/ \\partialz) \\rho\u02c4(7) Equation (6) can be solved forA_\\textphiin terms of the magnetic field. Since the particle is moving in a circular orbit v^\\ding{217} =\\rho\\textphi\u0307\\textphi\u02c4(8) andU = -e\\rho\\textphi\u0307A_\\textphi(\\rho, z)(9) HenceL = (1/2) m(\\rho \u0307^2 + \\rho^2\\textphi \u0307^2 + \\.{z}^2) +e\\rho\\textphi\u0307A_\\textphi(\\rho, z)(10) This expression for theLanrangianis non-relativistic and is useful only for particles whose velocities are much smaller than the velocity of light. (In the realBetatronproblems relativisticLagrangianmust be employed.) The generalizedmomentaare given by P_\\rho= (\\partialL/\\partial\\rho\u0307) =m\\rho\u0307(11) P_\\textphi= m\\rho^2\\textphi \u0307 +e\\rhoA_\\textphi(12) P_z=m\\.{z}(13) The Hamiltonian is given by H = \\sum_ip_iq\u0307_i- L = (p_e^2 / 2m) + (p_z^2 / 2m) + ({[p_\\textphi- (e/c)\\rhoA_\\textphi(\\rho, z)]^2} / 2m\\rho^2)(14) It is easily seen that \\textphi is an ignorable coordinate (not explicitly present in H), sop_\\textphimay be taken as a given constant. This Hamiltonian has the form H = 'T' + 'V' with'T' = (1/2) m(\\rho\u0307^2 + \\.{z}^2)(15) and'V' = [({p_\\textphi- (e/c)\\rhoA_\\textphi}^2) / (2m\\rho^2)](16) where we have used \\textphi \u0307 = [({p_\\textphi- (e/c)\\rhoA_\\textphi} / (2m\\rho^2)] from (12). Here 'T' can be considered to be an effective kinetic energy and ,V' an effective potential energy. The steady state solu-tion is obtained by (\\partial 'V' / \\partialz) = (e/c)\\rho\\textphi\u0307B_\\rho= 0using (7) and (8) and(\\partial 'V' / \\partial\\rho) = -\\rho\\textphi\u0307 [m\\textphi\u0307 + (e/c)B_z] = 0 using (6) and (8) The later equation gives \\textphi \u0307 = (e/cm) B_(z)O (\\rho)(17) We may solve this equation for \\rho given \\textphi \u0307, or alternatively, for \\textphi \u0307 with \\rho = a the radius of the equilibrium orbit. To study the small deviations from the equilibrium orbit, we set \\rho = a + n where a is the equilibrium orbit radius. We also define \\omega = \\textphi \u0307 = [{\\rhoB_z,O(a)} / cm](18) n = - [(a/B_z) (\\partialB_z/ \\partial\\rho)]z=0 , \\rho=a(19) Expanding 'V' and 'T' in powers of n, z \u1e45 and \\.{z}, and using (\\partialV/\\partial\\rho) = 0 and (\\partialV/\\partialz) = 0 at equilibrium, it is not difficult to show that T = (1/2) m(\u1e45^2 + \\.{z}^2)(20) 'V' = (1/2) m\\omega^2 (1 - n) n^2 + (1/2) m\\omega^2 nz^2(21) then deriving (21) it is necessary to use (\\partialB_z/ \\partial\\rho) = (\\partialB_\\rho/ \\partialz) which follows from \\nabla^\\ding{217} \u00d7 B^\\ding{217} = 0. The quantity n is called the field index. We see im-mediately that the motion is stable only if 0 < n < 1. In a cyclotron, the field is nearly constant at the center, so that n << 1, and then falls rapidly near the out-side edge of the magnet. In a betatronor synchrotron, the magnetic field has a constant value of n and B increases in magnitude as the particles are accelerated so as to keep a constant. We see from equation (19) that the value of n does not change asB_zis increased provided the shape of the magnetic field as a function of radius does not change, that is, provided \\partialB_z/\\partialz increases in proportion toB_z. Since the variables x, z are separated in 'T' and 'V', we can immediately write down thebetatronoscillation fre-quencies. It is convenient to express them in terms of the numbers ofbetatron oscillations per revolution,v_xandv_z: v_x= (\\omega_x/ \\omega) = (1 - n)^1/2 v_z= (\\omega_z/ \\omega) = n^1/2. If there are imperfections in the accelerator, so thatB_zis not independent of \\textphi, the difference betweenB_zand its average value gives rise to a periodic force acting on the coordinate x. The resulting perturbation of the orbit can be treated by solving the corresponding forced harmonic oscillator equations. IfB_\\rhois not zero everywhere in the median plane (z = 0), vertical forces act which drive the verticalbetatron oscillations. In general, such imper-fections also lead to variations in the field index n, so that n = n(\\textphi), and n for the steady motion becomes a periodic function of time. In alternating gradient ac-celerators, the field index n is deliberately made to vary periodically in azimuth \\textphi. The solution of this problem is too complex for inclusion here."}, "question": "task_1"}}]